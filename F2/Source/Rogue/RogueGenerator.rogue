module F2

$include "CompileErrorTemplate.rogue"
$include "ScannerTemplate.rogue"
$include "TokenTemplate.rogue"

class RogueGenerator : FroleyVisitor
  PROPERTIES
    folder     : String
    writer     : PrintWriter
    class_name = ""

    indent     = 0
    at_newline = true

  METHODS
    method init( program, folder )
      File.create_folder( folder )

      program.nodes.dispatch( this )
      #generate_scanner( forEach in scanners )
      #generate_parser( forEach in parsers )
      #nodes.dispatch( Organizer(this) )

      create_file( cur_module+"CompileError", template_CompileError )
      create_file( cur_module+"Token", template_Token )

      # TokenType
      create_file( cur_module+"TokenType" )
      writeln @|enum $ClassName( symbol:String, attributes=0:Int32 )
               |  ENUMERATE
               |    # TODO: attributes
               |  CATEGORIES
      forEach (def in program.tokens_by_name)
        write  ''    $("$"'' (def.name,to_escaped_ascii(def.symbol,''"''))
        writeln ")"
      endForEach
      writeln @|endEnum
      writer.close

    method create_file( class_name, template=null:String, filename=null:String )
      if (not filename) filename = class_name + ".rogue"

      if (File.exists(filename)) print "Recreating "
      else                       print "Creating "
      println filename

      writer = File(folder/filename).print_writer
      if (template)
        write( template )
        writer.close
      endIf

    method visit( cmd:CastToLogical )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Logical"
      return cmd

    method visit( cmd:CastToCharacter )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Character"
      return cmd

    method visit( cmd:CastToInteger )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Int32"
      return cmd

    method visit( cmd:CastToString )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->String"
      return cmd

    method visit( cmd:Cmd )->Cmd  [override]
      throw cmd.t.error( "Rogue code generation not defined for $."(cmd.type_name) )

    method visit( cmd:CompareEQ )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "=="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareNE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "!="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:ConsumeAny )->Cmd  [override]
      write "scanner.consume_any("
      dispatch( cmd.alternatives )
      write ")"
      return cmd

    method visit( cmd:ConsumeValue )->Cmd  [override]
      write "scanner.consume("
      dispatch( cmd.value )
      write ")"
      return cmd

    method visit( cmd:Decrement )->Cmd  [override]
      write "--"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:If )->Cmd  [override]
      write   "if ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2

      dispatch( cmd.else_ifs )

      if (cmd._else)
        writeln "else"
        indent += 2
        dispatch( cmd._else )
        indent -= 2
      endIf

      write   "endIf"
      return cmd

    method visit( cmd:ElseIf )->Cmd  [override]
      write   "elseIf ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      return cmd

    method visit( cmd:Increment )->Cmd  [override]
      write "++"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:HasNext )->Cmd  [override]
      write "scanner.has_another"
      return cmd

    method visit( cmd:LiteralCharacter )->Cmd  [override]
      which (cmd.value)
        case '\n': write @|'\n'
        case '\r': write @|'\r'
        case '\t': write @|'\t'
        others
          write( "'$'"(to_escaped_ascii(cmd.value,"'")) )
      endWhich
      return cmd

    method visit( cmd:LiteralInt32 )->Cmd  [override]
      writer.print( cmd.value )
      return cmd

    method visit( cmd:LiteralString )->Cmd  [override]
      if (cmd.value.count == 1)
        writer.print( "'$'"(to_escaped_ascii(cmd.value,"'")) )
      else
        writer.print( ''"$"''(to_escaped_ascii(cmd.value,''"'')) )
      endIf
      return cmd

    method visit( cmd:LogicalAnd )->Cmd  [override]
      write "("
      cmd.left.dispatch( this )
      write " and "
      cmd.right.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:LogicalNot )->Cmd  [override]
      write "(not "
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:LogicalOr )->Cmd  [override]
      write "("
      cmd.left.dispatch( this )
      write " or "
      cmd.right.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:Print )->Cmd  [override]
      write "output"
      if (cmd.args.count == 0)
        throw cmd.t.error( "Argument expected for 'print'." )
      else
        forEach (arg in cmd.args)
          write ".print("
          arg.require_value.dispatch( this )
          write ")"
        endForEach
      endIf
      return cmd

    method visit( cmd:Println )->Cmd  [override]
      write "output"
      if (cmd.args.count == 0)
        throw cmd.t.error( "Argument expected for 'println'." )
      else
        forEach (arg in cmd.args)
          write ".print("
          arg.require_value.dispatch( this )
          write ")"
        endForEach
        write ".println"
      endIf
      return cmd

    method visit( cmd:Read )->Cmd  [override]
      write "scanner.read"
      return cmd

    method visit( cmd:ReadVar )->Cmd  [override]
      write cmd.var.name
      return cmd

    method visit( cmd:Return )->Cmd  [override]
      # TODO: save return value first, if needed
      write "return"
      return cmd

    method visit( cmd:RoutineDef )->Cmd  [override]
      writeln "          case ip_$"(cmd.name)

      indent += 12
      prior.visit( cmd )
      indent -= 12

      return cmd

    method visit( cmd:ScannerDef )->Cmd  [override]
      # OutputFolder/XYZScanner.rogue
      create_file( cmd.name, template_Scanner )

      # OutputFolder/XYZScannerCore.rogue
      create_file( cmd.name+"Core" )
      writeln @|$module
               |class $ClassName
               |  DEFINITIONS
      forEach (r in cmd.routines)
        writeln "    ip_$ = $" (r.name,r.ip)
      endForEach

      write   @|
               |  PROPERTIES
               |    filepath   : String
               |    scanner    : Scanner
               |    line       = 1
               |    column     = 1
               |
               |    tokens     = $Token[]
               |    buffer     = StringBuilder()
               |    output     = StringBuilder()
               |
               |    start_ip   = 0
               |    ip         : Int32

      if (cmd.vars.count)
        writeln @|
                 |    # Generated Properties
        local max_w = 0
        max_w .= or_larger( (forEach in cmd.vars).name.count )

        forEach (v in cmd.vars)
          write "    $ : "(v.name.left_justified(max_w))
          which (v.type)
            case Type.NONE
              throw v.t.error( "Cannot determine variable type of '$'. Set to an initial value."(v.name) )
            case Type.LOGICAL
              writeln "Logical"
            case Type.CHARACTER
              writeln "Character"
            case Type.INTEGER
              writeln "Int32"
            case Type.STRING
              writeln "String"
            others
              throw v.t.error( "[INTERNAL] Unhandled type '$'."(v.type) )
          endWhich
        endForEach
      endIf

      writeln @|
               |  METHODS
               |    method init( file:File )
               |      init( file.filepath, Scanner(file) )
               |
               |    method init( filepath:String, content:String )
               |      init( filepath, Scanner(content) )
               |
               |    method init( filepath, scanner )
               |      noAction
               |
               |    method describe_character( c:Character )->String
               |      if (c == 10 or c == 13)       return "end of line";
               |      elseIf (c >= 32 and c != 127) return "'$'" (c)
               |      else                          return "'$'" (c.to_escaped_ascii)
               |
               |    method execute
               |      execute( start_ip )
               |
               |    method t( type:$TokenType, content=null:String )->$Token
               |      return $Token( type, filepath, scanner.source, line, column, content )
               |
               |    method throw_expected_character_error( ch:Character )
               |      local message = "Syntax error - expected $, found " (describe_character(ch))
               |      if (scanner.has_another) message += describe_character(scanner.peek) + "."
               |      else                     message += "end of input."
               |      throw $ModuleNameCompileError( filepath, scanner.source, scanner.line, scanner.column, message )
               |
               |    method throw_syntax_error( message=null:String )
               |      if (not message)
               |        local builder = StringBuilder()
               |        builder.print "Syntax error - unexpected "
               |        if (not scanner.has_another)
               |          builder.println "end of input."
               |        else
               |          builder.print( describe_character(scanner.peek) ).print( '.' )
               |        endIf
               |        message = builder->String
               |      endIf
               |      throw $ModuleNameCompileError( filepath, scanner.source, scanner.line, scanner.column, message )
               |
               |    method execute( ip:Int32 )
               |      loop
               |        ++ip
               |        which (ip-1)

      prior.visit( cmd )

      writeln @|          others
               |            escapeLoop
               |        endWhich
               |      endLoop
               |
               |endClass
      writer.close

      return cmd

    method visit( cmd:Statements )->Cmd  [override]
      forEach (element in cmd)
        if (element)
          element.dispatch( this )
          writeln
        endIf
      endForEach
      return cmd

    method visit( cmd:ScanError )->Cmd  [override]
      write "throw_syntax_error"
      if (cmd.args and cmd.args.count)
        write "("
        forEach (arg at i in cmd.args)
          if (i > 0) write "+"
          cmd.args.dispatch( this )
        endForEach
        write ")"
      endIf
      return cmd

    method visit( cmd:WriteVar )->Cmd  [override]
      write "$ = " (cmd.var.name)
      #write "[$]" (cmd.new_value.type_name)
      dispatch( cmd.new_value )
      return cmd

    method visit( cmd:While )->Cmd  [override]
      write   "while ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      write   "endWhile"
      return cmd

    method write( content:String )
      if (at_newline and indent)
        loop (indent) writer.print(' ')
      endIf

      if (content.contains('$'))
        content .= replacing( "$Token",      "$Token"(cur_module) )
        content .= replacing( "$ClassName",  class_name )
        if (String.exists(cur_module))
          content .= replacing( "$module", "module $\n"(cur_module) )
        else
          content .= replacing( "$module", "" )
        endIf
        content .= replacing( "$ModuleName", cur_module )
      endIf
      writer.print( content )

      at_newline = false

    method writeln( content="":String )
      if (String.exists(content)) write( content )
      writer.println
      at_newline = true

  GLOBAL METHODS
    method to_escaped_ascii( st:String, additional_escapes:String )->String
      return st.to_escaped_ascii( additional_escapes )

endClass
