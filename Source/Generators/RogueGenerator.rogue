$includeFolder "RogueTemplate"

module Froley

Froley.generators//rogue = GenerateRogue()

class GenerateRogue : CodeGenerator
  PROPERTIES
    should_generate_main : Logical

  METHODS
    method usage_options->String[]
      return prior.usage_options.[ add(
        @|    --main
         |      Creates a main file (if it does not yet exist) to test out the parser
         |      and tokenizer.
      ) ]

    method add_option( name:String, value:String )
      which (name)
        case "main"
          should_generate_main = true
          if (value != "") throw FroleyError( "The --main option should not have any arguments." )
        others
          prior.add_option( name, value )
      endWhich

    method output_filepath( filename:String, &do_not_overwrite, &for_reading )->String
      local filepath = output + filename
      if (for_reading) return filepath

      if (File.exists(filepath))
        if (do_not_overwrite) return null
        println "Regenerating " + filepath
      else
        println "Creating " + filepath
      endIf

      return filepath

    method output_writer( filename:String, &do_not_overwrite )->PrintWriter
      local filepath = output_filepath( filename, &=do_not_overwrite )
      if (not filepath) return null

      local writer = PrintWriter( File.writer(filepath) )
      if (not do_not_overwrite)
        writer.println @|# WARNING: This file will be automatically regenerated by the Froley compiler.
                        |# Any edits will be lost!
        writer.println
      endIf
      return writer

    method process( info )
      configure
      output = File.ensure_ends_with_separator( output  )
      File.create_folder( output )

      regenerate_Code
      generate_Error
      generate_Token
      regenerate_TokenType
      generate_Tokenizer
      regenerate_TokenizerOpcode

      if (has_parser)
        generate_Cmd
        generate_Visitor
        regenerate_CmdFactory
        generate_CmdInitArgs
        generate_Parser
        regenerate_ParserOpcode
      endIf

      if (should_generate_main) generate_main

    method generate( content:String, filename:String, content_filter=null:Function(String)->String, &do_not_overwrite )
      local writer = output_writer( filename, &=do_not_overwrite )
      if (not writer) return
      if (content_filter) content = content_filter( content )
      content = content.replacing( "FroleyLanguage", language )
      writer.println( content )
      writer.close

    method generate_Cmd
      generate( RogueTemplate.cmd, "Cmd.rogue", &do_not_overwrite )

      # Update Cmd.rogue by adding new class skeletons
      local filepath = output_filepath( "Cmd.rogue", &for_reading )
      local content = File.load_as_string( filepath )
      local builder : StringBuilder

      # 'constructors' may have many variations using the same class,
      # e.g. LiteralLogical(value=true:Logical) / LiteralLogical(false:Logical).
      # Gather one definition of each diffent type to generate classes from.
      local types = @{}
      forEach (constructor in info//constructors)
        types[ constructor//name ] = constructor
      endForEach

      forEach (constructor in types)
        local base_name = (constructor//name)->String
        local class_name = base_name
        local class_class_name = "class " + class_name
        if (not content.contains(class_class_name))
          if (not builder)
            println "Updating " + filepath
            builder = StringBuilder( content.count * 1.5 )
            builder.println( content )
          endIf
          local type = ParseRuleType( constructor//type )
          print( "  " ).println( class_class_name )
          builder.println.print( class_class_name )

          local cmd_properties = constructor//args
          if (cmd_properties.count)
            builder.print( "( t" )
            forEach (p in cmd_properties)
              builder.print( ", " )
              builder.print( p//name )
              builder.print( ':' )
              if (p//value.count)
                builder.print( p//type )
              else
                builder.print( p//type )
              endIf
            endForEach
            builder.print( " )" )
          endIf

          if (constructor//base_type)
            builder.print( " : " ).println( constructor//base_type )
          else
            which (type)
              case ParseRuleType.PRE_UNARY:  builder.println " : Unary"
              case ParseRuleType.POST_UNARY: builder.println " : PostUnary"
              case ParseRuleType.BINARY:     builder.println " : Binary"
              case ParseRuleType.LIST:       builder.println " : CmdList"
              others:                        builder.println " : Cmd"
            endWhich
          endIf
          builder.println "  METHODS"

          local escaped_symbol = constructor//symbol->String.to_escaped_ascii("\"")
          which (type)
            case ParseRuleType.PRE_UNARY, ParseRuleType.POST_UNARY, ParseRuleType.BINARY
              builder.println "    method op->String"
              builder.println '      return "$"' (escaped_symbol)
            others
              which (type)
                case ParseRuleType.LIST
                  noAction
                others
                  builder.println "    method to->String"
                  which (cmd_properties.count)
                    case 0
                      builder.println ''      return "$"'' (escaped_symbol)
                    others
                      local print_cmd_name = (cmd_properties.count > 1 or cmd_properties.first//value == "")
                      builder.print ''      return "''
                      if (print_cmd_name) builder.print "$("(escaped_symbol)
                      forEach (p at index in cmd_properties)
                        if (index > 0) builder.print ","
                        builder.print "$"
                      endForEach
                      if (print_cmd_name) builder.print ")"
                      builder.print '"'
                      builder.print '('
                      forEach (p at index in cmd_properties)
                        if (index > 0) builder.print ","
                        builder.print p//name
                      endForEach
                      builder.print ')'
                      builder.println
                  endWhich
              endWhich
          endWhich
          builder.println "endClass"
        endIf
      endForEach
      if (builder)
        File.save( filepath, builder->String )
      endIf

    method generate_Visitor
      generate( RogueTemplate.visitor, "Visitor.rogue", &do_not_overwrite )

      # Update Visitor.rogue by adding visit() methods for new classes
      local filepath = output_filepath( "Visitor.rogue", &for_reading )
      local content = File.load_as_string( filepath )
      local builder : StringBuilder
      forEach (constructor in info//constructors)
        local base_name = (constructor//name)->String
        local visit_method_name = "method visit( cmd:$ )->Cmd" (base_name)
        if (not content.contains(visit_method_name))
          if (not builder)
            println "Updating " + filepath
            builder = StringBuilder( content.count * 1.5 )
            local endClass_index = content.locate_last( "endClass" )
            if (endClass_index.exists)
              content = content.substring( 0, endClass_index.value-1 )
            endIf
            builder.println( content )
          endIf

          print( "  " ).println( visit_method_name )
          builder.println.print( "    " ).println( visit_method_name )

          local type = ParseRuleType( constructor//type )
          which (type)
            case ParseRuleType.PRE_UNARY
              builder.println "      if (cmd.operand)  cmd.operand = cmd.operand.dispatch( this )"
              builder.println "      return cmd"
            case ParseRuleType.POST_UNARY
              builder.println "      if (cmd.operand)  cmd.operand = cmd.operand.dispatch( this )"
              builder.println "      return cmd"
            case ParseRuleType.BINARY
              builder.println "      if (cmd.left)  cmd.left  = cmd.left.dispatch( this )"
              builder.println "      if (cmd.right) cmd.right = cmd.right.dispatch( this )"
              builder.println "      return cmd"
            case ParseRuleType.LIST
              builder.println "      forEach (element at index in cmd)"
              builder.println "        if (element) cmd[ index ] = element.dispatch( this )"
              builder.println "      endForEach"
              builder.println "      return cmd"
            others
              local cmd_properties = constructor//args
              forEach (p in cmd_properties)
                which (p//type->String)
                  case "String", "Int64", "Int32", "Real64", "Real32", "Logical", "Byte", "Character"
                    noAction
                  others
                    # Not a primitive
                    local p_name = p//name
                    builder.print "      if (cmd.$) cmd.$ = cmd.$.dispatch( this )" (p_name,p_name,p_name)
                    if (p//type != "Cmd") builder.println " as " + p//type
                    builder.println
                endWhich
              endForEach
              builder.println( "      return cmd" )
          endWhich
        endIf
      endForEach

      if (builder)
        builder.println( "endClass" )
        File.save( filepath, builder->String )
      endIf

    method generate_CmdInitArgs
      generate( RogueTemplate.cmd_init_args, "CmdInitArgs.rogue", &do_not_overwrite )

    method generate_Error
      generate( RogueTemplate.error, "Error.rogue", &do_not_overwrite )

    method generate_main
      if (has_parser)
        generate( RogueTemplate.main_with_tokenizer_and_parser, language+".rogue", &do_not_overwrite )
      else
        generate( RogueTemplate.main_with_tokenizer_only, language+".rogue", &do_not_overwrite )
      endIf

    method generate_Parser
      local fn = function( content:String )->String
        local def = Froley.token_defs_by_symbol[ "\n" ]
        if (def) content = content.replacing( "<handle_consume_eols>", "while (TokenType(next_token_type) == TokenType.$) read"(def.name) )
        return content
      endFunction
      generate( RogueTemplate.parser_vm, "ParserVM.rogue", fn )
      generate( RogueTemplate.parser,    "Parser.rogue",   &do_not_overwrite )

    method generate_Token
      generate( RogueTemplate.token, "Token.rogue", &do_not_overwrite )

    method generate_Tokenizer
      local fn = function( content:String )->String with (info)
        local def = Froley.token_defs_by_symbol[ "\n" ]
        content = content.replacing( "<id_start>", info//id_characters//start->String.to_escaped_ascii("\"") )
        content = content.replacing( "<id_continue>", info//id_characters//continue->String.to_escaped_ascii("\"") )
        return content
      endFunction
      generate( RogueTemplate.tokenizer_vm, "TokenizerVM.rogue", fn )
      generate( RogueTemplate.tokenizer,    "Tokenizer.rogue",   &do_not_overwrite )

    method regenerate_CmdFactory
      local writer = output_writer( "CmdFactory.rogue" )
      if (not writer) return

      writer.print  ("module ").println( language )
      writer.println
      writer.println @|class CmdFactory
                      |  GLOBAL METHODS
                      |    method create_cmd( constructor_index:Int32, args:CmdInitArgs )->Cmd
                      |      local t = args.t
                      |      which (constructor_index)
      forEach (constructor in info//constructors)
        writer.print "        case $: return $( t" (constructor//index,constructor//name)
        if (constructor//args.count == 0)
          local type = ParseRuleType( constructor//type )
          which (type)
            case ParseRuleType.PRE_UNARY
              writer.print ", args[0]"
            case ParseRuleType.POST_UNARY
              writer.print ", args[0]"
            case ParseRuleType.BINARY
              writer.print ", args[0], args[1]"
            case ParseRuleType.LIST
              writer.print ", args"
          endWhich
        else
          local index = 0
          forEach (arg in constructor//args)
            writer.print ", "
            if (String.exists(arg//value->String))
              writer.print arg//value->String  # use this literal value instead of next arg from args()
            else
              writer.print "args"
              if (arg//type == "" or arg//type == "Cmd")
                writer.[ print '[', print index, print ']' ]
              else
                which (arg//type->String)
                  case "Int32", "Logical", "Real64", "String"
                    writer.[ print ".cmd_to<<", print arg//type, print ">>(", print index, print ")" ]
                  others
                    writer.[ print ".cmd_as<<", print arg//type, print ">>(", print index, print ")" ]
                endWhich
              endIf
              ++index
            endIf
          endForEach
        endIf
        writer.println " )"
      endForEach
      writer.println @|        others
      writer.println(''          throw Error( "[INTERNAL] CmdFactory.create_cmd() constructor index out of bounds: " + constructor_index )'' )
      writer.println @|      endWhich
                      |endClass
      writer.close

    method regenerate_Code
      local writer = output_writer( "Code.rogue" )
      if (not writer) return

      writer.print  ("module ").println( language )
      writer.println
      writer.println( "class Code [singleton]" )
      writer.println @|  PROPERTIES
                      |    tokenizer_code_base64 =
      writer.print    "      \""
      writer.print   info//tokenizer_code->String.word_wrap(64).join( "\" ...\n      \"" )
      writer.println "\""
      writer.println

      if (info//parser_code.count)
        writer.println "    parser_code_base64 ="
        writer.print   "      \""
        writer.print   info//parser_code->String.word_wrap(64).join( "\" ...\n      \"" )
        writer.println "\""
        writer.println
      endIf

      writer.println @|  METHODS
                      |    method tokenizer_code->Byte[]
                      |      return tokenizer_code_base64.decode_base64
                      |

      if (has_parser)
        writer.println @|    method parser_code->Byte[]
                        |      return parser_code_base64.decode_base64
                        |
      endIf

      writer.println @|endClass
      writer.close

    method regenerate_ParserOpcode
      local writer = output_writer( "ParserOpcode.rogue" )
      if (not writer) return

      local defs = Int32DefsBuilder( &prefix="  " )
      forEach (parser_opcode in info//parser_opcodes)
        defs.add( parser_opcode//name, parser_opcode//value )
      endForEach

      writer.println( "enum ParserOpcode" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close

    method regenerate_TokenType
      local writer = output_writer( "TokenType.rogue" )
      if (not writer) return

      local attributes_by_value = Table<<Int32,String>>()
      local defs = Int32DefsBuilder( &prefix="  " )
      defs.add( "NONE", 0 )
      forEach (attribute in info//token_attributes)
        local name = attribute//name->String.to_uppercase
        defs.add( name, attribute//value )
        attributes_by_value[ attribute//value ] = name
      endForEach

      writer.println( "enum TokenTypeAttribute" )
      defs.print( writer )
      writer.println @|endEnum
      writer.println.println

      defs = Int32DefsBuilder( &prefix="  " )
      forEach (token_type in info//token_types)
        local def = '$("$"' (token_type//name,token_type//symbol->String.to_escaped_ascii("\""))
        local attributes = token_type//attributes->Int32
        if (attributes)
          def += ",TokenTypeAttribute"
          local name = attributes_by_value[ attributes ]
          if (name) def += "." + name
          else      def += "($)" (attributes)
        endIf
        def += ")"
        defs.add( def, token_type//type )
      endForEach

      writer.println( "enum TokenType( symbol:String, attributes=TokenTypeAttribute.NONE:TokenTypeAttribute )" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close

    method regenerate_TokenizerOpcode
      local writer = output_writer( "TokenizerOpcode.rogue" )
      if (not writer) return

      local defs = Int32DefsBuilder( &prefix="  " )
      forEach (tokenizer_opcode in info//tokenizer_opcodes)
        defs.add( tokenizer_opcode//name, tokenizer_opcode//value )
      endForEach

      writer.println( "enum TokenizerOpcode" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close
endClass
