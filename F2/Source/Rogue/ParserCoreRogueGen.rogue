module F2

class ParserCoreRogueGen( generator, parser_def:ParserDef ) : RogueSourceGen
  METHODS
    method init_object
      class_name = "ParserCore"

    method write_content
      # OutputFolder/XYZParserCore.rogue
      writeln ...
        @|# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
         |class ParserCore [abstract]
         |  DEFINITIONS
      forEach (r in parser_def.routines)
        writeln "    ip_$ = $" (r.name,r.ip)
      endForEach

      writeln ...
        @|
         |  PROPERTIES
         |    _tokens       : Token[]
         |    _position     : Int32
         |    _limit        : Int32
         |    _cmd_stack    = Cmd[]
         |    _token_stack  = Token[]
         |    _token_frames = Int32[]
         |    _cur_t        : Token
         |    start_ip      = 0
         |    ip            = 0
         |    output        = StringBuilder()
         |
         |  METHODS
         |    method init( file:File )
         |      local scanner = Scanner( file )
         |      local tokens = scanner.tokenize
         |      if (scanner.output.count) print scanner.output; flush
         |      init( tokens )
         |
         |    method init( _tokens )
         |      _position = 0
         |      _limit = _tokens.count
         |      _cmd_stack.clear
         |      _token_stack.clear
         |      output.clear
         |
         |    method has_another->Logical
         |      return _position < _limit
         |
         |    method parse( ip=null:Int32? )->Cmd
         |      if (_position == _limit) return null
         |      if (ip) start_ip = ip.value
         |      _token_stack.clear
         |      _token_frames.clear
         |      _cur_t = _tokens[_position]
         |      _execute( start_ip )
         |      if (_cmd_stack.count != 1)
         |        throw _peek.error( "[INTERNAL] Expected exactly one command node remaining on stack." )
         |      endIf
         |      return _cmd_stack.remove_last
         |
         |    method _consume( type:TokenType )->Logical
         |      if (_cur_t.type != type) return false
         |      ++_position
         |      _cur_t = _peek
         |      return true
         |
         |    method _describe( type:TokenType )->String
         |      if (type.symbol[0].is_letter) return type.symbol
         |      return "'$'" (type.symbol)
         |
         |    method _peek->Token
         |      if (_position < _limit) return _tokens[ _position ]
         |      return Token( TokenType.EOI, null, null, 0, 0 )
         |
         |    method _pop_frame
         |      _token_stack.discard_from( _token_frames.remove_last )
         |      _cur_t = _token_stack.remove_last
         |
         |    method _throw_syntax_error( message=null:String, expected=null:TokenType? )
         |      if (message is null)
         |        use builder = StringBuilder.pool
         |          local next = _describe( _peek.type )
         |          if (expected)
         |            builder.print "Expected $, found $." (_describe(expected.value),next)
         |          else
         |            builder.print "Unexpected $." (next)
         |          endIf
         |          message = builder->String
         |        endUse
         |      endIf
         |
         |      throw _peek.error( message )
         |
         |    method _execute( ip:Int32 )
         |      _token_stack.add( _cur_t )
         |      _token_frames.add( _token_stack.count )
         |      loop
         |        ++ip
         |        which (ip-1)

      parser_def.code.dispatch( generator )

      writeln @|          others
               |            return
               |        endWhich
               |      endLoop
               |endClass
endClass
