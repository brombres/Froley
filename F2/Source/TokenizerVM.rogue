# WARNING: This file will be automatically regenerated by the Froley compiler.
# Any edits will be lost!

module F2

$include "Code.rogue"
$include "Error.rogue"
$include "Token.rogue"
$include "TokenType.rogue"
$include "TokenizerOpcode.rogue"

class TokenizerVM
  DEFINITIONS
    MIN_VERSION = 1

  PROPERTIES
    code         = Int32[]
    stack        = Int32[]
    variables    = Int32[]
    strings      = String[]
    entry_points = EntryPoint[]
    ch           : Int32
    result       : Int32
    buffer       = StringBuilder()
    buffer_stack = StringBuilder[]
    tokens       : Token[]

    filepath : String
    scanner  : Scanner

    line   : Int32
    column : Int32

    start_ip = 0

    id_start      = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    id_continue   = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789"
    id_characters = Array<<Int32>>(128)

  METHODS
    method init
      forEach (ch in id_continue) id_characters[ch->Int32] = 2  # '2' = can be start or continue
      forEach (ch in id_start)    id_characters[ch->Int32] = 1  # '1' = can be start only

    method on_custom( name_index:Int32 )
      # Can override this instead of on_custom(String) for higher efficiency vs string compares.
      # name_index can change when the .froley code is updated so don't rely on specific values.
      # But one could set up an array of custom function handlers when the tokenizer is constructed
      # and then index into that.
      on_custom( strings[name_index] )

    method on_custom( name:String )
      println "*** Unhandled custom operation:$ ***" (name)

    method set_mode( new_mode_name:String )
      forEach (entry_point in entry_points)
        if (entry_point.name == new_mode_name)
          start_ip = entry_point.ip
          return
        endIf
      endForEach
      throw UnsupportedOperationError( ''No such mode "$".'' (new_mode_name) )

    method open( file:File )
      if (not file.exists) throw Error( "File not found: $." (file.filepath) )
      open( file.filepath, file.load_as_string )

    method open( filepath, source:String, start_line=1:Int32, start_column=1:Int32 )
      reset
      scanner = Scanner( source )
      scanner.line = start_line
      scanner.column = start_column

    method tokenize( mode=null:String )->Token[]
      if (mode) set_mode( mode )
      tokens = Token[](1024)
      execute
      return tokens

    method reset
      stack.clear
      ch = 0
      result = 0
      buffer.clear
      start_ip = 0

    method add( token_type:Int32 )
      local t = Token( TokenType(token_type), filepath, scanner.source, line, column )
      if (t.type.attributes & TokenTypeAttribute.CONTENT) t.content = buffer->String
      tokens.add( t )

    method describe_character( c:Character )->String
      if (c == 10 or c == 13)       return "end of line";
      elseIf (c == '\'')            return ''"'"''
      elseIf (c >= 32 and c != 127) return "'$'" (c)
      else                          return "'$'" (c.to_escaped_ascii)

    method execute
      local ip = start_ip
      loop
        local opcode = TokenizerOpcode( code[ip] )
        #println "$ $" (ip.format("04"),opcode)
        ++ip
        which (opcode)
          case TokenizerOpcode.HALT
            return
          case TokenizerOpcode.RESTART
            buffer.clear
            ip = start_ip
            nextIteration
          case TokenizerOpcode.MODE_INT32
            start_ip = code[ ip ]
            ++ip
            nextIteration
          case TokenizerOpcode.SYNTAX_ERROR
            throw_syntax_error
          case TokenizerOpcode.SYNTAX_ERROR_BUFFER
            throw_buffer_error
          case TokenizerOpcode.MARK_SOURCE_POS
            line   = scanner.line
            column = scanner.column
            nextIteration
          case TokenizerOpcode.CREATE_INT32
            local token_type = code[ ip ]
            ++ip
            add( token_type )
            buffer.clear
            nextIteration
          case TokenizerOpcode.JUMP
            ip = code[ ip ]
            nextIteration
          case TokenizerOpcode.JUMP_EQ
            if (result == 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case TokenizerOpcode.JUMP_NE
            if (result != 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case TokenizerOpcode.JUMP_LT
            if (result < 0) ip = code[ ip ]
            else            ++ip
            nextIteration
          case TokenizerOpcode.JUMP_LE
            if (result <= 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case TokenizerOpcode.JUMP_GT
            if (result > 0) ip = code[ ip ]
            else            ++ip
            nextIteration
          case TokenizerOpcode.JUMP_GE
            if (result >= 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case TokenizerOpcode.CALL
            stack.add( ip+1 )
            ip = code[ ip ]
            nextIteration
          case TokenizerOpcode.RETURN
            if (stack.is_empty) throw Error( "[INTERNAL]", "'return' on empty stack." )
            ip = stack.remove_last
            nextIteration
          case TokenizerOpcode.HAS_ANOTHER
            result = which{ scanner.has_another:1 || 0 }
            nextIteration
          case TokenizerOpcode.PEEK_CH_INT32
            ch = scanner.peek( code[ip] )
            ++ip
            nextIteration
          case TokenizerOpcode.PEEK_CH_VAR
            ch = scanner.peek( variables[code[ip]] )
            ++ip
            nextIteration
          case TokenizerOpcode.READ_CH
            ch = scanner.read
            nextIteration
          case TokenizerOpcode.CONSUME_CHARACTER
            local value = code[ip]->Character
            result = which{ scanner.consume(value):1 || 0 }
            ++ip
            nextIteration
          case TokenizerOpcode.CONSUME_STRING
            block
              local st = strings[ code[ip] ]
              ++ip
              forEach (ch at index in st)
                if (ch != scanner.peek(index)) result = 0; escapeBlock
              endForEach
              result = 1
              loop (st.count) scanner.read
            endBlock
            nextIteration
          case TokenizerOpcode.MUST_CONSUME_CHARACTER
            local ch = code[ip]->Character
            ++ip
            if (scanner.consume(ch)) nextIteration
            throw_expected_character_error( ch )
          case TokenizerOpcode.NEXT_IS_CHARACTER
            contingent
              necessary (scanner.has_another)
              local peek_ch = scanner.peek
              local low  = code[ip]->Character
              necessary (peek_ch >= low)
              local high = code[ip+1]->Character
              necessary (peek_ch >= high)
              result = 1
            unsatisfied
              result = 0
            endContingent
            ip += 2
            nextIteration
          case TokenizerOpcode.CLEAR_BUFFER
            buffer.clear
            nextIteration
          case TokenizerOpcode.COLLECT_CH
            buffer.print( ch->Character )
            nextIteration
          case TokenizerOpcode.COLLECT_CHARACTER
            buffer.print( code[ip]->Character )
            ++ip
            nextIteration
          case TokenizerOpcode.COLLECT_STRING
            buffer.print( strings[code[ip]] )
            ++ip
            nextIteration
          case TokenizerOpcode.CUSTOM
            ++ip
            on_custom( code[ip-1] )
            nextIteration
          case TokenizerOpcode.BUFFER_TO_LOWERCASE
            local lowercase_buffer = StringBuilder.pool.on_use
            lowercase_buffer.print( (forEach in buffer).to_lowercase )
            StringBuilder.pool.on_end_use( buffer )
            buffer = lowercase_buffer
            nextIteration
          case TokenizerOpcode.COMPARE_BUFFER_STRING
            result = buffer.compare_to( strings[code[ip]] )
            ++ip
            nextIteration
          case TokenizerOpcode.COMPARE_CH_INT32
            result = ch - code[ip]
            ++ip
            nextIteration
          case TokenizerOpcode.COMPARE_VAR_INT32
            result = variables[code[ip]] - code[ip+1]
            ip += 2
            nextIteration
          case TokenizerOpcode.CH_IS_RANGE
            result = (ch >= code[ip] and ch <= code[ip+1])
            ip += 2
            nextIteration
          case TokenizerOpcode.SET_CH_TO_INT32
            ch = code[ ip ]
            result = ch
            ++ip
            nextIteration
          case TokenizerOpcode.SET_CH_TO_VAR
            ch = variables[code[ip]]
            result = ch
            ++ip
            nextIteration
          case TokenizerOpcode.SET_VAR_TO_INT32
            result = code[ip+1]
            variables[code[ip]] = result
            ip += 2
            nextIteration
          case TokenizerOpcode.SET_VAR_TO_CH
            variables[code[ip]] = ch
            result = ch
            ++ip
            nextIteration
          case TokenizerOpcode.SET_RESULT_TO_CH
            result = ch
            nextIteration
          case TokenizerOpcode.SET_RESULT_TO_VAR
            result = variables[code[ip]]
            ++ip
            nextIteration
          case TokenizerOpcode.SET_RESULT_TO_INT32
            result = code[ ip ]
            ++ip
            nextIteration
          case TokenizerOpcode.ADD_CH_INT32
            ch += code[ ip ]
            ++ip
            nextIteration
          case TokenizerOpcode.ADD_VAR_INT32
            variables[code[ip]] += code[ip+1]
            ip += 2
            nextIteration
          case TokenizerOpcode.ADD_VAR_VAR
            variables[code[ip]] += variables[code[ip+1]]
            ip += 2
            nextIteration
          case TokenizerOpcode.SUB_VAR_VAR
            variables[code[ip]] -= variables[code[ip+1]]
            ip += 2
            nextIteration
          case TokenizerOpcode.MUL_VAR_INT32
            variables[code[ip]] *= code[ip+1]
            ip += 2
            nextIteration
          case TokenizerOpcode.DIV_VAR_INT32
            local d = code[ip+1]
            if (d) variables[code[ip]] /= d
            ip += 2
            nextIteration
          case TokenizerOpcode.WHICH_INPUT
            local cur_cmd = ip
            local lookahead = 0
            local last_acceptable_cmd = 0
            local last_acceptable_link_count = 0
            local last_acceptable_lookahead = 0
            loop
              local link_count = code[cur_cmd+1]
              if (code[cur_cmd])
                last_acceptable_cmd = cur_cmd
                last_acceptable_link_count = link_count
                last_acceptable_lookahead = lookahead
              endIf
              if (not scanner.has_another(lookahead+1)) escapeLoop
              local c = scanner.peek( lookahead )
              ip = cur_cmd + 2
              contingent
                loop (link_count)
                  if (c == code[ip])
                    cur_cmd = code[ ip+1 ]
                    sufficient true
                  endIf
                  ip += 2
                endLoop
                escapeLoop
              satisfied
                ++lookahead
              endContingent
            endLoop
            # Either no links match or EOI - jump to code of last acceptable cmd.
            # The start cmd is always acceptable and either contains the
            # 'others' case or jumps to the end of the scan table.
            ip = last_acceptable_cmd + last_acceptable_link_count * 2 + 2

            # Discard the matched input (we know what it is by what case is called)
            loop (last_acceptable_lookahead) scanner.read
            nextIteration

          case TokenizerOpcode.WHICH_BUFFER
            local cur_cmd = ip
            local start_cmd = cur_cmd
            local lookahead = 0
            loop
              local link_count = code[cur_cmd+1]
              if (lookahead == buffer.count) escapeLoop
              local c = buffer[ lookahead ]
              ip = cur_cmd + 2
              contingent
                loop (link_count)
                  if (c == code[ip])
                    cur_cmd = code[ ip+1 ]
                    sufficient true
                  endIf
                  ip += 2
                endLoop
                escapeLoop
              satisfied
                ++lookahead
              endContingent
            endLoop

            # Either no links match or EOI
            if (code[cur_cmd] == 0 or lookahead < buffer.count)
              # Not a complete match; use the 'others' code in the start cmd
              cur_cmd = start_cmd
            endIf
            ip = cur_cmd + code[cur_cmd+1] * 2 + 2
            nextIteration

          case TokenizerOpcode.TRACE
            print( "Line " ).print( code[ip] ).print( " peek:" )
            if (scanner.has_another) print( scanner.peek->Character.to_escaped_ascii )
            else                     print( "EOI" )
            ++ip
            print( " ch:$ ($) result:$ vars:$" (Character(ch).to_escaped_ascii,ch,result,variables) )
            print( " opcode:" ).println( TokenizerOpcode(code[ip]) )
            println( "buffer:" + buffer )
            nextIteration
          others
            throw Error( "[INTERNAL]", "Unhandled tokenizer opcode: " + TokenizerOpcode(opcode) )
        endWhich
      endLoop

    method load( data:Byte[] )
      load( DataReader(data) )

    method load( reader:DataReader )
      local version = reader.read_int32x
      require version >= MIN_VERSION

      local n = reader.read_int32x
      variables.resize( n )
      variables[ forEach of variables ] = 0

      n = reader.read_int32x
      strings.reserve( n )
      loop (n) strings.add( reader.read_string )

      n = reader.read_int32x
      entry_points.reserve( n )
      loop (n)
        local name = strings[ reader.read_int32x ]
        entry_points.add( EntryPoint(name,reader.read_int32x) )
      endLoop

      n = reader.read_int32x
      code.reserve( n )
      loop (n) code.add( reader.read_int32x )

    method throw_buffer_error
      throw Error( filepath, scanner.source, scanner.line, scanner.column, buffer->String )

    method throw_expected_character_error( ch:Character )
      local message = "Syntax error - expected $, found " (describe_character(ch))
      if (scanner.has_another) message += describe_character(scanner.peek) + "."
      else                     message += "end of input."
      throw Error( filepath, scanner.source, scanner.line, scanner.column, message )

    method throw_syntax_error
      local builder = StringBuilder()
      builder.print "Syntax error - unexpected "
      if (not scanner.has_another)
        builder.println "end of input."
      else
        builder.print( describe_character(scanner.peek) ).print( '.' )
      endIf
      throw Error( filepath, scanner.source, scanner.line, scanner.column, builder->String )
endClass

class EntryPoint( name:String, ip:Int32 ) [compound]
  METHODS
    method to->String
      return "$ $" (ip.format("04"),name)
endClass

