module Froley

class RParserCore( generator, parser_def:ParserDef ) : RogueSourceWriter
  METHODS
    method init_object
      class_name = "ParserCore"

    method write_content
      # OutputFolder/ParserCore.rogue
      writeln ...
        @|# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
         |$define PARSER_EXISTS true
         |
         |$include "Cmd.rogue"
         |$include "Scanner.rogue"
         |$include "RebuildVisitor.rogue"
         |
         |class ParserCore [abstract]
         |  DEFINITIONS
      forEach (r in parser_def.routines)
        writeln "    ip_$ = $" (r.name,r.ip)
      endForEach

      writeln ...
        @|
         |  PROPERTIES
         |    _tokens          : Token[]
         |    _position        : Int
         |    _limit           : Int
         |    _cmd_stack       = Cmd[]
         |    _list_starts     = Int[]
         |    _list_tokens     = Token[]
         |    _next_t          : Token
         |    _cur_t           : Token
         |    _saved_positions = ParserPosition[]
         |    start_ip         = 0L
         |    ip               = 0L
         |    buffer           = String()
         |    output           = String()
         |

      if (parser_def.vars.count)
        indent += 4

        local max_w = 0
        max_w .= or_larger( (forEach in parser_def.vars).name.count )

        forEach (v in parser_def.vars)
          write "$ : "(v.name.justified(-max_w))
          which (v.type)
            case FType.LOGICAL
              writeln "Logical"
            case FType.CHARACTER
              writeln "Character"
            case FType.INTEGER
              writeln "Int"
            case FType.REAL
              writeln "Real"
            case FType.STRING
              writeln "String"
            case FType.CMD
              writeln "Cmd"
            others
              throw v.t.error( "[INTERNAL] Unhandled type '$' (1)."(v.type) )
          endWhich
        endForEach

        indent -= 4
      endIf

      writeln ...
        @|
         |  METHODS
         |    method init( file:File )
         |      init( Scanner(file) )
         |
         |    method init( filepath:String, content:String )
         |      init( Scanner(filepath,content) )
         |
         |    method init( scanner:Scanner )
         |      local tokens = scanner.tokenize
         |      if (scanner.output.count) print scanner.output; flush
         |      init( tokens )
         |
         |    method init( _tokens )
         |      _position = 0
         |      _limit = _tokens.count
         |      _cmd_stack.clear
         |      output.clear

      forEach (fn_name in Program.parser_user_calls)
        writeln
        writeln  "    method $ [abstract]" (fn_name)
      endForEach

      writeln ...
        @|
         |    method has_another->Logical
         |      return _position < _limit
         |
         |    method parse( ip=null:Int? )->Cmd
         |      if (_position == _limit) return null
         |      if (ip) start_ip = ip.value
         |      _list_starts.clear
         |      _list_tokens.clear
         |      _next_t = _peek
         |      _cur_t = _next_t
         |      _execute( start_ip )
         |      _on_output_line # flush any buffered output
         |      if (disable_output) return null
         |      if (_cmd_stack.count != 1)
         |        @trace _cmd_stack
         |        throw _peek.error( "[INTERNAL] Expected exactly one command node remaining on stack." )
         |      endIf
         |      return _cmd_stack.remove_last
         |
         |    method _begin_list
         |      _list_starts.add( _cmd_stack.count )
         |      _list_tokens.add( _next_t )
         |
         |    method _consume( type:TokenType )->Logical
         |      if (_next_t.type != type) return false
         |      if (_position < _limit) ++_position; _next_t = _peek
         |      return true
         |
         |    method _consume_content( content:String )->Logical
         |      if (not _next_t.content or _next_t.content != content) return false
         |      if (_position < _limit) ++_position; _next_t = _peek
         |      return true
         |
         |    method _consume_eols
         |      while (_next_t.type == TokenType.EOL)
         |        ++_position
         |        _next_t = _peek
         |      endWhile
         |
         |    method _create_token_list( &preserve_stack )
         |      if (_saved_positions.is_empty)
         |        throw _peek.error( "[INTERNAL] createTokenList/produceTokenlist without prior savePosition." )
         |      endIf
         |      local pos = _saved_positions.remove_last
         |      if (not preserve_stack) _cmd_stack.discard_from( pos.cmd_stack_count )
         |      local i1 = pos.position
         |      local limit = _position
         |      local list = Token[]( limit - i1 )
         |      forEach (i in i1..<limit) list.add( _tokens[i] )
         |      _push( TokenList(_tokens[i1],list), 0 )
         |
         |    method _describe( type:TokenType )->String
         |      if (type.symbol[0].is_letter) return type.symbol
         |      return "'$'" (type.symbol)
         |
         |    method _discard_list
         |      if (_list_tokens.is_empty)
         |        throw _peek.error( "[INTERNAL] discardList without corresponding beginList." )
         |      endIf
         |      _list_starts.remove_last
         |      _list_tokens.remove_last
         |
         |    method _discard_position
         |      if (_saved_positions.is_empty)
         |        throw _peek.error( "[INTERNAL] No savePosition to discard." )
         |      endIf
         |      _saved_positions.remove_last
         |
         |    method _list_t->Token
         |      if (_list_tokens.is_empty)
         |        throw _peek.error( "[INTERNAL] createList/produceList without corresponding beginList." )
         |      endIf
         |      return _list_tokens.remove_last
         |
         |    method _must_consume_content( content:String )
         |      if (_consume_content(content)) return
         |      local expected = which{ content.contains('\''):content || "'$'"(content.to_escaped_ascii) }
         |      local next = _describe( _peek.type )
         |      _throw_syntax_error( "Expected $, found $." (expected,next) )
         |
         |    method _next_is( content:String )->Logical
         |      if (not _next_t.content or _next_t.content != content) return false
         |      if (_position < _limit) ++_position; _next_t = _peek
         |      return true
         |
         |    method _on_output_line
         |      # Default behavior: print out 'output' and clear it. Can override this method.
         |      print( output )
         |      flush
         |      output.clear
         |
         |    method _on_t->Token
         |     local result = _next_t
         |     ++_position
         |     _next_t = _peek
         |     return result
         |
         |    method _peek->Token
         |      if (_position < _limit) return _tokens[ _position ]
         |      if (_tokens.count) return _tokens.last.cloned( TokenType.EOI )
         |      return Token( TokenType.EOI, null, null, 0, 0 )
         |
         |    method _pop->Cmd
         |      if (disable_output)       return null
         |      elseIf (_cmd_stack.count) return _cmd_stack.remove_last
         |      throw _peek.error( "[INTERNAL] Attempt to pop command off empty command stack." )
         |
         |    method _push( cmd:Cmd )
         |      if (not disable_output) _cmd_stack.add( cmd )
         |
         |    method _push( cmd:Cmd, node_arg_count:Int )
         |      if (node_arg_count) _cmd_stack.discard_from( _cmd_stack.count - node_arg_count )
         |      _cmd_stack.add( cmd )
         |
         |    method _push_list( list:Cmd )
         |      local i1 = _list_starts.remove_last
         |      list.add( forEach in _cmd_stack from i1 )
         |      _cmd_stack.discard_from( i1 )
         |      _cmd_stack.add( list )
         |
         |    method _read->Token
         |      local result = _next_t
         |      if (_position < _limit) ++_position; _next_t = _peek
         |      return result
         |
         |    method _restore_position
         |      if (_saved_positions.is_empty)
         |        throw _peek.error( "[INTERNAL] No savePosition to restore." )
         |      endIf
         |      local pos = _saved_positions.remove_last
         |      _position = pos.position
         |      _cmd_stack.discard_from( pos.cmd_stack_count )
         |      _cur_t = pos.cur_t
         |      _next_t = _peek
         |
         |    method _save_position
         |      _saved_positions.add( ParserPosition(_position,_cmd_stack.count,_cur_t) )
         |
         |    method _node_arg( relative:Int )->Cmd
         |      local i = _cmd_stack.count + relative
         |      if (i < 0) throw _peek.error( "[INTERNAL] Not enough nodes on stack to create new Cmd." )
         |      return _cmd_stack[i]
         |
         |    method _logical_arg( relative:Int )->Logical
         |      local node = _node_arg( relative )
         |      if (node is null) return false
         |      return node->Logical
         |
         |    method _character_arg( relative:Int )->Character
         |      local node = _node_arg( relative )
         |      if (node is null) return 0
         |      return node->Character
         |
         |    method _integer_arg( relative:Int )->Int
         |      local node = _node_arg( relative )
         |      if (node is null) return 0
         |      return node->Int
         |
         |    method _real_arg( relative:Int )->Real
         |      local node = _node_arg( relative )
         |      if (node is null) return 0
         |      return node->Real
         |
         |    method _string_arg( relative:Int )->String
         |      local node = _node_arg( relative )
         |      if (node is null) return null
         |      return node->String
         |
         |    method _string_to_Logical( st:String )->Logical
         |      if (st.equals("false",&ignore_case)) return false
         |      return true
         |
         |    method _string_to_Character( st:String )->Character
         |      if (st.count == 0) return Character(0)
         |      return st[0]
         |
         |    method _string_to_Integer( st:String )->Int
         |      return st->Int
         |
         |    method _string_to_Real( st:String )->Real
         |      return st->Real
         |
         |    method _throw_syntax_error( message=null:String, expected=null:TokenType? )
         |      if (message is null)
         |        local builder = String()
         |        local next = _describe( _peek.type )
         |        if (expected)
         |          builder.print "Expected $, found $." (_describe(expected.value),next)
         |        else
         |          builder.print "Unexpected $." (next)
         |        endIf
         |        message = builder
         |      endIf
         |
         |      throw _peek.error( message )
         |
         |    method _execute( ip:Int )
         |      which (ip)
      forEach (r in parser_def.routines)
        writeln "        case ip_$: r_$" (r.name,r.name)
      endForEach
      writeln ...
        @|        others
         |          return
         |      endWhich
         |

      generator.visit( parser_def.routine_defs )

      writeln ...
        @|endClass
         |
         |class ParserPosition( position:Int, cmd_stack_count:Int, cur_t:Token ) [compound];
endClass
