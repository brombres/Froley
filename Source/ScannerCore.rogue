module Froley

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.

$include "CompileError.rogue"
$include "ScanTable.rogue"
$include "Token.rogue"
$include "TokenType.rogue"

class ScannerCore [abstract]
  DEFINITIONS
    ip_scan_standard_token = 0
    ip_scan_charset = 1
    ip_consume_whitespace = 2
    ip_consume_comment = 3
    ip_scan_optional_plain_id = 4
    ip_scan_tokens_id = 5
    ip_scan_token_name = 6
    ip_scan_token_symbol = 7
    ip_scan_token_attributes = 8
    ip_scan_identifier = 9
    ip_must_scan_attribute_identifier = 10
    ip_scan_integer = 11
    ip_scan_single_quoted_string = 12
    ip_scan_double_quoted_string = 13
    ip_scan_literal_character = 14

  PROPERTIES
    _filepath     : String
    _scanner      : ::Scanner
    line          = 1
    column        = 1

    tokens        = Token[]
    buffer        = StringBuilder()
    output        = StringBuilder()

    start_ip      = 0
    ip            : Int32
    halt          = false

    _position_stack = Int32[]

    # GENERATED PROPERTIES
    ch    : Character
    count : Int32
    _scan_pattern_0 = ScanPattern( "[0-9]" )
    _scan_pattern_1 = ScanPattern( "{[a-zA-Z_][a-zA-Z_0-9]*}" )
    _scan_pattern_2 = ScanPattern( "{[a-zA-Z_][a-zA-Z0-9_]*}" )
    _scan_pattern_3 = ScanPattern( "[0-9_]" )
    _scan_table_0 = ScanTable("gQoAFi0uPThAPl5AfUIpRF1GOkgsSi5MW1I+WDxeIWR7aihsK24/dDt2J3gvgQYqgQgSAj40LTYBABMAAgE9PAwAAwAEAAUABgAHAAgACQD/AS5QCgAWAV1WCwAOAT1cDQAQAT1iDwD/AT1oEQAUABUAFwErchgAGQAaAP8BXHz/ASeBAP8BJ4EEGwAcAB0A")
    _scan_table_1 = ScanTable("TgADcAhzHnQ4/wFhDP8BchD/AXMU/wFlGP8BchwBAP8BYyL/AWEm/wFuKv8Bbi7/AWUy/wFyNgIA/wFvPP8Ba0D/AWVE/wFuSP8Bc0wDAA==")
    _scan_table_2 = ScanTable("Ev8ECgpbDF0OLBAAAAEAAgADAA==")
    _scan_table_3 = ScanTable("iToAEnAmc4EgdIIOZYIwYYM6Y4NEZIRGZoUQaIUiaYVQbYVmboZUb4c6codYd4g2YohIQ4h+SYkg/wNhLnJAZYEW/wFyMv8Bczb/AWU6/wFyPgEA/wJpRm9Y/wFuSv8BdE4bAWxS/wFuVhwA/wFkXP8BdWD/AWNk/wFlaB0DTHBOfkGBDP8BaXT/AXN4/wF0fC8A/wF1gQL/AWyBBv8BbIEKMAD/AW6BEP8BeYEUOQD/AWWBGv8Ba4EeOAD/A2OBKGGBPnmBaP8BYYEs/wFugTAiAW6BNP8BZYE4/wFygTwCAP8BdoFC/wFlgUb/AVCBSv8Bb4FO/wFzgVL/AWmBVv8BdIFa/wFpgV7/AW+BYv8BboFmIQD/AW6BbP8BdIFw/wFhgXT/AXiBeP8BRYF8/wFyggD/AXKCBP8Bb4II/wFyggwjAP8Cb4IUcoIm/wFrghj/AWWCHP8BboIg/wFzgiQDAP8BdYIq/wFlgi4kAP8CbII2boJ8/wFzgjr/AWWCPgsCT4JESYJ2/wJugkp0gmQqAU+CTv8BdIJS/wFoglb/AWWCWv8BcoJe/wFzgmIEAP8BaIJo/wFlgmz/AXKCcP8Bc4J0KwD/AWaCegwA/wFkgwD/BEmDCleDEE+DIk2DKP8BZoMODQD/AWiDFP8BaYMY/wFsgxz/AWWDIA4A/wFugyYsAP8BYYMs/wF0gzD/AWODNP8BaIM4NQD/AW6DPv8BZINCBQD/A2GDTG+DXnKEFP8CbINSc4NY/wFsg1YGAP8BZYNcMgD/Am6DZGyEAv8Bc4No/wF1g2z/AW2DcP8BZYN0BwFBg3j/AW6DfP8BeYQACAD/AWyEBv8BZYQK/wFjhA7/AXSEEjQA/wFlhBj/AWGEHP8BdIQg/wFlhCQJAkyEKk6EOP8BaYQu/wFzhDL/AXSENicA/wF1hDz/AWyEQP8BbIREKAD/AWmESv8Bc4RO/wFjhFL/AWGEVv8BcoRa/wFkhF7/AlCEZEyFAv8Bb4Ro/wFzhGz/AWmEcP8BdIR0/wFphHj/AW+EfP8BboUACgD/AWmFBv8Bc4UK/wF0hQ4pAP8BYYUU/wFshRj/AXOFHP8BZYUgDwD/AWGFJv8CbIUsc4Uy/wF0hTAQAP8BQYU2/wFuhTr/AW+FPv8BdIVC/wFohUb/AWWFSv8BcoVOEQD/AmaFVm6FWBIA/wFwhVz/AXWFYP8BdIVkNgD/A2GFbm+GJHWGLv8CcoV0dIYa/wFrhXj/AVCFfP8Bb4YA/wFzhgT/AWmGCP8BdIYM/wFphhD/AW+GFP8BboYYEwD/AWOGHv8BaIYiOgD/AWSGKP8BZYYsFAD/AXOGMv8BdIY2/wFDhjr/AW+GPv8BboZC/wFzhkb/AXWGSv8BbYZO/wFlhlIVAP8CZYZab4cc/wF4hl7/AXSGYv8CSYZoSIZu/wFzhmwWAP8BYYZy/wFzhnb/AUGGev8BdIZ+/wF0hwL/AXKHBv8BaYcK/wFihw7/AXWHEv8BdIcW/wFlhxotAP8CQYcidIc4/wFjhyb/AXSHKv8BaYcu/wFvhzL/AW6HNhcAGAD/A3KHQnSHRG6HVhkA/wFoh0j/AWWHTP8BcodQ/wFzh1QaAC4A/wFlh1z/A2GHZHOHanSIKP8BZIdoHgD/AXSHbv8Cb4d0YYge/wFyh3j/AWWHfP8BUIgA/wFviAT/AXOICP8BaYgM/wF0iBD/AWmIFP8Bb4gY/wFuiBwfAP8Bcogi/wF0iCY7AP8BdYgs/wFyiDD/AW6INCAA/wFoiDr/AWmIPv8BbIhC/wFliEYlAP8CZYhOdYhs/wFniFL/AWmIVv8Bboha/wFMiF7/AWmIYv8Bc4hm/wF0iGomAP8BZohw/wFmiHT/AWWIeP8Bcoh8MQD/AWiJAv8BYYkG/wFyiQr/AWGJDv8BY4kS/wF0iRb/AWWJGv8BcokeMwD/AW6JJP8BdIko/wFliSz/AWeJMP8BZYk0/wFyiTg3AA==")

  METHODS
    method init( file:File )
      init( file.filepath, ::Scanner(file) )
      line   = 1
      column = 1

    method init( filepath:String, content:String, line=1, column=1 )
      init( filepath, ::Scanner(content) )

    method init( _filepath, _scanner )
      noAction

    method execute( ip:Int32 )
      _clear_state
      _execute( ip )

    method tokenize( ip=null:Int32? )->Token[]
      if (ip) start_ip = ip.value
      _clear_state
      while (_execute(start_ip) or not halt)
        buffer.clear
      endWhile
      _on_output_line # flush any buffered output
      return tokens

    method _add( type:TokenType )
      if (type.attributes & TokenType.ATTRIBUTE_CONTENT)
        tokens.add( _t(type,buffer) )
      else
        tokens.add( _t(type) )
      endIf
      buffer.clear

    method _clear_state
      tokens = Token[]
      buffer.clear
      output.clear
      halt = false

    method _describe_character( c:Character )->String
      if (c == 10 or c == 13)       return "end of line";
      elseIf (c >= 32 and c != 127) return "'$'" (c)
      else                          return "'$'" (c.to_escaped_ascii)

    method _is_next( text:String )->Logical
      local location = _scanner.location
      local result = _scanner.consume( text )
      _scanner.location = location
      return result

    method _must_consume( ch:Character )
      if (_scanner.consume(ch)) return
      local message = "Syntax error - expected $, found " (_describe_character(ch))
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _must_consume( st:String )
      if (_scanner.consume(st)) return
      _throw_expected_string_error( "'$'" (st.to_escaped_ascii("'")) )

    method _must_consume( pattern:ScanPattern )
      if (pattern.scan(_scanner)) return
      _throw_expected_string_error( pattern->String )

    method _next_is( text:String )->Logical
      if (not _scanner.has_another(text.count)) return false
      local pos = _scanner.position
      forEach (ch at index in text)
        if (ch != _scanner.data[pos+index]) return false
      endForEach
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output ).flush
      output.clear

    method _scan( ch:Character )->Logical
      if (not _scanner.consume(ch)) return false
      buffer.print ch
      return true

    method _scan( text:String )->Logical
      if (not _scanner.consume(text)) return false
      buffer.print text
      return true

    method _t( type:TokenType, content=null:String )->Token
      return Token( type, _filepath, _scanner.source, line, column, content )

    method _throw_expected_string_error( st:String )
      local message = "Syntax error - expected $, found " (st)
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _throw_syntax_error( message=null:String )
      if (not message)
        local builder = StringBuilder()
        builder.print "Syntax error - unexpected "
        if (not _scanner.has_another)
          builder.println "end of input."
        else
          builder.print( _describe_character(_scanner.peek) ).print( '.' )
        endIf
        message = builder->String
      endIf
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _execute( ip:Int32 )->Logical
      loop
        ++ip
        which (ip-1)
          case ip_scan_standard_token
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            line   = _scanner.line
            column = _scanner.column
            if (_scanner.consume('\n'))
              _add( TokenType.EOL )
              return false
            endIf
            if (not _execute(ip_scan_identifier)) return false
            if (not _execute(ip_scan_single_quoted_string)) return false
            if (not _execute(ip_scan_double_quoted_string)) return false
            if (not _execute(ip_scan_charset)) return false
            _scan_table_0.reset
            contingent
              block n=1
                while (_scanner.has_another(n))
                  if (not _scan_table_0.accept(_scanner.peek(n-1)))
                    escapeWhile
                  endIf
                  ++n
                endWhile
                necessary (_scan_table_0.has_product)
                loop (_scan_table_0.match_count) _scanner.read
              endBlock
              which (_scan_table_0.product)
                case 1
                  _add( TokenType.SYMBOL_ARROW )
                  return false
                case 2
                  _add( TokenType.SYMBOL_ASSIGN )
                  return false
                case 3
                  _add( TokenType.SYMBOL_AT )
                  return false
                case 4
                  _add( TokenType.SYMBOL_CARET )
                  return false
                case 5
                  _add( TokenType.SYMBOL_CLOSE_CURLY )
                  return false
                case 6
                  _add( TokenType.SYMBOL_CLOSE_PAREN )
                  return false
                case 7
                  _add( TokenType.SYMBOL_CLOSE_SQUARE )
                  return false
                case 8
                  _add( TokenType.SYMBOL_COLON )
                  return false
                case 9
                  _add( TokenType.SYMBOL_COMMA )
                  return false
                case 10
                  _add( TokenType.SYMBOL_DOT_DOT )
                  return false
                case 11
                  _add( TokenType.SYMBOL_EMPTY_BRACKETS )
                  return false
                case 12
                  _add( TokenType.SYMBOL_EQ )
                  return false
                case 13
                  _add( TokenType.SYMBOL_GE )
                  return false
                case 14
                  _add( TokenType.SYMBOL_GT )
                  return false
                case 15
                  _add( TokenType.SYMBOL_LE )
                  return false
                case 16
                  _add( TokenType.SYMBOL_LT )
                  return false
                case 17
                  _add( TokenType.SYMBOL_NE )
                  return false
                case 18
                  _add( TokenType.SYMBOL_MINUS )
                  return false
                case 19
                  _add( TokenType.SYMBOL_MINUS_MINUS )
                  return false
                case 20
                  _add( TokenType.SYMBOL_OPEN_CURLY )
                  return false
                case 21
                  _add( TokenType.SYMBOL_OPEN_PAREN )
                  return false
                case 22
                  _add( TokenType.SYMBOL_OPEN_SQUARE )
                  return false
                case 23
                  _add( TokenType.SYMBOL_PLUS )
                  return false
                case 24
                  _add( TokenType.SYMBOL_PLUS_PLUS )
                  return false
                case 25
                  _add( TokenType.SYMBOL_QUESTION )
                  return false
                case 26
                  _add( TokenType.SYMBOL_SEMICOLON )
                  return false
                case 27
                  _add( TokenType.SYMBOL_SINGLE_QUOTE )
                  return false
                case 28
                  _add( TokenType.SYMBOL_SLASH )
                  return false
                case 29
                  _add( TokenType.SYMBOL_STAR )
                  return false
                others
                  necessary (false)
              endWhich
            unsatisfied
              ch = _scanner.peek 
              if (_scan_pattern_0.is_next(_scanner))
                if (not _execute(ip_scan_integer)) return false
                _add( TokenType.INTEGER )
                return false
              endIf
            endContingent
            _throw_syntax_error
          case ip_scan_charset
            if ((not _scanner.consume('[')))
              return true
            endIf
            if (_scanner.consume(']'))
              _add( TokenType.SYMBOL_EMPTY_BRACKETS )
              return false
            endIf
            buffer.print('[')
            while ((_scanner.has_another and (not _scanner.next_is(']'))))
              ch = _scanner.read
              if ((ch=='\\'))
                ch = _scanner.read
                if ((ch=='n'))
                  ch = '\n'
                elseIf ((ch=='r'))
                  ch = '\r'
                elseIf ((ch=='t'))
                  ch = '\t'
                else
                  buffer.print('\\')
                endIf
              endIf
              buffer.print(ch)
            endWhile
            _must_consume( ']' )
            buffer.print(']')
            _add( TokenType.CHARSET )
            return false
          case ip_consume_whitespace
            while ((_scanner.consume(' ') or _scanner.consume('\t')))
            endWhile
            return true
          case ip_consume_comment
            if (_scanner.consume('#'))
              if (_scanner.consume('{'))
                count = 1
                while (_scanner.has_another)
                  ch = _scanner.read
                  if ((ch=='\n'))
                    _add( TokenType.EOL )
                  elseIf ((ch=='#'))
                    if (_scanner.consume('{'))
                      ++count
                    endIf
                  elseIf ((ch=='}'))
                    if (_scanner.consume('#'))
                      --count
                      if ((count==0))
                        return false
                      endIf
                    endIf
                  endIf
                endWhile
                halt = true
                return false
              else
                while (_scanner.has_another)
                  ch = _scanner.read
                  if ((ch=='\n'))
                    _add( TokenType.EOL )
                    return false
                  endIf
                endWhile
                return false
              endIf
            elseIf ((_scanner.consume("----") or _scanner.consume("====")))
              while (_scanner.has_another)
                ch = _scanner.read
                if ((ch=='\n'))
                  _add( TokenType.EOL )
                  return false
                endIf
              endWhile
              return false
            else
              return true
            endIf
          case ip_scan_optional_plain_id
            if ((not _scan_pattern_1.scan(_scanner,buffer)))
              return true
            endIf
            _add( TokenType.IDENTIFIER )
            return false
          case ip_scan_tokens_id
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            line   = _scanner.line
            column = _scanner.column
            start_ip = ip_scan_token_name
            if (_scanner.consume('\n'))
              _add( TokenType.EOL )
              return false
            endIf
            if (not _execute(ip_scan_optional_plain_id)) return false
            _throw_syntax_error("Identifier expected.")
          case ip_scan_token_name
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            line   = _scanner.line
            column = _scanner.column
            start_ip = ip_scan_token_symbol
            if (_scan_pattern_1.scan(_scanner,buffer))
              _scan_table_1.reset
              contingent
                necessary (_scan_table_1.accept(forEach in buffer))
                which (_scan_table_1.product)
                  case 1
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_PARSER )
                    return false
                  case 2
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_SCANNER )
                    return false
                  case 3
                    start_ip = ip_scan_tokens_id
                    _add( TokenType.KEYWORD_TOKENS )
                    return false
                  others
                    necessary (false)
                endWhich
              unsatisfied
                _add( TokenType.IDENTIFIER )
                return false
              endContingent
            endIf
            start_ip = ip_scan_token_name
            if (_scanner.consume('\n'))
              _add( TokenType.EOL )
              return false
            endIf
            _throw_syntax_error("Identifier expected.")
          case ip_scan_token_symbol
            if (_scanner.consume('('))
              while (((_scanner.has_another and (not _scanner.next_is(')'))) and (not _scanner.next_is('\n'))))
                ch = _scanner.read
                buffer.print(ch)
              endWhile
              _must_consume( ')' )
            else
              if (not _execute(ip_consume_whitespace)) return false
              if (_scanner.next_is('\n'))
                start_ip = ip_scan_token_attributes
                return false
              endIf
              while (((_scanner.has_another and (not _scanner.next_is(' '))) and (not _scanner.next_is('\n'))))
                ch = _scanner.read
                buffer.print(ch)
              endWhile
            endIf
            start_ip = ip_scan_token_attributes
            _add( TokenType.SYMBOL )
            return false
          case ip_scan_token_attributes
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            _scan_table_2.reset
            contingent
              block n=1
                while (_scanner.has_another(n))
                  if (not _scan_table_2.accept(_scanner.peek(n-1)))
                    escapeWhile
                  endIf
                  ++n
                endWhile
                necessary (_scan_table_2.has_product)
                loop (_scan_table_2.match_count) _scanner.read
              endBlock
              which (_scan_table_2.product)
                case 0
                  start_ip = ip_scan_token_name
                  _add( TokenType.EOL )
                  return false
                case 1
                  _add( TokenType.SYMBOL_OPEN_SQUARE )
                  return false
                case 2
                  _add( TokenType.SYMBOL_CLOSE_SQUARE )
                  return false
                case 3
                  _add( TokenType.SYMBOL_COMMA )
                  return false
                others
                  necessary (false)
              endWhich
            endContingent
            if (not _execute(ip_must_scan_attribute_identifier)) return false
          case ip_scan_identifier
            ch = _scanner.peek 
            if (_scan_pattern_2.scan(_scanner,buffer))
              _scan_table_3.reset
              contingent
                necessary (_scan_table_3.accept(forEach in buffer))
                which (_scan_table_3.product)
                  case 1
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_PARSER )
                    return false
                  case 2
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_SCANNER )
                    return false
                  case 3
                    start_ip = ip_scan_tokens_id
                    _add( TokenType.KEYWORD_TOKENS )
                    return false
                  case 4
                    _add( TokenType.KEYWORD_ELSE_OTHERS )
                    return false
                  case 5
                    _add( TokenType.KEYWORD_AND )
                    return false
                  case 6
                    _add( TokenType.KEYWORD_CALL )
                    return false
                  case 7
                    _add( TokenType.KEYWORD_CONSUME )
                    return false
                  case 8
                    _add( TokenType.KEYWORD_CONSUME_ANY )
                    return false
                  case 9
                    _add( TokenType.KEYWORD_CREATE )
                    return false
                  case 10
                    _add( TokenType.KEYWORD_DISCARD_POSITION )
                    return false
                  case 11
                    _add( TokenType.KEYWORD_ELSE )
                    return false
                  case 12
                    _add( TokenType.KEYWORD_ELSE_IF )
                    return false
                  case 13
                    _add( TokenType.KEYWORD_END_IF )
                    return false
                  case 14
                    _add( TokenType.KEYWORD_END_WHILE )
                    return false
                  case 15
                    _add( TokenType.KEYWORD_FALSE )
                    return false
                  case 16
                    _add( TokenType.KEYWORD_HALT )
                    return false
                  case 17
                    _add( TokenType.KEYWORD_HAS_NEXT )
                    return false
                  case 18
                    _add( TokenType.KEYWORD_IF )
                    return false
                  case 19
                    _add( TokenType.KEYWORD_MARK_POSITION )
                    return false
                  case 20
                    _add( TokenType.KEYWORD_MODE )
                    return false
                  case 21
                    _add( TokenType.KEYWORD_MUST_CONSUME )
                    return false
                  case 22
                    _add( TokenType.KEYWORD_NEXT_IS )
                    return false
                  case 23
                    _add( TokenType.KEYWORD_NO_ACTION )
                    return false
                  case 24
                    _add( TokenType.KEYWORD_NOT )
                    return false
                  case 25
                    _add( TokenType.KEYWORD_OR )
                    return false
                  case 26
                    _add( TokenType.KEYWORD_OTHERS )
                    return false
                  case 27
                    _add( TokenType.KEYWORD_PRINT )
                    return false
                  case 28
                    _add( TokenType.KEYWORD_PRINTLN )
                    return false
                  case 29
                    _add( TokenType.KEYWORD_PRODUCE )
                    return false
                  case 30
                    _add( TokenType.KEYWORD_READ )
                    return false
                  case 31
                    _add( TokenType.KEYWORD_RESTORE_POSITION )
                    return false
                  case 32
                    _add( TokenType.KEYWORD_RETURN )
                    return false
                  case 33
                    _add( TokenType.KEYWORD_SAVE_POSITION )
                    return false
                  case 34
                    _add( TokenType.KEYWORD_SCAN )
                    return false
                  case 35
                    _add( TokenType.KEYWORD_SYNTAX_ERROR )
                    return false
                  case 36
                    _add( TokenType.KEYWORD_TRUE )
                    return false
                  case 37
                    _add( TokenType.KEYWORD_WHILE )
                    return false
                  case 38
                    _add( TokenType.KEYWORD_BEGIN_LIST )
                    return false
                  case 39
                    _add( TokenType.KEYWORD_CREATE_LIST )
                    return false
                  case 40
                    _add( TokenType.KEYWORD_CREATE_NULL )
                    return false
                  case 41
                    _add( TokenType.KEYWORD_DISCARD_LIST )
                    return false
                  case 42
                    _add( TokenType.KEYWORD_ELSE_ON )
                    return false
                  case 43
                    _add( TokenType.KEYWORD_ELSE_OTHERS )
                    return false
                  case 44
                    _add( TokenType.KEYWORD_END_ON )
                    return false
                  case 45
                    _add( TokenType.KEYWORD_NEXT_HAS_ATTRIBUTE )
                    return false
                  case 46
                    _add( TokenType.KEYWORD_ON )
                    return false
                  case 47
                    _add( TokenType.KEYWORD_PRODUCE_LIST )
                    return false
                  case 48
                    _add( TokenType.KEYWORD_PRODUCE_NULL )
                    return false
                  case 49
                    _add( TokenType.KEYWORD_BUFFER )
                    return false
                  case 50
                    _add( TokenType.KEYWORD_CASE )
                    return false
                  case 51
                    _add( TokenType.KEYWORD_CHARACTER )
                    return false
                  case 52
                    _add( TokenType.KEYWORD_COLLECT )
                    return false
                  case 53
                    _add( TokenType.KEYWORD_END_MATCH )
                    return false
                  case 54
                    _add( TokenType.KEYWORD_INPUT )
                    return false
                  case 55
                    _add( TokenType.KEYWORD_INTEGER )
                    return false
                  case 56
                    _add( TokenType.KEYWORD_PEEK )
                    return false
                  case 57
                    _add( TokenType.KEYWORD_PRODUCE_ANY )
                    return false
                  case 58
                    _add( TokenType.KEYWORD_MATCH )
                    return false
                  case 59
                    _add( TokenType.KEYWORD_RESTART )
                    return false
                  others
                    necessary (false)
                endWhich
              unsatisfied
                _add( TokenType.IDENTIFIER )
                return false
              endContingent
            endIf
            return true
          case ip_must_scan_attribute_identifier
            if (_scan_pattern_2.scan(_scanner,buffer))
              _add( TokenType.IDENTIFIER )
              return false
            endIf
            _throw_syntax_error("Identifier expected.")
          case ip_scan_integer
            while (_scan_pattern_3.is_next(_scanner))
              ch = _scanner.read
              if ((ch!='_'))
                buffer.print(ch)
              endIf
              if ((not _scanner.has_another))
                return true
              endIf
              ch = _scanner.peek 
            endWhile
            return true
          case ip_scan_single_quoted_string
            if ((not _scanner.consume('\'')))
              return true
            endIf
            while (_scanner.has_another)
              if (_scanner.consume('\''))
                _add( TokenType.STRING_OR_CHARACTER )
                return false
              endIf
              if (_scanner.next_is('\n'))
                _throw_syntax_error("Unterminated string.")
              endIf
              if (not _execute(ip_scan_literal_character)) return false
            endWhile
            _throw_syntax_error("Unterminated string.")
          case ip_scan_double_quoted_string
            if ((not _scanner.consume('"')))
              return true
            endIf
            while (_scanner.has_another)
              if (_scanner.consume('"'))
                _add( TokenType.STRING )
                return false
              endIf
              if (_scanner.next_is('\n'))
                _throw_syntax_error("Unterminated string.")
              endIf
              if (not _execute(ip_scan_literal_character)) return false
            endWhile
            _throw_syntax_error("Unterminated string.")
          case ip_scan_literal_character
            ch = _scanner.read
            if ((ch=='\\'))
              ch = _scanner.read
              if ((ch=='n'))
                ch = '\n'
              endIf
              if ((ch=='r'))
                ch = '\r'
              endIf
              if ((ch=='t'))
                ch = '\t'
              endIf
            endIf
            buffer.print(ch)
            return true
          others
            halt = true
            return false
        endWhich
      endLoop

endClass
