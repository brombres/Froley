[tokens]
EOL                 EOL
CHARSET             charset    [content]
IDENTIFIER          identifier [content]
INTEGER             integer    [content]
STRING              string     [content]
STRING_OR_CHARACTER string     [content]
SYMBOL              symbol     [content]

[attributes]
structural

[section_keywords]
KEYWORD_PARSER          parser      [structural]
KEYWORD_SCANNER         scanner     [structural]
KEYWORD_TOKENS          tokens      [structural]

[scanner_keywords]
KEYWORD_BUFFER           buffer
KEYWORD_CASE             case
KEYWORD_COLLECT          collect
KEYWORD_END_MATCH        endMatch    [structural]
KEYWORD_INPUT            input
KEYWORD_PRODUCE_ANY      produceAny
KEYWORD_MATCH            match
KEYWORD_RESTART          restart

[parser_keywords]
KEYWORD_BEGIN_LIST       beginList
KEYWORD_CREATE_LIST      createList
KEYWORD_ELSE_ON          elseOn       [structural]
KEYWORD_ELSE_ON_OTHERS   elseOnOthers [structural]
KEYWORD_END_ON           endOn        [structural]
KEYWORD_ON               on
KEYWORD_PRODUCE_LIST     produceList

[common_keywords]
KEYWORD_AND              and
KEYWORD_CALL             call
KEYWORD_CONSUME          consume
KEYWORD_CONSUME_ANY      consumeAny
KEYWORD_CREATE           create
KEYWORD_DISCARD_POSITION discardPosition
KEYWORD_ELSE             else        [structural]
KEYWORD_ELSE_IF          elseIf      [structural]
KEYWORD_END_IF           endIf       [structural]
KEYWORD_END_WHILE        endWhile    [structural]
KEYWORD_FALSE            false
KEYWORD_HALT             halt
KEYWORD_HAS_NEXT         hasAnother
KEYWORD_IF               if
KEYWORD_MARK_POSITION    markPosition
KEYWORD_MODE             mode
KEYWORD_MUST_CONSUME     mustConsume
KEYWORD_NEXT_IS          nextIs
KEYWORD_NO_ACTION        noAction
KEYWORD_NOT              not
KEYWORD_OR               or
KEYWORD_OTHERS           others      [structural]
KEYWORD_PRINT            print
KEYWORD_PRINTLN          println
KEYWORD_PRODUCE          produce
KEYWORD_READ             read
KEYWORD_RESTORE_POSITION restorePosition
KEYWORD_RETURN           return
KEYWORD_SAVE_POSITION    savePosition
KEYWORD_SCAN             scan
KEYWORD_SYNTAX_ERROR     syntaxError
KEYWORD_TRUE             true
KEYWORD_WHILE            while

[symbols]
SYMBOL_ARROW          ->  [structural]
SYMBOL_ASSIGN         =
SYMBOL_AT             @
SYMBOL_CARET          ^
SYMBOL_CLOSE_CURLY    }   [structural]
SYMBOL_CLOSE_PAREN    )   [structural]
SYMBOL_CLOSE_SQUARE   ]   [structural]
SYMBOL_COLON          :   [structural]
SYMBOL_COMMA          ,
SYMBOL_DOT_DOT        ..
SYMBOL_EMPTY_BRACKETS []
SYMBOL_EQ             ==
SYMBOL_GE             >=
SYMBOL_GT             >
SYMBOL_LE             <=
SYMBOL_LT             <
SYMBOL_NE             !=
SYMBOL_MINUS          -
SYMBOL_MINUS_MINUS    --
SYMBOL_OPEN_CURLY     {
SYMBOL_OPEN_PAREN     (
SYMBOL_OPEN_SQUARE    [
SYMBOL_PLUS           +
SYMBOL_PLUS_PLUS      ++
SYMBOL_QUESTION       ?
SYMBOL_SEMICOLON      ;    [structural]
SYMBOL_SINGLE_QUOTE   '\''
SYMBOL_SLASH          /
SYMBOL_STAR           *
SYMBOL_T_CONTENT      t.content

[tokenizer]
+ scan_standard_token
  if (not hasAnother) halt

  consume_whitespace
  consume_comment

  markSourcePosition

  if (consume('\n')) produce EOL

  scan_identifier
  scan_single_quoted_string
  scan_double_quoted_string
  scan_charset

  which (input)
    produceAny [symbols]
    others
      ch = peek
      if (ch is '0'..'9')
        scan_integer
        produce INTEGER
      endIf
  endWhich

  syntaxError

- scan_charset
  if (not consume('[')) return
  if (consume(']')) produce SYMBOL_EMPTY_BRACKETS

  collect '['
  while (hasAnother and not nextIs(']'))
    ch = read
    if (ch == '\\')
      ch = read
      if (ch == 'n')     ch = '\n'
      elseIf (ch == 'r') ch = '\r'
      elseIf (ch == 't') ch = '\t'
      else               collect '\\'  # leave the slash
    endIf
    collect ch
  endWhile

  mustConsume ']'
  collect ']'
  produce CHARSET

- consume_whitespace
  while (consume(' ') or consume('\t')) noAction
  return

- consume_comment
  if (not consume('#')) return
  if (consume('{'))
    @count = 1
    while (hasAnother)
      ch = read
      if (ch == '\n')
        create EOL
      elseIf (ch == '#')
        if (consume('{')) @count += 1
      elseIf (ch == '}')
        if (consume('#'))
          @count -= 1
          if (@count == 0) restart
        endIf
      endIf
    endWhile
    halt
  else
    # Single line comment
    while (hasAnother)
      ch = read
      if (ch == '\n') produce EOL
    endWhile
    restart
  endIf

- scan_tokens_id
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  markSourcePosition
  mode scan_token_name

  if (consume('\n')) produce EOL

  scan_identifier
  syntaxError "Identifier expected."

- scan_token_name
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  if (nextIs('-')) restart scan_standard_token

  markSourcePosition
  mode scan_token_symbol
  scan_identifier

  mode scan_token_name
  if (consume('\n')) produce EOL
  syntaxError "Identifier expected."

- scan_token_symbol
  # TOKEN_ID(symbol)
  # TOKEN_ID symbol
  if (consume('('))
    while (hasAnother and not nextIs(')') and not nextIs('\n'))
      ch = read
      collect ch
    endWhile
    mustConsume(')')

  else
    consume_whitespace

    if (nextIs('[') or nextIs('\n')) restart scan_token_attributes

    # Scan everything to the next space
    while (hasAnother and not nextIs(' ') and not nextIs('\n'))
      ch = read
      collect ch
    endWhile
  endIf

  mode scan_token_attributes
  produce SYMBOL

- scan_token_attributes
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  which (input)
    case '\n': mode scan_token_name; produce EOL
    case '[':  produce SYMBOL_OPEN_SQUARE
    case ']':  produce SYMBOL_CLOSE_SQUARE
    case ',':  produce SYMBOL_COMMA
  endWhich

  must_scan_attribute_identifier

- scan_identifier
  ch = peek
  if (ch is 'a'..'z' or ch is 'A'..'Z' or ch == '_')
    collect_identifier

    which (buffer)
      case "parser"
        mode scan_standard_token
        produce KEYWORD_PARSER
      case "scanner"
        mode scan_standard_token
        produce KEYWORD_SCANNER
      case "tokens"
        mode scan_tokens_id
        produce KEYWORD_TOKENS
      produceAny [common_keywords]
      produceAny [parser_keywords]
      produceAny [scanner_keywords]
      others
        produce IDENTIFIER
    endWhich
  endIf
  return

- must_scan_attribute_identifier
  ch = peek
  if (ch is 'a'..'z' or ch is 'A'..'Z' or ch == '_')
    collect_identifier
    produce IDENTIFIER
  endIf
  syntaxError "Identifier expected."

- collect_identifier
  clear buffer

  ch = peek
  while (ch is 'a'..'z' or ch is 'A'..'Z' or ch is '0'..'9' or ch == '_')
    ch = read
    collect ch
    ch = peek
    if (ch == '/')
      ch = peek(1)
      if (ch == '/') ch = read; collect ch; ch = read; collect ch
      ch = peek
    endIf
  endWhile

  return

- scan_integer
  while (ch is '0'..'9' or ch == '_')
    ch = read
    if (ch != '_') collect ch
    if (not hasAnother) return
    ch = peek
  endWhile
  return

- scan_single_quoted_string
  if (not consume('\'')) return
  while (hasAnother)
    if (consume('\''))
      produce STRING_OR_CHARACTER
    endIf
    if (nextIs('\n')) syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_double_quoted_string
  if (not consume('"')) return
  while (hasAnother)
    if (consume('"')) produce STRING
    if (nextIs('\n')) syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_literal_character
  ch = read
  if (ch == '\\')
    ch = read
    if (ch == 'n') ch = '\n'
    if (ch == 'r') ch = '\r'
    if (ch == 't') ch = '\t'
  endIf
  collect ch
  return

[parser]
+ program
  beginList

  while (consume(EOL)) noAction

  while (hasAnother)
    element
    while (consume(EOL)) noAction
  endWhile

  produceList

+ element
  on "scanner"
    createNull
    must_consume_eols
    scanner_routines
    produce ScannerDef(name:String,code:CmdList)

  elseOn "parser"
    createNull
    must_consume_eols
    parser_routines
    produce ParserDef(name:String,code:CmdList)

  elseOn "tokens"
    if (consume(EOL)) createNull
    else              identifier
    token_definitions
    produce TokenGroup(name:String,definitions:CmdList)
  endOn
  syntaxError

+ identifier
  on IDENTIFIER -> Identifier(name=t.content:String)
  syntaxError "Identifier expected."

+ scanner_routines
  beginList

  consume_eols
  while nextIs('-')
    on "-"
      routine_name_and_attributes
      scanner_multi_line_statements
      create Routine(name:String,attributes:String,statements:Statements)
    endOn
    consume_eols
  endWhile

  produceList

+ routine_name_and_attributes
  identifier
  on CHARSET
    create LiteralString(value=t.content:String)
  else
    createNull
  endOn
  must_consume_eols

+ token_definitions
  beginList

  consume_eols
  while (hasAnother and not nextHasAttribute(structural))
    identifier

    if (nextIs(SYMBOL)) symbol
    else                createNull

    attributes

    create TokenDef(name:String,symbol:String,attributes:CmdList)
    consume_eols
  endWhile

  produceList

+ attributes
  if (not consume('[')) produceNull
  if (consume(']'))     produceNull

  beginList
  identifier
  while (consume(',') or not nextIs(']'))
    if (not hasAnother or nextIs(EOL)) syntaxError "Closing ']' expected."
    identifier
  endWhile
  mustConsume(']')
  produceList

+ symbol
  on SYMBOL -> Symbol(name=t.content:String)
  syntaxError "Symbol expected."

+ consume_eols
  while (consume(EOL)) noAction

+ must_consume_eols
  mustConsume(EOL)
  while (consume(EOL)) noAction

+ scanner_multi_line_statements
  consume_eols
  if (not hasAnother) syntaxError
  beginList
  while (hasAnother and not (nextIs('+') or nextIs('-') or nextHasAttribute(structural)))
    scanner_control_structure
    consume_eols
  endWhile
  produceList Statements

+ scanner_single_line_statements
  beginList

  if (consume(EOL)) produceList Statements
  scanner_statement
  while (consume(';'))
    consume_eols
    scanner_statement
  endWhile
  must_consume_eols

  produceList Statements

+ scanner_control_structure
  on "if"
    if (consume("("))
      scanner_expression
      mustConsume( ")" )
    else
      scanner_expression
    endIf
    if (consume(EOL))
      scanner_multi_line_statements
      scanner_multi_line_else_ifs
      scanner_multi_line_else
      mustConsume( "endIf" )
    else
      scanner_single_line_statements
      scanner_single_line_else_ifs
      scanner_single_line_else
    endIf
    produce If( condition, statements:Statements, else_ifs:CmdList, _else:Statements )
  endOn

  on "match"
    if (consume(EOL) or consume("input"))
      createNull
    else
      scanner_expression
    endIf
    cases
    _others
    mustConsume "endMatch"
    produce Match(scanner_expression,cases:CmdList,_others:Cmd)
  endOn

  on "while"
    if (consume("("))
      scanner_expression
      mustConsume( ")" )
    else
      scanner_expression
    endIf
    if (consume(EOL))
      scanner_multi_line_statements
      mustConsume( "endWhile" )
    else
      scanner_single_line_statements
    endIf
    produce While( condition, statements:Statements )
  endOn

  scanner_statement

+ cases
  beginList
    consume_eols
    while (hasAnother)
      consume_eols
      on "case"
        scanner_expression
        if (consume("->"))
          beginList
            scanner_product
            create ScannerProduce(arg:Cmd)
          createList Statements
        else
          consume(":")
          consume_eols
          scanner_multi_line_statements
        endIf
        create MatchCase(scanner_expression,statements:CmdList)
      elseOn "produceAny"
        identifier
        create ProduceAny(token_group_name:String)
      else
        produceList
      endOn
    endWhile
  produceList

+ _others
  on "others"
    consume(":")
    consume_eols
    scanner_multi_line_statements
  else
    createNull
  endOn

+ scanner_multi_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        scanner_expression
        mustConsume( ")" )
      else
        scanner_expression
      endIf
      if (nextIs(EOL)) discardPosition
      else             restorePosition; produceList
      scanner_multi_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ scanner_multi_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (not consume(EOL)) restorePosition; produceNull
    scanner_multi_line_statements
    discardPosition
    return
  endOn

+ scanner_single_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        scanner_expression
        mustConsume( ")" )
      else
        scanner_expression
      endIf
      if (nextIs(EOL)) restorePosition; produceList
      else             discardPosition
      scanner_single_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ scanner_single_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (consume(EOL)) restorePosition; produceNull
    scanner_single_line_statements
    discardPosition
    return
  endOn

+ scanner_statement
  on "collect", scanner_args -> Collect(args:Args)
  #on "create", scanner_product      -> ScannerProduce(arg:Cmd)
  on "discardPosition"       -> DiscardPosition
  on "halt"                  -> Halt
  on "markPosition"          -> MarkPosition
  on "mode", identifier      -> Mode(routine_name:String)
  on "mustConsume", sequence_args   -> ScannerMustConsume(args:SequenceArgs)
  on "noAction": return
  on "print",   scanner_args       -> Print(args:Args)
  on "println"
    if (not hasAnother or nextHasAttribute(structural))
      beginList
      createList Args
    else
      scanner_args
    endIf
    produce Println(args:Args)
  endOn
  on "produce", scanner_product    -> ScannerProduce(arg:Cmd)
  on "->",      scanner_product    -> ScannerProduce(arg:Cmd)
  on "restart"
    if (nextIs(EOL)) createNull
    else             identifier
    produce Restart(start_ip:String)
  endOn
  on "restorePosition" -> RestorePosition
  on "return"
    if (nextIs(EOL)) createNull
    else             scanner_expression
    produce Return(value)
  endOn
  on "savePosition"    -> SavePosition
  on "syntaxError"
    if (nextIs(EOL)) createNull
    else             scanner_args
    produce ThrowSyntaxError(args:Args)
  endOn

  on "++", scanner_expression -> Increment(target)
  on "--", scanner_expression -> Decrement(target)

  scanner_expression

  on "=",  scanner_expression -> Assign(target,new_value)
  on "++", scanner_expression -> Increment(target)
  on "--", scanner_expression -> Decrement(target)

+ scanner_product
  identifier
  produce Access( name=t.content:String )

+ cmd_args
  beginList
    consume_eols
    if (consume(')')) produceList Args
    cmd_arg
    while (consume(','))
      consume_eols
      cmd_arg
      consume_eols
    endWhile
  produceList Args

+ cmd_arg
  identifier
  if (consume('='))
    on IDENTIFIER
      create Identifier( value=t.content:String )
    elseOn STRING
      create LiteralString( value=t.content:String )
    else
      syntaxError "content or \"quoted expression\" expected."
    endOn
  else
    createNull
  endIf
  if (consume(':')) identifier
  else              createNull
  produce CreateCmdArg(arg_name:String,arg_value,arg_type:String)

+ scanner_args
  if (consume('('))
    consume_eols
    scanner_arg_list
    consume_eols
    mustConsume(')')
  else
    scanner_arg_list
  endIf

+ scanner_arg_list
  beginList
  if (nextHasAttribute(structural)) produceList Args

  scanner_expression
  while (hasAnother)
    if (consume(','))
      consume_eols
      scanner_expression
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList Args
    else
      scanner_expression
    endIf
  endWhile

  produceList Args

+ sequence_args
  if (consume('('))
    consume_eols
    sequence_arg_list
    consume_eols
    mustConsume(')')
  else
    sequence_arg_list
  endIf

+ sequence_arg_list
  beginList
  if (nextHasAttribute(structural)) produceList SequenceArgs

  scanner_expression
  while (hasAnother)
    if (consume(','))
      consume_eols
      scanner_expression
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList SequenceArgs
    else
      scanner_expression
    endIf
  endWhile

  produceList SequenceArgs

+ pattern_sequence
  beginList
  if (nextHasAttribute(structural)) produceList PatternSequence

  sequence_item
  while (hasAnother)
    if (consume('*'))
      create ZeroOrMore(pattern:Cmd)
    elseIf (consume('+'))
      create OneOrMore(pattern)
    elseIf (consume('?'))
      create OptionalPattern(pattern)
    elseIf (consume(','))
      consume_eols
      sequence_item
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList PatternSequence
    else
      sequence_item
    endIf
  endWhile

  produceList PatternSequence

+ sequence_item
  on '{' pattern_sequence '}': return
  on CHARSET
    create CharSet(characters=t.content:String)
    repeat_count
    return  # just the CharSet
  endOn
  on STRING              -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralStringOrCharacter( value=t.content:String )
  syntaxError

+ empty_statements
  beginList
  createList Statements

+ scanner_expression

- scanner_logical_or : Binary
  on "or" -> LogicalOr

- scanner_logical_and : Binary
  on "and" -> LogicalAnd

- scanner_comparison : Binary
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

- scanner_add_subtract : Binary
  on "+" -> Add
  on "-" -> Subtract

- scanner_multiply_divide : Binary
  on "*" -> Multiply
  on "/" -> Divide

- scanner_power : Binary
  on "^" -> Power

- scanner_pre_unary : PreUnary
  on "-"   -> Negate
  on "not" -> LogicalNot

- scanner_term
  on '(' scanner_expression ')': return
  on '{' pattern_sequence '}':   return
  on "buffer"                    -> ReadBuffer
  on "call", identifier          -> ScannerCallUserMethod(fn_name:String)
  on "consume", sequence_args    -> ScannerConsume(args:SequenceArgs)
  on "false"                     -> LiteralLogical(value="false":Logical)
  on "hasAnother"                -> ScannerHasAnother
  on "nextIs", sequence_args     -> ScannerNextIs(args:SequenceArgs)
  on "read"                      -> ScannerRead
  on "scan", sequence_args       -> Scan(args:SequenceArgs)
  on "true"                      -> LiteralLogical(value="true":Logical)
  on CHARSET
    create CharSet(characters=t.content:String)
    repeat_count
    return
  endOn
  on IDENTIFIER          -> Access( name=t.content:String )
  on INTEGER             -> LiteralInteger( value=t.content:Int32 )
  on STRING
    create LiteralString( value=t.content:String )
    repeat_count
    return
  elseOn STRING_OR_CHARACTER
    create LiteralStringOrCharacter( value=t.content:String )
    repeat_count
    return
  endOn
  syntaxError

+ repeat_count
  on "*"
    produce ZeroOrMore(pattern:Cmd)
  elseOn "+"
    produce OneOrMore(pattern)
  elseOn "?"
    produce OptionalPattern(pattern)
  endOn
  # else just the CharSet

+ parser_routines
  beginList

  consume_eols
  while (nextIs('-'))
    on "-"
      routine_name_and_attributes
      parser_multi_line_statements
      create Routine(name:String,attributes:String,statements:Statements)
    endOn
    consume_eols
  endWhile

  produceList

+ parser_multi_line_statements
  consume_eols
  if (not hasAnother) syntaxError
  beginList
  while (hasAnother and not (nextIs('+') or nextIs('-') or nextHasAttribute(structural)))
    parser_control_structure
    consume_eols
  endWhile
  produceList Statements

+ parser_single_line_statements
  beginList
  if (consume(EOL)) produceList Statements

  parser_statement
  while (consume(';'))
    consume_eols
    parser_statement
  endWhile
  must_consume_eols

  produceList Statements

+ parser_control_structure
  on "if"
    if (consume("("))
      parser_expression
      mustConsume( ")" )
    else
      parser_expression
    endIf
    if (consume(EOL))
      parser_multi_line_statements
      parser_multi_line_else_ifs
      parser_multi_line_else
      mustConsume( "endIf" )
    else
      parser_single_line_statements
      parser_single_line_else_ifs
      parser_single_line_else
    endIf
    produce If( condition, statements:Statements, else_ifs:CmdList, _else:Statements )
  endOn

  on "on"
    string_or_id
    collect_parse_list
    if (consume(EOL))
      parser_multi_line_statements
      parser_multi_line_else_ons
      parser_multi_line_else_on_others
      mustConsume( "endOn" )
    else
      consume(':')
      parser_single_line_statements
      parser_single_line_else_ons
      parser_single_line_else_on_others
    endIf
    produce On( token_type, token_types:Args, statements:Statements, else_ons:CmdList, _else_on_others:Statements )
  endOn

  on "while"
    if (consume("("))
      parser_expression
      mustConsume( ")" )
    else
      parser_expression
    endIf
    if (consume(EOL))
      parser_multi_line_statements
      mustConsume( "endWhile" )
    else
      parser_single_line_statements
    endIf
    produce While( condition, statements:Statements )
  endOn

  parser_statement

+ parser_multi_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        parser_expression
        mustConsume( ")" )
      else
        parser_expression
      endIf
      if (nextIs(EOL)) discardPosition
      else             restorePosition; produceList
      parser_multi_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ parser_multi_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (not consume(EOL)) restorePosition; produceNull
    parser_multi_line_statements
    discardPosition
    return
  endOn

+ parser_single_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        parser_expression
        mustConsume( ")" )
      else
        parser_expression
      endIf
      if (nextIs(EOL)) restorePosition; produceList
      else             discardPosition
      parser_single_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ parser_single_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (consume(EOL)) restorePosition; produceNull
    parser_single_line_statements
    discardPosition
    return
  endOn

+ parser_multi_line_else_ons
  beginList

  while (nextIs("elseOn"))
    savePosition
    on "elseOn"
      string_or_id
      collect_parse_list
      if (nextIs(EOL)) discardPosition
      else             restorePosition; produceList
      parser_multi_line_statements
      create ElseOn(token_type,token_types:Args,statements:Statements)
    endOn
  endWhile

  produceList

+ parser_multi_line_else_on_others
  if (not nextIs("elseOnOthers")) produceNull
  savePosition
  on "elseOnOthers"
    if (not consume(EOL)) restorePosition; produceNull
    parser_multi_line_statements
    discardPosition
    return
  endOn

+ parser_single_line_else_ons
  beginList

  while (nextIs("elseOn"))
    savePosition
    on "elseOn"
      string_or_id
      collect_parse_list
      if (nextIs(EOL)) restorePosition; produceList
      else             discardPosition
      consume(':')
      parser_single_line_statements
      create ElseOn(token_type,token_types:Args,statements:Statements)
    endOn
  endWhile

  produceList

+ parser_single_line_else_on_others
  if (not nextIs("elseOnOthers")) produceNull
  savePosition
  on "elseOnOthers"
    if (consume(EOL)) restorePosition; produceNull
    consume(':')
    parser_single_line_statements
    discardPosition
    return
  endOn

+ parser_statement
  on "beginList" -> BeginList
  on "create",     parser_product -> ParserCreate(arg:CreateCmd)
  on "createList", list_type -> CreateList(list_type:String)
#{
  on "discardPosition"     -> DiscardPosition
  on "halt"                -> Halt
  on "markPosition"        -> MarkPosition
  on "mode", identifier    -> Mode(routine_name:String)
}#
  on "mustConsume", string_or_id_arg   -> ParserMustConsume(token_type)
  on "noAction": return
#{
  on "print",   parser_args       -> Print(args:ParserArgs)
  on "println"
    if (not hasAnother or nextHasAttribute(structural))
      beginList
      createList ParserArgs
    else
      parser_args
    endIf
    produce Println(args:ParserArgs)
  endOn
  #on "on"
  #  identifier_or_string
  #  additional_elements
  #endOn
}#
  on "produce", parser_product    -> ParserProduce(arg:CreateCmd)
  on "produceList", list_type     -> ProduceList(list_type:String)
  on "->",      parser_product    -> ParserProduce(arg:CreateCmd)
#{
  on "restart"
    if (nextIs(EOL)) createNull
    else             identifier
    produce Restart(start_ip:String)
  endOn
  on "restorePosition" -> RestorePosition
}#
  on "return"
    if (nextIs(EOL)) createNull
    else             parser_expression
    produce          Return(value)
  endOn
#{
  on "savePosition"    -> SavePosition
}#
  on "syntaxError"
    if (nextIs(EOL)) createNull
    else             parser_args
    produce ThrowSyntaxError(args:Args)
  endOn
#{
  on "++", parser_expression -> Increment(target)
  on "--", parser_expression -> Decrement(target)
}#

  parser_expression

#{
  on "=",  parser_expression -> Assign(target,new_value)
  on "++", parser_expression -> Increment(target)
  on "--", parser_expression -> Decrement(target)
}#

+ list_type
  if (nextIs(IDENTIFIER)) identifier
  else                    produceNull

+ parser_args
  if (consume('('))
    consume_eols
    parser_arg_list
    consume_eols
    mustConsume(')')
  else
    parser_arg_list
  endIf

+ parser_arg_list
  beginList
  if (nextHasAttribute(structural)) produceList ParserArgs

  parser_expression
  while (hasAnother)
    if (consume(','))
      consume_eols
      parser_expression
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList ParserArgs
    else
      parser_expression
    endIf
  endWhile

  produceList ParserArgs

+ string_or_id_arg
  if (consume('('))
    string_or_id
    mustConsume(')')
  else
    string_or_id
  endIf

+ string_or_id
  on IDENTIFIER          -> Identifier( name=t.content:String )
  on STRING              -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralString( value=t.content:String )
  syntaxError "TOKEN_ID or \"token_name\" expected."

+ collect_parse_list
  beginList
    while (hasAnother and not nextIs(EOL) and not nextHasAttribute(structural))
      consume ","
      string_id_or_routine
    endWhile
  produceList Args

+ string_id_or_routine
  on IDENTIFIER          -> Identifier( name=t.content:String )
  on STRING              -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralString( value=t.content:String )
  syntaxError "TOKEN_ID, \"token_name\", or routine_name expected."

+ parser_product
  identifier
  if (consume('('))
    cmd_args
    mustConsume(')')
  else
    beginList
    createList Args
  endIf
  produce CreateCmd(name:String,args:Args)

+ parser_expression

- parser_logical_or : Binary
  on "or" -> LogicalOr

- parser_logical_and : Binary
  on "and" -> LogicalAnd

- parser_comparison : Binary
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

- parser_add_subtract : Binary
  on "+" -> Add
  on "-" -> Subtract

- parser_multiply_divide : Binary
  on "*" -> Multiply
  on "/" -> Divide

- parser_power : Binary
  on "^" -> Power

- parser_pre_unary : PreUnary
  on "-"   -> Negate
  on "not" -> LogicalNot

- parser_term
#{
  on '(' parser_expression ')':     return
  on '{' pattern_sequence '}':      return
  on "buffer"                    -> ReadBuffer
  on "call", identifier          -> ParserCallUserMethod(fn_name:String)
}#
  on "consume", string_or_id_arg -> ParserConsume(token_type)
  on "false"                     -> LiteralLogical(value="false":Logical)
  on "hasAnother"                -> ParserHasAnother
#{
  on "nextIs", parser_args       -> ParserNextIs(args:ParserArgs)
}#
  on "read"                      -> ParserRead
  on "true"                      -> LiteralLogical(value="true":Logical)
  on IDENTIFIER          -> Access( name=t.content:String )
  on INTEGER             -> LiteralInteger( value=t.content:Int32 )
  on STRING              -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralStringOrCharacter( value=t.content:String )
  syntaxError

