module Froley

class RScannerCore( generator, scanner_def:ScannerDef ) : RogueSourceWriter
  METHODS
    method init_object
      class_name = "ScannerCore"

    method write_content
      writeln ...
        @|# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
         |
         |$include "CompileError.rogue"
         |$include "ScanTable.rogue"
         |$include "Token.rogue"
         |$include "TokenType.rogue"
         |
         |class ScannerCore [abstract]
         |  DEFINITIONS
      forEach (r in scanner_def.routines)
        writeln "    ip_$ = $" (r.name,r.ip)
      endForEach

      writeln ...
        @|
         |  PROPERTIES
         |    _filepath     : String
         |    _scanner      : Rogue::Scanner
         |    line          = 1L
         |    column        = 1L
         |
         |    tokens        = Token[]
         |    buffer        = String()
         |    output        = String()
         |
         |    start_ip      = 0L
         |    halt          = false
         |
         |    _position_stack  = NewInt[]
         |    _line_stack      = NewInt[]
         |    _column_stack    = NewInt[]
         |    _token_pos_stack = NewInt[]
         |
         |    # GENERATED PROPERTIES

      indent += 4
      if (scanner_def.vars.count)
        local max_w = 0
        max_w .= or_larger( (forEach in scanner_def.vars).name.count )

        forEach (v in scanner_def.vars)
          write "$ : "(v.name.justified(-max_w))
          which (v.type)
            case FType.LOGICAL
              writeln "Logical"
            case FType.CHARACTER
              writeln "Character"
            case FType.INTEGER
              writeln "NewInt"
            case FType.STRING
              writeln "String"
            others
              throw v.t.error( "[INTERNAL] Unhandled type '$' (1)."(v.type) )
          endWhich
        endForEach
      endIf

      forEach (entry in Program.scan_patterns.entries)
        writeln ''$ = ScanPattern( "$" )'' (entry.value,entry.key)
      endForEach

      ScanTableDeclarationWriter(generator).visit( scanner_def )
      indent -= 4

      writeln ...
        @|
         |  METHODS
         |    method init( file:File )
         |      init( file.filepath, Rogue::Scanner(file) )
         |      line   = 1
         |      column = 1
         |
         |    method init( filepath:String, content:String, line=1, column=1 )
         |      init( filepath, Rogue::Scanner(content).[line=line, column=column] )
         |
         |    method init( _filepath, _scanner )
         |      noAction
         |

      forEach (fn_name in Program.scanner_user_calls)
        writeln  "    method $ [abstract]" (fn_name)
        writeln
      endForEach

      writeln ...
        @|    method execute( ip:NewInt )
         |      _clear_state
         |      _execute( ip )
         |
         |    method tokenize( ip=null:NewInt? )->Token[]
         |      if (ip) start_ip = ip.value
         |      _clear_state
         |      while (_execute(start_ip) or not halt)
         |        buffer.clear
         |      endWhile
         |      _on_output_line # flush any buffered output
         |      return tokens
         |
         |    method _add( type:TokenType )
         |      if (type.attributes & TokenType.ATTRIBUTE_CONTENT)
         |        tokens.add( _t(type,buffer.cloned) )
         |      else
         |        tokens.add( _t(type) )
         |      endIf
         |      buffer.clear
         |
         |    method _clear_state
         |      tokens = Token[]
         |      buffer.clear
         |      output.clear
         |      halt = false
         |
         |    method _describe_character( c:Character )->String
         |      if (c == 10 or c == 13)       return "end of line";
         |      elseIf (c >= 32 and c != 127) return "'$'" (c)
         |      else                          return "'$'" (c.to_escaped_ascii)
         |
         |    method _discard_position
         |      if (_position_stack.is_empty)
         |        _throw_syntax_error( "discardPosition without prior savePosition." )
         |      endIf
         |      _position_stack.remove_last
         |      _line_stack.remove_last
         |      _column_stack.remove_last
         |      _token_pos_stack.remove_last
         |
         |    method _is_next( text:String )->Logical
         |      local location = _scanner.location
         |      local result = _scanner.consume( text )
         |      _scanner.location = location
         |      return result
         |
         |    method _must_consume( ch:Character )
         |      if (_scanner.consume(ch)) return
         |      local message = "Syntax error - expected $, found " (_describe_character(ch))
         |      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
         |      else                      message += "end of input."
         |      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )
         |
         |    method _must_consume( st:String )
         |      if (_scanner.consume(st)) return
         |      _throw_expected_string_error( "'$'" (st.to_escaped_ascii("'")) )
         |
         |    method _must_consume( pattern:ScanPattern )
         |      if (pattern.scan(_scanner)) return
         |      _throw_expected_string_error( pattern->String )
         |
         |    method _next_is( text:String )->Logical
         |      if (not _scanner.has_another(text.count)) return false
         |      local pos = _scanner.position
         |      forEach (ch at index in text)
         |        if (ch != _scanner.data[pos+index]) return false
         |      endForEach
         |      return true
         |
         |    method _on_output_line
         |      # Default behavior: print out 'output' and clear it. Can override this method.
         |      print( output )
         |      flush
         |      output.clear
         |
         |    method _restore_position
         |      if (_position_stack.is_empty)
         |        _throw_syntax_error( "restorePosition without prior savePosition." )
         |      endIf
         |      _scanner.position = _position_stack.remove_last
         |      _scanner.line     = _line_stack.remove_last
         |      _scanner.column   = _column_stack.remove_last
         |      tokens.discard_from( _token_pos_stack.remove_last )
         |
         |    method _save_position
         |      _position_stack.add( _scanner.position )
         |      _line_stack.add( _scanner.line )
         |      _column_stack.add( _scanner.column )
         |      _token_pos_stack.add( tokens.count )
         |
         |    method _scan( ch:Character )->Logical
         |      if (not _scanner.consume(ch)) return false
         |      buffer.print ch
         |      return true
         |
         |    method _scan( text:String )->Logical
         |      if (not _scanner.consume(text)) return false
         |      buffer.print text
         |      return true
         |
         |    method _t( type:TokenType, content=null:String )->Token
         |      return Token( type, _filepath, _scanner.source, line, column, content )
         |
         |    method _throw_expected_string_error( st:String )
         |      local message = "Syntax error - expected $, found " (st)
         |      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
         |      else                      message += "end of input."
         |      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )
         |
         |    method _throw_syntax_error( message=null:String )
         |      if (not message)
         |        local builder = String()
         |        builder.print "Syntax error - unexpected "
         |        if (not _scanner.has_another)
         |          builder.println "end of input."
         |        else
         |          builder.[ print(_describe_character(_scanner.peek)), print('.') ]
         |        endIf
         |        message = builder
         |      endIf
         |      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )
         |
         |    method _execute( ip:NewInt )->Logical
         |      which (ip)
      forEach (r in scanner_def.routines)
        writeln "        case ip_$: return r_$" (r.name,r.name)
      endForEach
      writeln ...
        @|        others
         |          halt = true
         |          return false
         |      endWhich
         |

      generator.visit( scanner_def.routine_defs )

      writeln ...
        @|endClass
endClass

