module F2

class ParserCoreRogueGen( generator, parser_def:ParserDef ) : RogueSourceWriter
  METHODS
    method init_object
      class_name = "ParserCore"

    method write_content
      # OutputFolder/XYZParserCore.rogue
      writeln ...
        @|# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
         |class ParserCore [abstract]
         |  DEFINITIONS
      forEach (r in parser_def.routines)
        writeln "    ip_$ = $" (r.name,r.ip)
      endForEach

      writeln ...
        @|
         |  PROPERTIES
         |    _tokens          : Token[]
         |    _position        : Int32
         |    _limit           : Int32
         |    _cmd_stack       = Cmd[]
         |    _token_stack     = Token[]
         |    _token_frames    = Int32[]
         |    _list_starts     = Int32[]
         |    _list_tokens     = Token[]
         |    _next_t          : Token
         |    _cur_t           : Token
         |    _saved_positions = ParserPosition[]
         |    start_ip         = 0
         |    ip               = 0
         |    output           = StringBuilder()
         |
         |  METHODS
         |    method init( file:File )
         |      local scanner = Scanner( file )
         |      local tokens = scanner.tokenize
         |      if (scanner.output.count) print scanner.output; flush
         |      init( tokens )
         |
         |    method init( _tokens )
         |      _position = 0
         |      _limit = _tokens.count
         |      _cmd_stack.clear
         |      _token_stack.clear
         |      output.clear

      forEach (fn_name in generator.program.parser_user_calls)
        writeln
        writeln  "    method $ [abstract]" (fn_name)
      endForEach

      writeln ...
        @|
         |    method has_another->Logical
         |      return _position < _limit
         |
         |    method parse( ip=null:Int32? )->Cmd
         |      if (_position == _limit) return null
         |      if (ip) start_ip = ip.value
         |      _token_stack.clear
         |      _token_frames.clear
         |      _list_starts.clear
         |      _list_tokens.clear
         |      _next_t = _tokens[_position]
         |      _cur_t = _next_t
         |      _execute( start_ip )
         |      if (_cmd_stack.count != 1)
         |        throw _peek.error( "[INTERNAL] Expected exactly one command node remaining on stack." )
         |      endIf
         |      return _cmd_stack.remove_last
         |
         |    method _begin_list
         |      _list_starts.add( _cmd_stack.count )
         |      _list_tokens.add( _next_t )
         |
         |    method _consume( type:TokenType )->Logical
         |      if (_next_t.type != type) return false
         |      if (_position < _limit) ++_position; _next_t = _peek
         |      return true
         |
         |    method _consume_eols
         |      while (_next_t.type == TokenType.EOL)
         |        ++_position
         |        _next_t = _peek
         |      endWhile
         |
         |    method _describe( type:TokenType )->String
         |      if (type.symbol[0].is_letter) return type.symbol
         |      return "'$'" (type.symbol)
         |
         |    method _discard_position
         |      if (_saved_positions.is_empty)
         |        throw _peek.error( "[INTERNAL] No savePosition to discard." )
         |      endIf
         |      _saved_positions.remove_last
         |
         |    method _list_t->Token
         |      if (_list_tokens.is_empty)
         |        throw _peek.error( "[INTERNAL] createList/produceList without corresponding beginList." )
         |      endIf
         |      return _list_tokens.remove_last
         |
         |    method _on_t
         |     _tokens.add( _cur_t )
         |     _cur_t = _next_t
         |     ++_position
         |     _next_t = _peek
         |
         |    method _peek->Token
         |      if (_position < _limit) return _tokens[ _position ]
         |      return Token( TokenType.EOI, null, null, 0, 0 )
         |
         |    method _pop_frame
         |      _token_stack.discard_from( _token_frames.remove_last )
         |      _cur_t = _token_stack.remove_last
         |
         |    method _push( cmd:Cmd, node_arg_count:Int32 )
         |      _cmd_stack.discard_from( _cmd_stack.count - node_arg_count )
         |      _cmd_stack.add( cmd )
         |      if (_tokens.count) _cur_t = _tokens.remove_last
         |
         |    method _push_list( list:Cmd )
         |      local i1 = _list_starts.remove_last
         |      list.add( forEach in _cmd_stack from i1 )
         |      _cmd_stack.discard_from( i1 )
         |      _cmd_stack.add( list )
         |
         |    method _read->Token
         |      local result = _next_t
         |      if (_position < _limit) ++_position; _next_t = _peek
         |      return result
         |
         |    method _restore_position
         |      if (_saved_positions.is_empty)
         |        throw _peek.error( "[INTERNAL] No savePosition to restore." )
         |      endIf
         |      local pos = _saved_positions.remove_last
         |      _position = pos.position
         |      _cmd_stack.discard_from( pos.cmd_stack_count )
         |      _cur_t = pos.cur_t
         |      _next_t = _peek
         |
         |    method _save_position
         |      _saved_positions.add( ParserPosition(_position,_cmd_stack.count,_cur_t) )
         |
         |    method _stack_arg( relative:Int32 )->Cmd
         |      local i = _cmd_stack.count + relative
         |      if (i < 0) throw _peek.error( "[INTERNAL] Not enough nodes on stack to create new Cmd." )
         |      return _cmd_stack[i]
         |
         |    method _throw_syntax_error( message=null:String, expected=null:TokenType? )
         |      if (message is null)
         |        use builder = StringBuilder.pool
         |          local next = _describe( _peek.type )
         |          if (expected)
         |            builder.print "Expected $, found $." (_describe(expected.value),next)
         |          else
         |            builder.print "Unexpected $." (next)
         |          endIf
         |          message = builder->String
         |        endUse
         |      endIf
         |
         |      throw _peek.error( message )
         |
         |    method _execute( ip:Int32 )
         |      _token_stack.add( _cur_t )
         |      _token_frames.add( _token_stack.count )
         |      loop
         |        ++ip
         |        which (ip-1)

      parser_def.code.dispatch( generator )

      writeln ...
        @|          others
         |            return
         |        endWhich
         |      endLoop
         |endClass
         |
         |class ParserPosition( position:Int32, cmd_stack_count:Int32, cur_t:Token ) [compound];
endClass
