module Simple

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.

$include "CompileError.rogue"
$include "ScanTable.rogue"
$include "Token.rogue"
$include "TokenType.rogue"

class ScannerCore [abstract]
  DEFINITIONS
    ip_main = 0
    ip_scan_id_or_keyword = 1
    ip_scan_number = 2
    ip_scan_integer = 3
    ip_scan_string = 4

  PROPERTIES
    _filepath     : String
    _scanner      : ::Scanner
    line          = 1
    column        = 1

    tokens        = Token[]
    buffer        = StringBuilder()
    output        = StringBuilder()

    start_ip      = 0
    ip            : Int32
    halt          = false

    _position_stack  = Int32[]
    _line_stack      = Int32[]
    _column_stack    = Int32[]
    _token_pos_stack = Int32[]

    # GENERATED PROPERTIES
    ch : Character
    _scan_pattern_0 = ScanPattern( "[ \r\t]*" )
    _scan_pattern_1 = ScanPattern( "{#[^\n]*}" )
    _scan_pattern_2 = ScanPattern( "{[_a-zA-Z][_a-zA-Z0-9]*}" )
    _scan_pattern_3 = ScanPattern( "[0-9]" )
    _scan_pattern_4 = ScanPattern( "[0-9]*" )
    _scan_table_0 = ScanTable("Hv8HKRA9Ei0UKBYrGC8aKhwAAAEAAgADAAQABQAGAA==")
    _scan_table_1 = ScanTable("HgABcAT/AXII/wFpDP8BbhD/AXQUAQFsGP8BbhwCAA==")

  METHODS
    method init( file:File )
      init( file.filepath, ::Scanner(file) )
      line   = 1
      column = 1

    method init( filepath:String, content:String, line=1, column=1 )
      init( filepath, ::Scanner(content).[line=line, column=column] )

    method init( _filepath, _scanner )
      noAction

    method execute( ip:Int32 )
      _clear_state
      _execute( ip )

    method tokenize( ip=null:Int32? )->Token[]
      if (ip) start_ip = ip.value
      _clear_state
      while (_execute(start_ip) or not halt)
        buffer.clear
      endWhile
      _on_output_line # flush any buffered output
      return tokens

    method _add( type:TokenType )
      if (type.attributes & TokenType.ATTRIBUTE_CONTENT)
        tokens.add( _t(type,buffer) )
      else
        tokens.add( _t(type) )
      endIf
      buffer.clear

    method _clear_state
      tokens = Token[]
      buffer.clear
      output.clear
      halt = false

    method _describe_character( c:Character )->String
      if (c == 10 or c == 13)       return "end of line";
      elseIf (c >= 32 and c != 127) return "'$'" (c)
      else                          return "'$'" (c.to_escaped_ascii)

    method _discard_position
      if (_position_stack.is_empty)
        _throw_syntax_error( "discardPosition without prior savePosition." )
      endIf
      _position_stack.remove_last
      _line_stack.remove_last
      _column_stack.remove_last
      _token_pos_stack.remove_last

    method _is_next( text:String )->Logical
      local location = _scanner.location
      local result = _scanner.consume( text )
      _scanner.location = location
      return result

    method _must_consume( ch:Character )
      if (_scanner.consume(ch)) return
      local message = "Syntax error - expected $, found " (_describe_character(ch))
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _must_consume( st:String )
      if (_scanner.consume(st)) return
      _throw_expected_string_error( "'$'" (st.to_escaped_ascii("'")) )

    method _must_consume( pattern:ScanPattern )
      if (pattern.scan(_scanner)) return
      _throw_expected_string_error( pattern->String )

    method _next_is( text:String )->Logical
      if (not _scanner.has_another(text.count)) return false
      local pos = _scanner.position
      forEach (ch at index in text)
        if (ch != _scanner.data[pos+index]) return false
      endForEach
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output ).flush
      output.clear

    method _restore_position
      if (_position_stack.is_empty)
        _throw_syntax_error( "restorePosition without prior savePosition." )
      endIf
      _scanner.position = _position_stack.remove_last
      _scanner.line     = _line_stack.remove_last
      _scanner.column   = _column_stack.remove_last
      tokens.discard_from( _token_pos_stack.remove_last )

    method _save_position
      _position_stack.add( _scanner.position )
      _line_stack.add( _scanner.line )
      _column_stack.add( _scanner.column )
      _token_pos_stack.add( tokens.count )

    method _scan( ch:Character )->Logical
      if (not _scanner.consume(ch)) return false
      buffer.print ch
      return true

    method _scan( text:String )->Logical
      if (not _scanner.consume(text)) return false
      buffer.print text
      return true

    method _t( type:TokenType, content=null:String )->Token
      return Token( type, _filepath, _scanner.source, line, column, content )

    method _throw_expected_string_error( st:String )
      local message = "Syntax error - expected $, found " (st)
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _throw_syntax_error( message=null:String )
      if (not message)
        local builder = StringBuilder()
        builder.print "Syntax error - unexpected "
        if (not _scanner.has_another)
          builder.println "end of input."
        else
          builder.print( _describe_character(_scanner.peek) ).print( '.' )
        endIf
        message = builder->String
      endIf
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _execute( ip:Int32 )->Logical
      loop
        ++ip
        which (ip-1)
          case ip_main
            _scan_pattern_0.scan(_scanner)
            if (_scan_pattern_1.scan(_scanner))
              return false
            endIf
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            line   = _scanner.line
            column = _scanner.column
            if (_scanner.consume('\n'))
              _add( TokenType.EOL )
              return false
            endIf
            _scan_table_0.reset
            contingent
              block n=1
                while (_scanner.has_another(n))
                  if (not _scan_table_0.accept(_scanner.peek(n-1)))
                    escapeWhile
                  endIf
                  ++n
                endWhile
                necessary (_scan_table_0.has_product)
                loop (_scan_table_0.match_count) _scanner.read
              endBlock
              which (_scan_table_0.product)
                case 0
                  _add( TokenType.SYMBOL_CLOSE_PAREN )
                  return false
                case 1
                  _add( TokenType.SYMBOL_EQUALS )
                  return false
                case 2
                  _add( TokenType.SYMBOL_MINUS )
                  return false
                case 3
                  _add( TokenType.SYMBOL_OPEN_PAREN )
                  return false
                case 4
                  _add( TokenType.SYMBOL_PLUS )
                  return false
                case 5
                  _add( TokenType.SYMBOL_SLASH )
                  return false
                case 6
                  _add( TokenType.SYMBOL_STAR )
                  return false
                others
                  necessary (false)
              endWhich
            endContingent
            if (not _execute(ip_scan_id_or_keyword)) return false
            if (not _execute(ip_scan_number)) return false
            if (not _execute(ip_scan_string)) return false
            _throw_syntax_error
            return true
          case ip_scan_id_or_keyword
            if ((not _scan_pattern_2.scan(_scanner,buffer)))
              return true
            endIf
            _scan_table_1.reset
            contingent
              necessary (_scan_table_1.accept(forEach in buffer))
              which (_scan_table_1.product)
                case 1
                  _add( TokenType.KEYWORD_PRINT )
                  return false
                case 2
                  _add( TokenType.KEYWORD_PRINTLN )
                  return false
                others
                  necessary (false)
              endWhich
            unsatisfied
              _add( TokenType.IDENTIFIER )
              return false
            endContingent
          case ip_scan_number
            if ((not _scanner.has_another))
              return true
            endIf
            if (_scan_pattern_3.scan(_scanner,buffer))
              if (not _execute(ip_scan_integer)) return false
              if (_scan('.'))
                if (not _execute(ip_scan_integer)) return false
              endIf
              _add( TokenType.NUMBER )
              return false
            elseIf (_scan('.'))
              if (not _execute(ip_scan_integer)) return false
              _add( TokenType.NUMBER )
              return false
            else
              return true
            endIf
          case ip_scan_integer
            _scan_pattern_4.scan(_scanner,buffer)
            return true
          case ip_scan_string
            if ((not _scanner.consume('"')))
              return true
            endIf
            while ((_scanner.has_another and (not _scanner.next_is('\n'))))
              ch = _scanner.read
              if ((ch=='"'))
                _add( TokenType.STRING )
                return false
              elseIf (((ch=='\\') and _scanner.has_another))
                ch = _scanner.read
              endIf
              buffer.print(ch)
            endWhile
            _throw_syntax_error("Unterminated string.")
            return true
          others
            halt = true
            return false
        endWhich
      endLoop

endClass
