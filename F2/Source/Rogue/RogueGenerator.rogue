module F2

$include "CmdRogueGen.rogue"
$include "MainRogueGen.rogue"
$include "ParserCoreRogueGen.rogue"
$include "ParserRogueGen.rogue"
$include "RogueSourceGen.rogue"
$include "ScanTableDeclarationWriter.rogue"
$include "ScanTableRogueGen.rogue"
$include "ScannerCoreRogueGen.rogue"
$include "ScannerRogueGen.rogue"
$include "SyntaxErrorRogueGen.rogue"
$include "TokenRogueGen.rogue"
$include "TokenTypeRogueGen.rogue"

class RogueGenerator : FroleyVisitor
  GLOBAL METHODS
    method to_escaped_ascii( st:String, additional_escapes:String )->String
      return st.to_escaped_ascii( additional_escapes )

  PROPERTIES
    folder     : String
    writer     : PrintWriter
    class_name = ""

    indent     = 0
    at_newline = true
    write_replacements = StringTable<<String>>()

  METHODS
    method init( program, folder )
      File.create_folder( folder )

      program.nodes.dispatch( this )
      #generate_scanner( forEach in scanners )
      #generate_parser( forEach in parsers )
      #nodes.dispatch( Organizer(this) )

      SyntaxErrorRogueGen(this).overwrite
      ScanTableRogueGen(this).overwrite
      TokenTypeRogueGen(this).overwrite
      TokenRogueGen(this).overwrite

      # Main
      if (program.main_filename)
        MainRogueGen( this, program.main_filename ).overwrite
      endIf

    method visit( cmd:Call )->Cmd  [override]
      write "if (not execute(ip_"
      write cmd.routine_def.name
      write ")) return false"
      return cmd

    method visit( cmd:CastToLogical )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Logical"
      return cmd

    method visit( cmd:CastToCharacter )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Character"
      return cmd

    method visit( cmd:CastToInteger )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Int32"
      return cmd

    method visit( cmd:CastToString )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->String"
      return cmd

    method visit( cmd:CharSet )->Cmd  [override]
      trace cmd.characters
      println StackTrace()
      return cmd

    method visit( cmd:Collect )->Cmd  [override]
      write "buffer"
      forEach (arg in cmd.args)
        write ".print("
        arg.dispatch( this )
        write ")"
      endForEach
      return cmd

    method visit( cmd:CompareEQ )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "=="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareNE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "!="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:ConsumeCharacters )->Cmd  [override]
      write "_scanner.consume("
      dispatch( cmd.value )
      write ")"
      return cmd

    method visit( cmd:ConsumePattern )->Cmd  [override]
      dispatch( cmd.pattern )
      write ".scan(_scanner)"
      return cmd

    method visit( cmd:ConsumeToken )->Cmd  [override]
      write "_consume(TokenType."
      write cmd.token_type.name
      write ")"
      return cmd

    method visit( cmd:MustConsumeCharacters )->Cmd  [override]
      write "_must_consume( "
      dispatch( cmd.value )
      write " )"
      return cmd

    method visit( cmd:MustConsumePattern )->Cmd  [override]
      write "_must_consume( "
      dispatch( cmd.pattern )
      write " )"
      return cmd

    method visit( cmd:Pattern )->Cmd  [override]
      write cmd.reference_name
      return cmd

    method visit( cmd:Decrement )->Cmd  [override]
      write "--"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:DiscardPosition )->Cmd  [override]
      write @|if (_position_stack.count) _position_stack.remove_last
      return cmd

    method visit( cmd:If )->Cmd  [override]
      write   "if ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2

      dispatch( cmd.else_ifs )

      if (cmd._else)
        writeln "else"
        indent += 2
        dispatch( cmd._else )
        indent -= 2
      endIf

      write   "endIf"
      return cmd

    method visit( cmd:ElseIf )->Cmd  [override]
      write   "elseIf ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      return cmd

    method visit( cmd:Halt )->Cmd  [override]
      writeln "halt = true"
      write   "return false"
      return cmd

    method visit( cmd:Increment )->Cmd  [override]
      write "++"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:ScannerHasAnother )->Cmd  [override]
      write "_scanner.has_another"
      return cmd

    method visit( cmd:LiteralCharacter )->Cmd  [override]
      which (cmd.value)
        case '\\': write @|'\\'
        case '\n': write @|'\n'
        case '\r': write @|'\r'
        case '\t': write @|'\t'
        others
          write( "'$'"(to_escaped_ascii(cmd.value,"'")) )
      endWhich
      return cmd

    method visit( cmd:LiteralInteger )->Cmd  [override]
      writer.print( cmd.value )
      return cmd

    method visit( cmd:LiteralLogical )->Cmd  [override]
      writer.print( cmd.value )
      return cmd

    method visit( cmd:LiteralString )->Cmd  [override]
      if (cmd.value.count == 1)
        writer.print( "'$'"(to_escaped_ascii(cmd.value,"'")) )
      else
        writer.print( ''"$"''(to_escaped_ascii(cmd.value,''"'')) )
      endIf
      return cmd

    method visit( cmd:LiteralTokenType )->Cmd  [override]
      write "TokenType."
      write cmd.token_type.name
      return cmd

    method visit( cmd:LogicalAnd )->Cmd  [override]
      write "("
      cmd.left.dispatch( this )
      write " and "
      cmd.right.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:LogicalNot )->Cmd  [override]
      write "(not "
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:LogicalOr )->Cmd  [override]
      write "("
      cmd.left.dispatch( this )
      write " or "
      cmd.right.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:MarkPosition )->Cmd  [override]
      writeln "_src_line   = _scanner.line"
      write   "_src_column = _scanner.column"
      return cmd

    method visit( cmd:Mode )->Cmd  [override]
      write "start_ip = ip_"
      write cmd.routine_name
      return cmd

    method visit( cmd:ScannerCallUserMethod )->Cmd  [override]
      writeln "this.ip = ip"
      writeln cmd.fn_name
      write   "ip = this.ip"
      return cmd

    method visit( cmd:NextIsCharacters )->Cmd  [override]
      if (cmd.value.type == Type.CHARACTER)
        write "_scanner.next_is("
        dispatch( cmd.value )
        write ")"
      else
        write "_next_is("
        dispatch( cmd.value )
        write ")"
      endIf
      return cmd

    method visit( cmd:NextIsPattern )->Cmd  [override]
      dispatch( cmd.pattern )
      write ".is_next(_scanner)"
      return cmd

    method visit( cmd:Print )->Cmd  [override]
      write "output"
      forEach (arg in cmd.args)
        write ".print("
        arg.require_value.dispatch( this )
        write ")"
      endForEach
      return cmd

    method visit( cmd:Println )->Cmd  [override]
      write "output"
      forEach (arg in cmd.args)
        write ".print("
        arg.require_value.dispatch( this )
        write ")"
      endForEach
      write ".println"
      return cmd

    method visit( cmd:ScanCharacters )->Cmd  [override]
      write "_scan("
      dispatch( cmd.value )
      write ")"
      return cmd

    method visit( cmd:ScanPatternCmd )->Cmd  [override]
      dispatch( cmd.pattern )
      write ".scan(_scanner,buffer)"
      return cmd

    method visit( cmd:Produce )->Cmd  [override]
      write   "_add( "
      cmd.arg.dispatch( this )
      writeln " )"
      write   "return false"
      return cmd

    method visit( cmd:ScannerRead )->Cmd  [override]
      write "_scanner.read"
      return cmd

    method visit( cmd:ReadBuffer )->Cmd  [override]
      write "buffer"
      return cmd

    method visit( cmd:ReadVar )->Cmd  [override]
      write cmd.var.name
      return cmd

    method visit( cmd:Restart )->Cmd  [override]
      if (cmd.start_ip)
        write "start_ip = ip_"
        write cmd.start_ip
      endIf
      write "return false"
      return cmd

    method visit( cmd:RestorePosition )->Cmd  [override]
      write @|if (_position_stack.count) _scanner.seek( _position_stack.remove_last )
      return cmd

    method visit( cmd:Return )->Cmd  [override]
      # TODO: save return value first, if needed
      write   "return true"
      return cmd

    method visit( cmd:Routine )->Cmd  [override]
      writeln "          case ip_$"(cmd.name)

      indent += 12
      prior.visit( cmd )
      indent -= 12

      return cmd

    method visit( cmd:SavePosition )->Cmd  [override]
      write "_position_stack.add( _scanner.position )"
      return cmd

    method visit( cmd:ScannerDef )->Cmd  [override]
      is_scanner = true
      is_parser = false

      ScannerRogueGen(this).overwrite
      ScannerCoreRogueGen(this,cmd).overwrite
      return cmd

    method visit( cmd:Statements )->Cmd  [override]
      forEach (element in cmd)
        if (element)
          element.dispatch( this )
          writeln
        endIf
      endForEach
      return cmd

    method visit( cmd:Match )->Cmd  [override]
      write_replacements["$scan_table"] = cmd.id

      writeln @|$scan_table.reset
               |contingent
      if (cmd.expression)
        # ScannerRead from string; must accept all characters.
        write @|  necessary ($scan_table.accept(forEach in
        write " "
        cmd.expression.dispatch(this)
        writeln @|))
      else
        # ScannerRead longest match from input
        indent += 2
        writeln @|block n=1
                 |  while (_scanner.has_another(n))
                 |    if (not $scan_table.accept(_scanner.peek(n-1)))
                 |      escapeWhile
                 |    endIf
                 |    ++n
                 |  endWhile
                 |  necessary ($scan_table.has_product)
                 |  loop ($scan_table.match_count) _scanner.read
                 |endBlock
        indent -= 2
      endIf

      writeln @|  which ($scan_table.product)
      indent += 4
      forEach (statements at i in cmd.statement_lists)
        writeln "case "+i
        indent += 2
        statements.dispatch(this)
        indent -= 2
      endForEach
      indent -= 4
      write @|  endWhich
             |endContingent

      write_replacements.remove( "$scan_table" )
      return cmd

    method visit( cmd:ThrowSyntaxError )->Cmd  [override]
      write "_throw_syntax_error"
      if (cmd.args and cmd.args.count)
        write "("
        forEach (arg at i in cmd.args)
          if (i > 0) write "+"
          cmd.args.dispatch( this )
        endForEach
        write ")"
      endIf
      return cmd

    method visit( cmd:WriteBuffer )->Cmd  [override]
      write "buffer.clear.print "
      dispatch( cmd.new_value )
      return cmd

    method visit( cmd:WriteVar )->Cmd  [override]
      write "$ = " (cmd.var.name)
      dispatch( cmd.new_value )
      return cmd

    method visit( cmd:While )->Cmd  [override]
      write   "while ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      write   "endWhile"
      return cmd

    method write( content:String )
      if (content.contains('\n'))
        forEach (line at i in content.split('\n'))
          if (i > 0) writeln
          write( line )
        endForEach
        return
      endIf

      if (at_newline and indent)
        loop (indent) writer.print(' ')
      endIf

      if (content.contains('$'))
        content .= replacing( "$module", "module $\n" (program.project_name) )
        forEach (entry in write_replacements.entries)
          content .= replacing( entry.key, entry.value )
        endForEach
      endIf
      writer.print( content )

      at_newline = false

    method writeln( content="":String )
      if (String.exists(content)) write( content )
      writer.println
      at_newline = true

    method visit( cmd:ParserDef )->Cmd  [override]
      is_parser = true
      is_scanner = false

      CmdRogueGen(this).overwrite
      ParserRogueGen(this).overwrite
      ParserCoreRogueGen(this,cmd).overwrite

      return cmd
endClass

