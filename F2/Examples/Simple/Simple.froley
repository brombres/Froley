tokens
EOL(end of line)
IDENTIFIER identifier [content]
NUMBER     number     [content]
STRING     string     [content]

tokens Keywords
KEYWORD_PRINTLN println

tokens Symbols
SYMBOL_CARET       ^
SYMBOL_CLOSE_PAREN )
SYMBOL_EQUALS      =
SYMBOL_MINUS       -
SYMBOL_OPEN_PAREN  (
SYMBOL_PLUS        +
SYMBOL_SLASH       /
SYMBOL_STAR        *

scanner

- main
  consume [ \r\t]*    # whitespace
  consume "#" [^\n]*  # single-line comment

  if (not hasAnother) println; halt
  markPosition

  match
    produceAny Keywords
    produceAny Symbols
    case '\n' -> EOL
    case '"':    scan_string
  endMatch

  if (scan( [_a-zA-Z][_a-zA-Z0-9]* )) -> IDENTIFIER
  scan_number

  if (hasAnother) print read; restart
  halt

- scan_string
  # already read initial double quote
  while (hasAnother and not nextIs('\n'))
    if consume('"') produce STRING
    ch = read
    if (ch == '\\' and hasAnother) ch = read
    collect ch
  endWhile
  if nextIs('\n') syntaxError "Unterminated string."

- scan_number
  if (not hasAnother) return

  if (scan [0-9])
    scan_integer
    if (scan '.') scan_integer
    produce NUMBER
  elseIf (scan '.')
    scan_integer
    produce NUMBER
  else
    return
  endIf

- scan_integer
  while hasAnother
    if (not scan([0-9]) and not consume([_]*)) return
  endWhile
  return

parser

- identifier
  read
  #produce CmdTest(name)
  syntaxError "TODO"
#{
  #on IDENTIFIER -> Identifier(name=t:String)

  on '\n' -> EOL
  on [_A-Za-z] [_A-Za-z0-9]* -> IDENTIFIER

  if nextIs [0-9]
    scan_integer_discarding_underscores
    if (scan('.')) scan_integer_discarding_underscores
    produce NUMBER
  elseIf (nextIs '.' and peek(1) == [0-9])
    scan '.'
    scan_integer_discarding_underscores
    produce NUMBER
  endIf

  which input
    produceAny Symbols
  endWhich

  syntaxError

- scan_integer_discarding_underscores
  while hasAnother
    if (not scan [0-9]) return
    consumeAny '_'
  endWhile
}#


#{
- scan_integer
  while (ch is '0'..'9' or ch == '_')
    ch = read
    if (ch != '_') collect ch
    if (not hasAnother) return
    ch = peek
  endWhile
  return
}#

#{
[parser]
+ expression

- assign : RightBinary
  on "=" -> Assign

- add_subtract : Binary
  on "+" -> Add
  on "-" -> Subtract

- multiply_divide : Binary
  on "*" -> Multiply
  on "/" -> Divide

- power : Binary
  on "^" -> Power

- pre_unary : PreUnary
  on "-" -> Negate

- term
  on IDENTIFIER -> Access( name=t.content:String )
  on INTEGER    -> LiteralInt32( value=t.content:String )
  on '(' expression ')': return
  syntaxError
}#

