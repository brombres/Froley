module F2

class Cmd( t:Token )
  METHODS
    method cast_to( to_type:Type )->Cmd
      if (type == to_type) return this  # no cast needed

      which (to_type)
        case Type.LOGICAL:    return CastToLogical( t, this )
        case Type.CHARACTER:  return CastToCharacter( t, this )
        case Type.INTEGER:    return CastToInteger( t, this )
        case Type.TOKEN_TYPE: return CastToTokenType( t, this )
        case Type.STRING:     return CastToString( t, this )
        others
          throw t.error( "[INTERNAL] Unhandled cast type: $."(type) )
      endWhich

    method common_type( other:Cmd )->Type
      local a = require_type
      local b = other.require_type
      return Type( a->Int32.or_larger(b->Int32) )

    method dispatch( visitor:Visitor )->Cmd [propagated]
      return visitor.visit( this )

    method require_type->Type
      localize type
      if (not type.exists) throw t.error( "Value expected." )
      return type

    method require_value->Cmd
      require_type
      return this

    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      throw t.error( "Illegal assignment." )

    method to->Int32
      return this->String->Int32

    method to->Logical
      return this->Int32 != 0

    method to->Real64
      return this->Int32

    method to->CmdList
      return CmdList(t).[ add(this) ]

    method type->Type
      return Type.NONE
endClass

class CmdList : Cmd
  PROPERTIES
    list : Cmd[]

  METHODS
    method init( t )
      list = Cmd[](5)

    method init( t, args:CmdInitArgs )
      list = Cmd[]( args.count )
      list.add( forEach in args )

    method add( cmd:Cmd )
      list.add( cmd )

    method count->Int32
      return list.count

    method first->Cmd
      return list.first

    method get( index:Int32 )->Cmd
      return list[ index ]

    method last->Cmd
      return list.last

    method set( index:Int32, value:Cmd )->this
      list[ index ] = value
      return this

    method to->CmdList
      return this

    method to->String
      return list->String
endClass

class Literal : Cmd
  METHODS
endClass

class LiteralInt32( t, value:Int32 ) : Literal
  METHODS
    method init( t, string_value:String )
      value = string_value->Int32

    method to->Int32
      return value

    method to->Real64
      return value

    method to->String
      return value->String

    method type->Type
      return Type.INTEGER
endClass

class LiteralLogical( t, value:Logical ) : Literal
  METHODS
    method to->Int32
      return which{ value:1 || 0 }

    method to->Logical
      return value

    method to->Real64
      return which{ value:1 || 0 }

    method to->String
      return which{ value:"true" || "false" }

    method type->Type
      return Type.LOGICAL
endClass

class LiteralString( t, value:String ) : Literal
  METHODS
    method to->String
      return value.to_escaped_ascii

    method type->Type
      return Type.STRING
endClass

class LiteralCharacter( t, value:Character ) : Literal
  METHODS
    method to->String
      return value.to_escaped_ascii

    method type->Type
      return Type.CHARACTER
endClass

class LiteralStringOrCharacter( t, value:String ) : Literal
  METHODS
    method cast_to( to_type:Type )->Cmd
      which (to_type)
        case Type.CHARACTER
          if (value.count == 0) return LiteralCharacter( t, 0 )
          return LiteralCharacter( t, value[0] )
        case Type.STRING
          return LiteralString( t, value )
        others
          return prior.cast_to( to_type )
      endWhich

    method to->String
      return value.to_escaped_ascii

    method type->Type
      return Type.STRING
endClass

class Unary( t, operand:Cmd ) : Cmd
  METHODS
    method op->String
      throw UnsupportedOperationError()

    method to->String
      local op = this.op
      local space = which{ op.count and op[op.count-1].is_letter:" " || "" }
      return "($$$)" (op,space,operand)
endClass

class PostUnary : Unary
  METHODS
    method to->String
      local op = this.op
      local space = which{ op.count and op[0].is_letter:" " || "" }
      return "($$$)" (operand,space,op)
endClass

class Binary( t, left:Cmd, right:Cmd ) : Cmd
  METHODS
    method op->String
      throw UnsupportedOperationError()

    method to->String
      return "($ $ $)" (left,op,right)
endClass


class Identifier( t, name:String ) : Cmd
  METHODS
    method to->String
      return "$"(name)
endClass

class ElementDef : Cmd
  PROPERTIES
    routines = StringTable<<RoutineDef>>()
    vars     = StringTable<<Var>>()

  METHODS
    method define_var( t:Token, name:String, type=Type.NONE:Type )->Var
      local entry = vars.find( name )
      if (not entry)
        local v = Var( t, name, type )
        vars[name] = v
        return v
      endIf

      local existing = entry.value
      if (type != existing.type)
        if (not existing.type.exists)
          existing.type = type
        elseIf (type.exists)
          throw t.error( "Conflicting implicit types $ and $ for variable '$'."...
                         (existing.type,type,name) )
        endIf
      endIf

      return existing

    method var_type( name:String )->Type
      local entry = vars.find( name )
      if (not entry) return Type.NONE
      return entry.value.type
endClass

class ParserDef( t, name:String, code:Cmd ) : ElementDef
  METHODS
    method to->String
      return "ParserDef($)"(name)
endClass

class ScannerDef( t, name:String, code:Cmd ) : ElementDef
  METHODS
    method to->String
      return "ScannerDef($,$)"(name,code)
endClass


class RoutineDef( t, name:String, base_type:String, statements:Cmd ) : Cmd
  PROPERTIES
    ip : Int32

  METHODS
    method to->String
      return "RoutineDef($,$,$)"(name,base_type,statements)
endClass

class SubroutineDef : RoutineDef
  METHODS
    method to->String
      return "SubroutineDef($,$,$)"(name,base_type,statements)
endClass


class Add : Binary
  METHODS
    method op->String
      return "+"
endClass

class Subtract : Binary
  METHODS
    method op->String
      return "-"
endClass

class Multiply : Binary
  METHODS
    method op->String
      return "*"
endClass

class Divide : Binary
  METHODS
    method op->String
      return "/"
endClass

class Power : Binary
  METHODS
    method op->String
      return "^"
endClass

class Negate : Unary
  METHODS
    method op->String
      return "-"
endClass

class Access( t, name:String ) : Cmd
  METHODS
    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      local r = resolver.cur_element.routines[name]
      if (r) throw t.error( "Illegal assignment to a routine." )
      local v = resolver.cur_element.define_var( t, name, cmd.new_value.type )
      return WriteVar( v, cmd.new_value ).dispatch( resolver )

    method to->String
      return "$"(name)
endClass


class Assign( t, target:Cmd, new_value:Cmd ) : Cmd
  METHODS
    method to->String
      return "Assign($,$)"(target,new_value)
endClass


class Statements : CmdList
  METHODS
endClass

class While( t, condition:Cmd, statements:Cmd ) : Cmd
  METHODS
    method to->String
      return "While($,$)"(condition,statements)
endClass


class If( t, condition:Cmd, statements:Cmd, else_ifs:CmdList, _else:Statements ) : Cmd
  METHODS
    method to->String
      return "If($,$,$,$)"(condition,statements,else_ifs,_else)
endClass

class ElseIf( t, condition:Cmd, statements:Statements ) : Cmd
  METHODS
    method to->String
      return "ElseIf($,$)"(condition,statements)
endClass

class LogicalOr : Binary
  METHODS
    method op->String
      return "or"
endClass

class LogicalAnd : Binary
  METHODS
    method op->String
      return "and"
endClass

class CompareEQ : Binary
  METHODS
    method op->String
      return "=="
endClass

class CompareNE : Binary
  METHODS
    method op->String
      return "!="
endClass

class CompareLT : Binary
  METHODS
    method op->String
      return "<"
endClass

class CompareGT : Binary
  METHODS
    method op->String
      return ">"
endClass

class CompareLE : Binary
  METHODS
    method op->String
      return "<="
endClass

class CompareGE : Binary
  METHODS
    method op->String
      return ">="
endClass


class Increment( t, target:Cmd ) : Cmd
  METHODS
    method to->String
      return "Increment($)"(target)
endClass

class Decrement( t, target:Cmd ) : Cmd
  METHODS
    method to->String
      return "Decrement($)"(target)
endClass

class Print( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Print($)"(args)
endClass

class Println( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Println($)"(args)
endClass


class HasNext : Cmd
  METHODS
    method to->String
      return "hasNext"

    method type->Type
      return Type.LOGICAL
endClass


class Read : Cmd
  METHODS
    method to->String
      return "read"

    method type->Type
      return Type.CHARACTER
endClass

class Collect( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Collect($)"(args)
endClass

class WriteVar : Cmd
  PROPERTIES
    var       : Var
    new_value : Cmd

  METHODS
    method init( var, new_value )
      t = var.t

    method to->String
      return "WriteVar($,$)"(var.name,new_value)
endClass

class ReadVar : Cmd
  PROPERTIES
    var : Var

  METHODS
    method init( var )
      t = var.t

    method to->String
      return "ReadVar($)"(var.name)

    method type->Type
      return var.type
endClass

class ScanError( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "ScanError($)"(args)
endClass

class CastTo( t, operand, to_type:Type )  : Unary
  METHODS
    method to->String [override]
      return "$->$"(operand,to_type)

    method type->Type
      return to_type
endClass

class CastToLogical : Unary
  METHODS
    method to->String [override]
      return "$->Logical"(operand->String)

    method type->Type
      return Type.LOGICAL
endClass

class CastToCharacter : Unary
  METHODS
    method to->String [override]
      return "$->Character"(operand->String)

    method type->Type
      return Type.CHARACTER
endClass

class CastToInteger : Unary
  METHODS
    method to->String [override]
      return "$->Integer"(operand->String)

    method type->Type
      return Type.INTEGER
endClass

class CastToTokenType : Unary
  METHODS
    method to->String [override]
      return "$->TokenType"(operand->String)

    method type->Type
      return Type.TOKEN_TYPE
endClass

class CastToString : Unary
  METHODS
    method to->String [override]
      return "$->String"(operand->String)

    method type->Type
      return Type.STRING
endClass



class TokenGroup( t, name:String, definitions:CmdList ) : Cmd
  METHODS
    method to->String
      return "TokenGroup($,$)"(name,definitions)
endClass


class TokenDef( t, name:String, symbol:String, attributes:CmdList ) : Cmd
  METHODS
    method to->String
      return "TokenDef($,$,$)"(name,symbol,attributes)
endClass


class Symbol( t, name:String ) : Cmd
  METHODS
    method to->String
      return "$"(name)
endClass


class LogicalNot : Unary
  METHODS
    method op->String
      return "not"
endClass


class Consume( t, alternatives:CmdList ) : Cmd
  METHODS
    method to->String
      return "Consume($)"(alternatives)
endClass

class ConsumeValue( t, value:Cmd ) : Cmd
  METHODS
    method to->String
      return "ConsumeValue($)"(value)
endClass

class ConsumeAny( t, alternatives:Cmd ) : Cmd
  METHODS
    method to->String
      return "ConsumeAny($)"(alternatives)
endClass

class Call( t, routine_def:RoutineDef ) : Cmd
  METHODS
    method to->String
      return "Call($)"(routine_def.name)
endClass


class Return( t, value:Cmd ) : Cmd
  METHODS
    method to->String
      return "Return($)"(value)
endClass



class ScannerProduce( t, token_type:Cmd ) : Cmd
  METHODS
    method to->String
      return "ScannerProduce($)"(token_type)
endClass

class LiteralTokenType( t, token_type:TokenDef ) : Literal
  METHODS
    method to->String
      return "LiteralTokenType($)"(token_type.name)

    method type->Type
      return Type.TOKEN_TYPE
endClass



class Halt : Cmd
  METHODS
    method to->String
      return "halt"
endClass
