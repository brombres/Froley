module Froley

class RScannerCore( generator, scanner_def:ScannerDef ) : RogueSourceWriter
  METHODS
    method init_object
      class_name = "ScannerCore"

    method write_content
      writeln ...
        @|# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
         |
         |$include "CompileError.rogue"
         |$include "ScanTable.rogue"
         |$include "Token.rogue"
         |$include "TokenType.rogue"
         |
         |class ScannerCore [abstract]
         |  DEFINITIONS
      forEach (r in scanner_def.routines)
        writeln "    ip_$ = $" (r.name,r.ip)
      endForEach

      writeln ...
        @|
         |  PROPERTIES
         |    _filepath     : String
         |    _scanner      : ::Scanner
         |    line          = 1
         |    column        = 1
         |
         |    tokens        = Token[]
         |    buffer        = StringBuilder()
         |    output        = StringBuilder()
         |
         |    start_ip      = 0
         |    ip            : Int32
         |    halt          = false
         |
         |    _position_stack = Int32[]
         |
         |    # GENERATED PROPERTIES

      indent += 4
      if (scanner_def.vars.count)
        local max_w = 0
        max_w .= or_larger( (forEach in scanner_def.vars).name.count )

        forEach (v in scanner_def.vars)
          write "$ : "(v.name.left_justified(max_w))
          which (v.type)
            case FType.LOGICAL
              writeln "Logical"
            case FType.CHARACTER
              writeln "Character"
            case FType.INTEGER
              writeln "Int32"
            case FType.STRING
              writeln "String"
            others
              throw v.t.error( "[INTERNAL] Unhandled type '$' (1)."(v.type) )
          endWhich
        endForEach
      endIf

      forEach (entry in Program.scan_patterns.entries)
        writeln ''$ = ScanPattern( "$" )'' (entry.value,entry.key)
      endForEach

      scanner_def.dispatch( ScanTableDeclarationWriter(generator) )
      indent -= 4

      writeln ...
        @|
         |  METHODS
         |    method init( file:File )
         |      init( file.filepath, ::Scanner(file) )
         |      line   = 1
         |      column = 1
         |
         |    method init( filepath:String, content:String, line=1, column=1 )
         |      init( filepath, ::Scanner(content) )
         |
         |    method init( _filepath, _scanner )
         |      noAction
         |

      forEach (fn_name in Program.scanner_user_calls)
        writeln  "    method $ [abstract]" (fn_name)
        writeln
      endForEach

      writeln ...
        @|    method execute( ip:Int32 )
         |      _clear_state
         |      _execute( ip )
         |
         |    method tokenize( ip=null:Int32? )->Token[]
         |      if (ip) start_ip = ip.value
         |      _clear_state
         |      while (_execute(start_ip) or not halt)
         |        buffer.clear
         |      endWhile
         |      _on_output_line # flush any buffered output
         |      return tokens
         |
         |    method _add( type:TokenType )
         |      if (type.attributes & TokenType.ATTRIBUTE_CONTENT)
         |        tokens.add( _t(type,buffer) )
         |      else
         |        tokens.add( _t(type) )
         |      endIf
         |      buffer.clear
         |
         |    method _clear_state
         |      tokens = Token[]
         |      buffer.clear
         |      output.clear
         |      halt = false
         |
         |    method _describe_character( c:Character )->String
         |      if (c == 10 or c == 13)       return "end of line";
         |      elseIf (c >= 32 and c != 127) return "'$'" (c)
         |      else                          return "'$'" (c.to_escaped_ascii)
         |
         |    method _is_next( text:String )->Logical
         |      local location = _scanner.location
         |      local result = _scanner.consume( text )
         |      _scanner.location = location
         |      return result
         |
         |    method _must_consume( ch:Character )
         |      if (_scanner.consume(ch)) return
         |      local message = "Syntax error - expected $, found " (_describe_character(ch))
         |      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
         |      else                      message += "end of input."
         |      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )
         |
         |    method _must_consume( st:String )
         |      if (_scanner.consume(st)) return
         |      _throw_expected_string_error( "'$'" (st.to_escaped_ascii("'")) )
         |
         |    method _must_consume( pattern:ScanPattern )
         |      if (pattern.scan(_scanner)) return
         |      _throw_expected_string_error( pattern->String )
         |
         |    method _next_is( text:String )->Logical
         |      if (not _scanner.has_another(text.count)) return false
         |      local pos = _scanner.position
         |      forEach (ch at index in text)
         |        if (ch != _scanner.data[pos+index]) return false
         |      endForEach
         |      return true
         |
         |    method _on_output_line
         |      # Default behavior: print out 'output' and clear it. Can override this method.
         |      print( output ).flush
         |      output.clear
         |
         |    method _scan( ch:Character )->Logical
         |      if (not _scanner.consume(ch)) return false
         |      buffer.print ch
         |      return true
         |
         |    method _scan( text:String )->Logical
         |      if (not _scanner.consume(text)) return false
         |      buffer.print text
         |      return true
         |
         |    method _t( type:TokenType, content=null:String )->Token
         |      return Token( type, _filepath, _scanner.source, line, column, content )
         |
         |    method _throw_expected_string_error( st:String )
         |      local message = "Syntax error - expected $, found " (st)
         |      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
         |      else                      message += "end of input."
         |      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )
         |
         |    method _throw_syntax_error( message=null:String )
         |      if (not message)
         |        local builder = StringBuilder()
         |        builder.print "Syntax error - unexpected "
         |        if (not _scanner.has_another)
         |          builder.println "end of input."
         |        else
         |          builder.print( _describe_character(_scanner.peek) ).print( '.' )
         |        endIf
         |        message = builder->String
         |      endIf
         |      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )
         |
         |    method _execute( ip:Int32 )->Logical
         |      loop
         |        ++ip
         |        which (ip-1)

      scanner_def.routine_defs.dispatch( generator )

      writeln ...
        @|          others
         |            halt = true
         |            return false
         |        endWhich
         |      endLoop
         |
         |endClass
endClass

