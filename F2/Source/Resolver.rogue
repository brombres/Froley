module F2

class Resolver : FroleyVisitor
  PROPERTIES
    cur_scan           : Scan
    next_scan_table_id = 0

  METHODS
    method init( program:Program )
      prior.init( program )
      local t = program.nodes.t
      local null_attr = null as CmdList
      if (not program.tokens_by_name.contains("EOI"))
        program.tokens_by_name//EOI = TokenDef( t, "EOI", "end of input", null_attr )
      endIf
      if (not program.tokens_by_name.contains("COMPILE_ERROR"))
        program.tokens_by_name//COMPILE_ERROR = TokenDef( t, "COMPILE_ERROR", "compile error", null_attr )
      endIf

    method cast_to( cmd:Cmd, to_type:Type )->Cmd
      cmd = cmd.dispatch( this )
      if (cmd.type == to_type) return cmd
      return cmd.cast_to( to_type ).dispatch( this )

    method visit( cmd:Access )->Cmd [override]
      local r = cur_element.routines[ cmd.name ]
      if (r)
        return Call(cmd.t,r).dispatch( this )
      else
        local t_def = program.tokens_by_name[ cmd.name ]
        if (t_def)
          return LiteralTokenType( cmd.t, t_def ).dispatch(this)
        else
          return ReadVar(cur_element.define_var(cmd.t,cmd.name)).dispatch(this)
        endIf
      endIf

    method visit( cmd:Add )->Cmd  [override]
      cmd.left  .= dispatch( this )
      cmd.right .= dispatch( this )
      local common_type = cmd.left.common_type( cmd.right )
      if (cmd.left.require_type != common_type)
        cmd.left = cmd.left.cast_to( common_type ).dispatch( this )
      endIf
      if (cmd.right.require_type != common_type)
        cmd.right = cmd.right.cast_to( common_type ).dispatch( this )
      endIf
      if (cmd.left instanceOf Literal and cmd.right instanceOf Literal)
        which (common_type)
          case Type.LOGICAL
            local left  = (cmd.left as LiteralLogical).value
            local right = (cmd.right as LiteralLogical).value
            return LiteralLogical( cmd.t, left or right ).dispatch(this)
          case Type.CHARACTER
            local left  = (cmd.left as LiteralCharacter).value
            local right = (cmd.right as LiteralCharacter).value
            return LiteralCharacter( cmd.t, left+right ).dispatch(this)
          case Type.INTEGER
            local left  = (cmd.left as LiteralInteger).value
            local right = (cmd.right as LiteralInteger).value
            return LiteralInteger( cmd.t, left + right ).dispatch(this)
          case Type.STRING
            local left  = (cmd.left as LiteralString).value
            local right = (cmd.right as LiteralString).value
            return LiteralString( cmd.t, left + right ).dispatch(this)
          others
            throw UnsupportedOperationError()
        endWhich
      endIf
      return cmd

    method visit( cmd:Args )->Cmd [override]
      local result = prior.visit( cmd )
      if (not result) return null
      (forEach in cmd.list).require_value
      return result

    method visit( cmd:Assign )->Cmd [override]
      return cmd.target.resolve_assignment( cmd, this )

    method visit( cmd:CastTo )->Cmd [override]
      cmd.operand .= dispatch(this)
      local operand = cmd.operand

      local from_type = operand.require_type
      if (from_type == cmd.to_type) return operand  # no cast needed

      local t = cmd.t
      which (cmd.to_type)
        case Type.LOGICAL:    return CastToLogical( t, operand )
        case Type.CHARACTER:  return CastToCharacter( t, operand )
        case Type.INTEGER:    return CastToInteger( t, operand )
        case Type.TOKEN_TYPE: return CastToTokenType( t, operand )
        case Type.STRING:     return CastToString( t, operand )
        others
          throw t.error( "[INTERNAL] Unhandled cast type: $."(cmd.to_type) )
      endWhich

    method visit( cmd:ScannerProduce )->Cmd [override]
      cmd.token_type = cast_to( cmd.token_type, Type.TOKEN_TYPE )
      return cmd

    method visit( cmd:Scan )->Cmd [override]
      temporarily cur_scan = cmd
        if (not cmd.id)
          cmd.id = "scan_table_" + next_scan_table_id
          ++next_scan_table_id
        endIf
        if (cmd.expression)
          cmd.expression = cast_to( cmd.expression.dispatch(this), Type.STRING )
        endIf
        if (cmd._others and cmd.statement_lists.is_empty)
          cmd.table_builder.default = 0  # index 0 in statement_lists
          cmd.statement_lists.add( cmd._others )
        endIf
        return prior.visit( cmd )
      endTemporarily

    method visit( cmd:ScanOn )->Cmd [override]
      if (not cmd.is_resolved)
        cmd.is_resolved = true

        cmd.expression = cmd.expression.dispatch( this )
        if (cmd.expression.type == Type.INTEGER) cmd.expression .= cast_to( Type.CHARACTER )
        cmd.expression = cmd.expression.cast_to(Type.STRING).dispatch(this)
        if (cmd.expression not instanceOf LiteralString)
          throw cmd.t.error( "Literal string, character, or character code expected." )
        endIf

        cmd.statements = cmd.statements.dispatch(this)

        cur_scan.table_builder.add( (cmd.expression as LiteralString).value, cur_scan.statement_lists.count )
        cur_scan.statement_lists.add( cmd.statements )
      endIf
      return cmd

    method visit( cmd:ScanError )->Cmd [override]
      if (cmd.args)
        forEach (arg at i in cmd.args)
          cmd.args[i] = arg.cast_to( Type.STRING ).dispatch( this )
        endForEach
      endIf
      return cmd

    method visit( cmd:WriteBuffer )->Cmd [override]
      cmd.new_value = cmd.new_value.dispatch(this).require_value
      return cmd

    method visit( cmd:WriteVar )->Cmd [override]
      cmd.new_value = cmd.new_value.dispatch(this).require_value
      return cmd
endClass

