module Froley

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
$define PARSER_EXISTS true

$include "Cmd.rogue"
$include "Scanner.rogue"
$include "Visitor.rogue"

class ParserCore [abstract]
  DEFINITIONS
    ip_program = 0
    ip_section = 1
    ip_type_name = 2
    ip_identifier = 3
    ip_scanner_routines = 4
    ip_routine_name_and_attributes = 5
    ip_token_definitions = 6
    ip_attributes = 7
    ip_symbol = 8
    ip_consume_eols = 9
    ip_consume_eols_and_semicolons = 10
    ip_must_consume_eols = 11
    ip_scanner_multi_line_statements = 12
    ip_scanner_single_line_statements = 13
    ip_scanner_control_structure = 14
    ip_cases = 15
    ip__others = 16
    ip_scanner_multi_line_else_ifs = 17
    ip_scanner_multi_line_else = 18
    ip_scanner_single_line_else_ifs = 19
    ip_scanner_single_line_else = 20
    ip_scanner_statement = 21
    ip_scanner_product = 22
    ip_cmd_args = 23
    ip_cmd_arg = 24
    ip_scanner_args = 25
    ip_scanner_arg_list = 26
    ip_sequence_args = 27
    ip_sequence_arg_list = 28
    ip_pattern_sequence = 29
    ip_sequence_item = 30
    ip_empty_statements = 31
    ip_scanner_expression = 32
    ip_scanner_logical_or = 33
    ip_scanner_logical_or__inner = 34
    ip_scanner_logical_and = 35
    ip_scanner_logical_and__inner = 36
    ip_scanner_comparison = 37
    ip_scanner_comparison__inner = 38
    ip_scanner_add_subtract = 39
    ip_scanner_add_subtract__inner = 40
    ip_scanner_multiply_divide = 41
    ip_scanner_multiply_divide__inner = 42
    ip_scanner_power = 43
    ip_scanner_power__inner = 44
    ip_scanner_pre_unary = 45
    ip_scanner_term = 46
    ip_repeat_count = 47
    ip_parser_routines = 48
    ip_parser_multi_line_statements = 49
    ip_parser_single_line_statements = 50
    ip_parser_control_structure = 51
    ip_on_block = 52
    ip_parser_multi_line_else_ifs = 53
    ip_parser_multi_line_else = 54
    ip_parser_single_line_else_ifs = 55
    ip_parser_single_line_else = 56
    ip_parser_multi_line_else_ons = 57
    ip_parser_multi_line_else_on_others = 58
    ip_parser_single_line_else_ons = 59
    ip_parser_single_line_else_on_others = 60
    ip_parser_statement = 61
    ip_list_type = 62
    ip_parser_args = 63
    ip_parser_arg_list = 64
    ip_ttype_or_literal = 65
    ip_ttype_or_literal_inner = 66
    ip_attr_name_arg = 67
    ip_attribute_name = 68
    ip_token_id = 69
    ip_collect_parse_list = 70
    ip_string_id_or_routine = 71
    ip_parser_product = 72
    ip_parser_expression = 73
    ip_parser_logical_or = 74
    ip_parser_logical_or__inner = 75
    ip_parser_logical_and = 76
    ip_parser_logical_and__inner = 77
    ip_parser_comparison = 78
    ip_parser_comparison__inner = 79
    ip_parser_add_subtract = 80
    ip_parser_add_subtract__inner = 81
    ip_parser_multiply_divide = 82
    ip_parser_multiply_divide__inner = 83
    ip_parser_power = 84
    ip_parser_power__inner = 85
    ip_parser_pre_unary = 86
    ip_parser_term = 87
    ip_access = 88
    ip_additional_node_types = 89

  PROPERTIES
    _tokens          : Token[]
    _position        : Int32
    _limit           : Int32
    _cmd_stack       = Cmd[]
    _list_starts     = Int32[]
    _list_tokens     = Token[]
    _next_t          : Token
    _cur_t           : Token
    _saved_positions = ParserPosition[]
    start_ip         = 0
    ip               = 0
    buffer           = String()
    output           = String()

    disable_output : Int32

  METHODS
    method init( file:File )
      init( Scanner(file) )

    method init( filepath:String, content:String )
      init( Scanner(filepath,content) )

    method init( scanner:Scanner )
      local tokens = scanner.tokenize
      if (scanner.output.count) print scanner.output; flush
      init( tokens )

    method init( _tokens )
      _position = 0
      _limit = _tokens.count
      _cmd_stack.clear
      output.clear

    method has_another->Logical
      return _position < _limit

    method parse( ip=null:Int32? )->Cmd
      if (_position == _limit) return null
      if (ip) start_ip = ip.value
      _list_starts.clear
      _list_tokens.clear
      _next_t = _peek
      _cur_t = _next_t
      _execute( start_ip )
      _on_output_line # flush any buffered output
      if (disable_output) return null
      if (_cmd_stack.count != 1)
        @trace _cmd_stack
        throw _peek.error( "[INTERNAL] Expected exactly one command node remaining on stack." )
      endIf
      return _cmd_stack.remove_last

    method _begin_list
      _list_starts.add( _cmd_stack.count )
      _list_tokens.add( _next_t )

    method _consume( type:TokenType )->Logical
      if (_next_t.type != type) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_content( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_eols
      while (_next_t.type == TokenType.EOL)
        ++_position
        _next_t = _peek
      endWhile

    method _create_token_list
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] createTokenList/produceTokenlist without prior savePosition." )
      endIf
      local pos = _saved_positions.remove_last
      _cmd_stack.discard_from( pos.cmd_stack_count )
      local i1 = pos.position
      local limit = _position
      local list = Token[]( limit - i1 )
      forEach (i in i1..<limit) list.add( _tokens[i] )
      _push( TokenList(_tokens[i1],list), 0 )

    method _describe( type:TokenType )->String
      if (type.symbol[0].is_letter) return type.symbol
      return "'$'" (type.symbol)

    method _discard_list
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] discardList without corresponding beginList." )
      endIf
      _list_starts.remove_last
      _list_tokens.remove_last

    method _discard_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to discard." )
      endIf
      _saved_positions.remove_last

    method _list_t->Token
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] createList/produceList without corresponding beginList." )
      endIf
      return _list_tokens.remove_last

    method _must_consume_content( content:String )
      if (_consume_content(content)) return
      local expected = which{ content.contains('\''):content || "'$'"(content.to_escaped_ascii) }
      local next = _describe( _peek.type )
      _throw_syntax_error( "Expected $, found $." (expected,next) )

    method _next_is( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output )
      flush
      output.clear

    method _on_t->Token
     local result = _next_t
     ++_position
     _next_t = _peek
     return result

    method _peek->Token
      if (_position < _limit) return _tokens[ _position ]
      if (_tokens.count) return _tokens.last.cloned( TokenType.EOI )
      return Token( TokenType.EOI, null, null, 0, 0 )

    method _pop->Cmd
      if (disable_output)       return null
      elseIf (_cmd_stack.count) return _cmd_stack.remove_last
      throw _peek.error( "[INTERNAL] Attempt to pop command off empty command stack." )

    method _push( cmd:Cmd )
      if (not disable_output) _cmd_stack.add( cmd )

    method _push( cmd:Cmd, node_arg_count:Int32 )
      if (node_arg_count) _cmd_stack.discard_from( _cmd_stack.count - node_arg_count )
      _cmd_stack.add( cmd )

    method _push_list( list:Cmd )
      local i1 = _list_starts.remove_last
      list.add( forEach in _cmd_stack from i1 )
      _cmd_stack.discard_from( i1 )
      _cmd_stack.add( list )

    method _read->Token
      local result = _next_t
      if (_position < _limit) ++_position; _next_t = _peek
      return result

    method _restore_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to restore." )
      endIf
      local pos = _saved_positions.remove_last
      _position = pos.position
      _cmd_stack.discard_from( pos.cmd_stack_count )
      _cur_t = pos.cur_t
      _next_t = _peek

    method _save_position
      _saved_positions.add( ParserPosition(_position,_cmd_stack.count,_cur_t) )

    method _node_arg( relative:Int32 )->Cmd
      local i = _cmd_stack.count + relative
      if (i < 0) throw _peek.error( "[INTERNAL] Not enough nodes on stack to create new Cmd." )
      return _cmd_stack[i]

    method _logical_arg( relative:Int32 )->Logical
      local node = _node_arg( relative )
      if (node is null) return false
      return node->Logical

    method _character_arg( relative:Int32 )->Character
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Character

    method _integer_arg( relative:Int32 )->Int32
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Int32

    method _real_arg( relative:Int32 )->Real64
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Real64

    method _string_arg( relative:Int32 )->String
      local node = _node_arg( relative )
      if (node is null) return null
      return node->String

    method _string_to_Logical( st:String )->Logical
      if (st.equals("false",&ignore_case)) return false
      return true

    method _string_to_Character( st:String )->Character
      if (st.count == 0) return Character(0)
      return st[0]

    method _string_to_Integer( st:String )->Int32
      return st->Int32

    method _string_to_Real( st:String )->Real64
      return st->Real64

    method _throw_syntax_error( message=null:String, expected=null:TokenType? )
      if (message is null)
        local builder = String()
        local next = _describe( _peek.type )
        if (expected)
          builder.print "Expected $, found $." (_describe(expected.value),next)
        else
          builder.print "Unexpected $." (next)
        endIf
        message = builder
      endIf

      throw _peek.error( message )

    method _execute( ip:Int32 )
      which (ip)
        case ip_program: r_program
        case ip_section: r_section
        case ip_type_name: r_type_name
        case ip_identifier: r_identifier
        case ip_scanner_routines: r_scanner_routines
        case ip_routine_name_and_attributes: r_routine_name_and_attributes
        case ip_token_definitions: r_token_definitions
        case ip_attributes: r_attributes
        case ip_symbol: r_symbol
        case ip_consume_eols: r_consume_eols
        case ip_consume_eols_and_semicolons: r_consume_eols_and_semicolons
        case ip_must_consume_eols: r_must_consume_eols
        case ip_scanner_multi_line_statements: r_scanner_multi_line_statements
        case ip_scanner_single_line_statements: r_scanner_single_line_statements
        case ip_scanner_control_structure: r_scanner_control_structure
        case ip_cases: r_cases
        case ip__others: r__others
        case ip_scanner_multi_line_else_ifs: r_scanner_multi_line_else_ifs
        case ip_scanner_multi_line_else: r_scanner_multi_line_else
        case ip_scanner_single_line_else_ifs: r_scanner_single_line_else_ifs
        case ip_scanner_single_line_else: r_scanner_single_line_else
        case ip_scanner_statement: r_scanner_statement
        case ip_scanner_product: r_scanner_product
        case ip_cmd_args: r_cmd_args
        case ip_cmd_arg: r_cmd_arg
        case ip_scanner_args: r_scanner_args
        case ip_scanner_arg_list: r_scanner_arg_list
        case ip_sequence_args: r_sequence_args
        case ip_sequence_arg_list: r_sequence_arg_list
        case ip_pattern_sequence: r_pattern_sequence
        case ip_sequence_item: r_sequence_item
        case ip_empty_statements: r_empty_statements
        case ip_scanner_expression: r_scanner_expression
        case ip_scanner_logical_or: r_scanner_logical_or
        case ip_scanner_logical_or__inner: r_scanner_logical_or__inner
        case ip_scanner_logical_and: r_scanner_logical_and
        case ip_scanner_logical_and__inner: r_scanner_logical_and__inner
        case ip_scanner_comparison: r_scanner_comparison
        case ip_scanner_comparison__inner: r_scanner_comparison__inner
        case ip_scanner_add_subtract: r_scanner_add_subtract
        case ip_scanner_add_subtract__inner: r_scanner_add_subtract__inner
        case ip_scanner_multiply_divide: r_scanner_multiply_divide
        case ip_scanner_multiply_divide__inner: r_scanner_multiply_divide__inner
        case ip_scanner_power: r_scanner_power
        case ip_scanner_power__inner: r_scanner_power__inner
        case ip_scanner_pre_unary: r_scanner_pre_unary
        case ip_scanner_term: r_scanner_term
        case ip_repeat_count: r_repeat_count
        case ip_parser_routines: r_parser_routines
        case ip_parser_multi_line_statements: r_parser_multi_line_statements
        case ip_parser_single_line_statements: r_parser_single_line_statements
        case ip_parser_control_structure: r_parser_control_structure
        case ip_on_block: r_on_block
        case ip_parser_multi_line_else_ifs: r_parser_multi_line_else_ifs
        case ip_parser_multi_line_else: r_parser_multi_line_else
        case ip_parser_single_line_else_ifs: r_parser_single_line_else_ifs
        case ip_parser_single_line_else: r_parser_single_line_else
        case ip_parser_multi_line_else_ons: r_parser_multi_line_else_ons
        case ip_parser_multi_line_else_on_others: r_parser_multi_line_else_on_others
        case ip_parser_single_line_else_ons: r_parser_single_line_else_ons
        case ip_parser_single_line_else_on_others: r_parser_single_line_else_on_others
        case ip_parser_statement: r_parser_statement
        case ip_list_type: r_list_type
        case ip_parser_args: r_parser_args
        case ip_parser_arg_list: r_parser_arg_list
        case ip_ttype_or_literal: r_ttype_or_literal
        case ip_ttype_or_literal_inner: r_ttype_or_literal_inner
        case ip_attr_name_arg: r_attr_name_arg
        case ip_attribute_name: r_attribute_name
        case ip_token_id: r_token_id
        case ip_collect_parse_list: r_collect_parse_list
        case ip_string_id_or_routine: r_string_id_or_routine
        case ip_parser_product: r_parser_product
        case ip_parser_expression: r_parser_expression
        case ip_parser_logical_or: r_parser_logical_or
        case ip_parser_logical_or__inner: r_parser_logical_or__inner
        case ip_parser_logical_and: r_parser_logical_and
        case ip_parser_logical_and__inner: r_parser_logical_and__inner
        case ip_parser_comparison: r_parser_comparison
        case ip_parser_comparison__inner: r_parser_comparison__inner
        case ip_parser_add_subtract: r_parser_add_subtract
        case ip_parser_add_subtract__inner: r_parser_add_subtract__inner
        case ip_parser_multiply_divide: r_parser_multiply_divide
        case ip_parser_multiply_divide__inner: r_parser_multiply_divide__inner
        case ip_parser_power: r_parser_power
        case ip_parser_power__inner: r_parser_power__inner
        case ip_parser_pre_unary: r_parser_pre_unary
        case ip_parser_term: r_parser_term
        case ip_access: r_access
        case ip_additional_node_types: r_additional_node_types
        others
          return
      endWhich

    method r_program
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      while ((_position < _limit))
        r_section
        r_consume_eols
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      if (not disable_output) _push( ProgramDef(_cur_t,_node_arg(-1)), 1 )
      _cur_t = _previous_cur_t
      return

    method r_section
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_SCANNER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( null, 0 )
          r_must_consume_eols
          r_scanner_routines
          if (not disable_output) _push( ScannerDef(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_NATIVE_TYPES)
        temporarily _cur_t = _on_t
          _begin_list
          r_consume_eols
          while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
            r_identifier
            _consume(TokenType.SYMBOL_COMMA)
            r_consume_eols
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( NativeTypes(_list_t) )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_PARSER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( null, 0 )
          r_must_consume_eols
          r_parser_routines
          if (not disable_output) _push( ParserDef(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_TOKENS)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            if (not disable_output) _push( null, 0 )
          else
            r_identifier
          endIf
          r_token_definitions
          if (not disable_output) _push( TokenGroup(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_type_name
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,"Character"), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_INTEGER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,"Integer"), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_identifier
      _cur_t = _previous_cur_t

    method r_identifier
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Identifier expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_scanner_routines
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      while ((_next_t.type == TokenType.SYMBOL_MINUS))
        if (_next_t.type == TokenType.SYMBOL_MINUS)
          temporarily _cur_t = _on_t
            r_routine_name_and_attributes
            r_scanner_multi_line_statements
            if (not disable_output) _push( FroleyRoutine(_cur_t,_string_arg(-3),_string_arg(-2),_node_arg(-1)->(as Statements)), 3 )
          endTemporarily
        endIf
        r_consume_eols
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_routine_name_and_attributes
      local _previous_cur_t = _cur_t
      r_identifier
      if (_next_t.type == TokenType.CHARSET)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
        endTemporarily
      else
        if (not disable_output) _push( null, 0 )
      endIf
      r_must_consume_eols
      _cur_t = _previous_cur_t

    method r_token_definitions
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
        r_identifier
        if ((_next_t.type == TokenType.SYMBOL))
          r_symbol
        else
          if (not disable_output) _push( null, 0 )
        endIf
        r_attributes
        if (not disable_output) _push( TokenDef(_cur_t,_string_arg(-3),_string_arg(-2),_node_arg(-1)), 3 )
        r_consume_eols
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_attributes
      local _previous_cur_t = _cur_t
      if ((not _consume(TokenType.SYMBOL_OPEN_SQUARE)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      if (_consume(TokenType.SYMBOL_CLOSE_SQUARE))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _begin_list
      r_identifier
      while ((_consume(TokenType.SYMBOL_COMMA) or (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
        if (((not (_position < _limit)) or (_next_t.type == TokenType.EOL)))
          _throw_syntax_error("Closing ']' expected.")
          _cur_t = _previous_cur_t
          return
        endIf
        r_identifier
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_symbol
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Symbol(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Symbol expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_consume_eols
      local _previous_cur_t = _cur_t
      while (_consume(TokenType.EOL))
      endWhile
      _cur_t = _previous_cur_t

    method r_consume_eols_and_semicolons
      local _previous_cur_t = _cur_t
      while ((_consume(TokenType.EOL) or _consume(TokenType.SYMBOL_SEMICOLON)))
      endWhile
      _cur_t = _previous_cur_t

    method r_must_consume_eols
      local _previous_cur_t = _cur_t
      if (not _consume(TokenType.EOL)) _throw_syntax_error( &expected=TokenType.EOL )
      while (_consume(TokenType.EOL))
      endWhile
      _cur_t = _previous_cur_t

    method r_scanner_multi_line_statements
      local _previous_cur_t = _cur_t
      r_consume_eols_and_semicolons
      if ((not (_position < _limit)))
        _throw_syntax_error
        _cur_t = _previous_cur_t
        return
      endIf
      _begin_list
      while (((_position < _limit) and (not ((_next_t.type == TokenType.SYMBOL_MINUS) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))))
        r_scanner_control_structure
        r_consume_eols_and_semicolons
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_scanner_single_line_statements
      local _previous_cur_t = _cur_t
      _begin_list
      if (_consume(TokenType.EOL))
        if (disable_output)     _discard_list
        else                    _push_list( Statements(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_scanner_statement
      while (_consume(TokenType.SYMBOL_SEMICOLON))
        r_scanner_statement
      endWhile
      r_must_consume_eols
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_scanner_control_structure
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_IF)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            r_scanner_expression
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            r_scanner_expression
          endIf
          if (_consume(TokenType.EOL))
            r_scanner_multi_line_statements
            r_scanner_multi_line_else_ifs
            r_scanner_multi_line_else
            if (not _consume(TokenType.KEYWORD_END_IF)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_IF )
          else
            r_scanner_single_line_statements
            r_scanner_single_line_else_ifs
            r_scanner_single_line_else
          endIf
          if (not disable_output) _push( If(_cur_t,_node_arg(-4),_node_arg(-3)->(as Statements),_node_arg(-2),_node_arg(-1)->(as Statements)), 4 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_MATCH)
        temporarily _cur_t = _on_t
          if ((_consume(TokenType.EOL) or _consume(TokenType.KEYWORD_INPUT)))
            if (not disable_output) _push( null, 0 )
          elseIf (_consume(TokenType.SYMBOL_OPEN_PAREN))
            if (_consume(TokenType.KEYWORD_INPUT))
              if (not disable_output) _push( null, 0 )
            else
              r_scanner_expression
            endIf
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            r_scanner_expression
          endIf
          r_cases
          r__others
          if (not _consume(TokenType.KEYWORD_END_MATCH)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_MATCH )
          if (not disable_output) _push( Match(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_WHILE)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            r_scanner_expression
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            r_scanner_expression
          endIf
          if (_consume(TokenType.EOL))
            r_scanner_multi_line_statements
            if (not _consume(TokenType.KEYWORD_END_WHILE)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_WHILE )
          else
            r_scanner_single_line_statements
          endIf
          if (not disable_output) _push( While(_cur_t,_node_arg(-2),_node_arg(-1)->(as Statements)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_scanner_statement
      _cur_t = _previous_cur_t

    method r_cases
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      while ((_position < _limit))
        r_consume_eols
        if (_next_t.type == TokenType.KEYWORD_CASE)
          temporarily _cur_t = _on_t
            r_scanner_expression
            if (_consume(TokenType.SYMBOL_ARROW))
              r_consume_eols
              _begin_list
              r_scanner_product
              if (not disable_output) _push( ScannerCreate(_cur_t,_node_arg(-1)), 1 )
              if (not disable_output) _push( null, 0 )
              if (not disable_output) _push( Restart(_cur_t,_string_arg(-1)), 1 )
              if (disable_output)     _discard_list
              else                    _push_list( Statements(_list_t) )
            else
              _consume(TokenType.SYMBOL_COLON)
              r_consume_eols
              r_scanner_multi_line_statements
            endIf
            if (not disable_output) _push( MatchCase(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          endTemporarily
        elseIf (_next_t.type == TokenType.KEYWORD_PRODUCE_ANY)
          temporarily _cur_t = _on_t
            r_identifier
            if (not disable_output) _push( ProduceAny(_cur_t,_string_arg(-1)), 1 )
          endTemporarily
        else
          if (disable_output)     _discard_list
          else                    _push_list( CmdList(_list_t) )
          _cur_t = _previous_cur_t
          return
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r__others
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_OTHERS)
        temporarily _cur_t = _on_t
          _consume(TokenType.SYMBOL_COLON)
          r_consume_eols
          r_scanner_multi_line_statements
        endTemporarily
      else
        if (not disable_output) _push( null, 0 )
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_multi_line_else_ifs
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_next_t.type == TokenType.KEYWORD_ELSE_IF))
        _save_position
        if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
          temporarily _cur_t = _on_t
            if (_consume(TokenType.SYMBOL_OPEN_PAREN))
              r_scanner_expression
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            else
              r_scanner_expression
            endIf
            if ((_next_t.type == TokenType.EOL))
              _discard_position
            else
              _restore_position
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              _cur_t = _previous_cur_t
              return
            endIf
            r_scanner_multi_line_statements
            if (not disable_output) _push( ElseIf(_cur_t,_node_arg(-2),_node_arg(-1)->(as Statements)), 2 )
          endTemporarily
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_scanner_multi_line_else
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.KEYWORD_ELSE)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE)
        temporarily _cur_t = _on_t
          if ((not _consume(TokenType.EOL)))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
          r_scanner_multi_line_statements
          _discard_position
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_single_line_else_ifs
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_next_t.type == TokenType.KEYWORD_ELSE_IF))
        _save_position
        if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
          temporarily _cur_t = _on_t
            if (_consume(TokenType.SYMBOL_OPEN_PAREN))
              r_scanner_expression
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            else
              r_scanner_expression
            endIf
            if ((_next_t.type == TokenType.EOL))
              _restore_position
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              _cur_t = _previous_cur_t
              return
            else
              _discard_position
            endIf
            r_scanner_single_line_statements
            if (not disable_output) _push( ElseIf(_cur_t,_node_arg(-2),_node_arg(-1)->(as Statements)), 2 )
          endTemporarily
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_scanner_single_line_else
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.KEYWORD_ELSE)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
          r_scanner_single_line_statements
          _discard_position
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_statement
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_CALL)
        temporarily _cur_t = _on_t
          r_identifier
          if (not disable_output) _push( ScannerCallUserMethod(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_COLLECT)
        temporarily _cur_t = _on_t
          r_scanner_args
          if (not disable_output) _push( Collect(_cur_t,_node_arg(-1)->(as Args)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CREATE)
        temporarily _cur_t = _on_t
          r_scanner_product
          if (not disable_output) _push( ScannerCreate(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_DISCARD_POSITION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( DiscardPosition(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_HALT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Halt(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_MARK_POSITION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( MarkPosition(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_MODE)
        temporarily _cur_t = _on_t
          r_identifier
          if (not disable_output) _push( Mode(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_MUST_CONSUME)
        temporarily _cur_t = _on_t
          r_sequence_args
          if (not disable_output) _push( ScannerMustConsume(_cur_t,_node_arg(-1)->(as SequenceArgs)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NO_ACTION)
        temporarily _cur_t = _on_t
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRINT)
        temporarily _cur_t = _on_t
          r_scanner_args
          if (not disable_output) _push( Print(_cur_t,_node_arg(-1)->(as Args)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRINTLN)
        temporarily _cur_t = _on_t
          if (((not (_position < _limit)) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
            _begin_list
            if (disable_output)     _discard_list
            else                    _push_list( Args(_list_t) )
          else
            r_scanner_args
          endIf
          if (not disable_output) _push( Println(_cur_t,_node_arg(-1)->(as Args)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRODUCE)
        temporarily _cur_t = _on_t
          r_scanner_product
          if (not disable_output) _push( ScannerCreate(_cur_t,_node_arg(-1)), 1 )
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Restart(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_ARROW)
        temporarily _cur_t = _on_t
          r_consume_eols
          if (not disable_output) _push( ScannerCreate(_cur_t,_node_arg(-1)), 1 )
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Restart(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_RESTART)
        temporarily _cur_t = _on_t
          if ((_next_t.type == TokenType.EOL))
            if (not disable_output) _push( null, 0 )
          else
            r_identifier
          endIf
          if (not disable_output) _push( Restart(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_RESTORE_POSITION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( RestorePosition(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_RETURN)
        temporarily _cur_t = _on_t
          if ((_next_t.type == TokenType.EOL))
            if (not disable_output) _push( null, 0 )
          else
            _throw_syntax_error
            _cur_t = _previous_cur_t
            return
          endIf
          if (not disable_output) _push( Return(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_SAVE_POSITION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( SavePosition(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_SYNTAX_ERROR)
        temporarily _cur_t = _on_t
          if ((_next_t.type == TokenType.EOL))
            if (not disable_output) _push( null, 0 )
          else
            r_scanner_args
          endIf
          if (not disable_output) _push( ThrowSyntaxError(_cur_t,_node_arg(-1)->(as Args)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
        temporarily _cur_t = _on_t
          r_scanner_expression
          if (not disable_output) _push( Increment(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
        temporarily _cur_t = _on_t
          r_scanner_expression
          if (not disable_output) _push( Decrement(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_scanner_expression
      if (_next_t.type == TokenType.SYMBOL_ASSIGN)
        temporarily _cur_t = _on_t
          r_scanner_expression
          if (not disable_output) _push( Assign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Increment(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Decrement(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_product
      local _previous_cur_t = _cur_t
      r_identifier
      if (not disable_output) _push( Access(_cur_t,_string_arg(-1)), 1 )
      _cur_t = _previous_cur_t
      return

    method r_cmd_args
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      if (_consume(TokenType.SYMBOL_CLOSE_PAREN))
        if (disable_output)     _discard_list
        else                    _push_list( Args(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_cmd_arg
      while (_consume(TokenType.SYMBOL_COMMA))
        r_consume_eols
        r_cmd_arg
        r_consume_eols
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Args(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_cmd_arg
      local _previous_cur_t = _cur_t
      r_identifier
      if (_consume(TokenType.SYMBOL_ASSIGN))
        if (_next_t.type == TokenType.IDENTIFIER)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          endTemporarily
        elseIf (_next_t.type == TokenType.STRING)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          endTemporarily
        elseIf (_next_t.type == TokenType.NATIVE_LITERAL)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( NativeLiteral(_cur_t,_cur_t.content), 0 )
          endTemporarily
        else
          _throw_syntax_error("Content or \"quoted expression\" expected.")
          _cur_t = _previous_cur_t
          return
        endIf
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (_consume(TokenType.SYMBOL_COLON))
        r_type_name
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (not disable_output) _push( CreateCmdArg(_cur_t,_string_arg(-3),_node_arg(-2),_string_arg(-1)), 3 )
      _cur_t = _previous_cur_t
      return

    method r_scanner_args
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_consume_eols
        r_scanner_arg_list
        r_consume_eols
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        r_scanner_arg_list
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_arg_list
      local _previous_cur_t = _cur_t
      _begin_list
      if ((_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)
        if (disable_output)     _discard_list
        else                    _push_list( Args(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_scanner_expression
      while ((_position < _limit))
        if (_consume(TokenType.SYMBOL_COMMA))
          r_consume_eols
          r_scanner_expression
        elseIf (((_next_t.type == TokenType.EOL) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
          if (disable_output)     _discard_list
          else                    _push_list( Args(_list_t) )
          _cur_t = _previous_cur_t
          return
        else
          r_scanner_expression
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Args(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_sequence_args
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_consume_eols
        r_sequence_arg_list
        r_consume_eols
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        r_sequence_arg_list
      endIf
      _cur_t = _previous_cur_t

    method r_sequence_arg_list
      local _previous_cur_t = _cur_t
      _begin_list
      if ((_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)
        if (disable_output)     _discard_list
        else                    _push_list( SequenceArgs(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_scanner_expression
      while ((_position < _limit))
        if (_consume(TokenType.SYMBOL_COMMA))
          r_consume_eols
          r_scanner_expression
        elseIf (((_next_t.type == TokenType.EOL) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
          if (disable_output)     _discard_list
          else                    _push_list( SequenceArgs(_list_t) )
          _cur_t = _previous_cur_t
          return
        else
          r_scanner_expression
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( SequenceArgs(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_pattern_sequence
      local _previous_cur_t = _cur_t
      _begin_list
      if ((_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)
        if (disable_output)     _discard_list
        else                    _push_list( PatternSequence(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_sequence_item
      while ((_position < _limit))
        if (_consume(TokenType.SYMBOL_STAR))
          if (not disable_output) _push( ZeroOrMore(_cur_t,_node_arg(-1)), 1 )
        elseIf (_consume(TokenType.SYMBOL_PLUS))
          if (not disable_output) _push( OneOrMore(_cur_t,_node_arg(-1)), 1 )
        elseIf (_consume(TokenType.SYMBOL_QUESTION))
          if (not disable_output) _push( OptionalPattern(_cur_t,_node_arg(-1)), 1 )
        elseIf (_consume(TokenType.SYMBOL_COMMA))
          r_consume_eols
          r_sequence_item
        elseIf (((_next_t.type == TokenType.EOL) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
          if (disable_output)     _discard_list
          else                    _push_list( PatternSequence(_list_t) )
          _cur_t = _previous_cur_t
          return
        else
          r_sequence_item
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( PatternSequence(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_sequence_item
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_CURLY)
        temporarily _cur_t = _on_t
          r_pattern_sequence
          if (not _consume(TokenType.SYMBOL_CLOSE_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_CURLY )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.CHARSET)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( CharSet(_cur_t,_cur_t.content), 0 )
          r_repeat_count
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING_OR_CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralStringOrCharacter(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_empty_statements
      local _previous_cur_t = _cur_t
      _begin_list
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t

    method r_scanner_expression
      local _previous_cur_t = _cur_t
      r_scanner_logical_or
      _cur_t = _previous_cur_t

    method r_scanner_logical_or
      local _previous_cur_t = _cur_t
      r_scanner_logical_and
      r_scanner_logical_or__inner
      _cur_t = _previous_cur_t

    method r_scanner_logical_or__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_OR)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_logical_and
          if (not disable_output) _push( LogicalOr(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_logical_or__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_logical_and
      local _previous_cur_t = _cur_t
      r_scanner_comparison
      r_scanner_logical_and__inner
      _cur_t = _previous_cur_t

    method r_scanner_logical_and__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_AND)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_comparison
          if (not disable_output) _push( LogicalAnd(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_logical_and__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_comparison
      local _previous_cur_t = _cur_t
      r_scanner_add_subtract
      r_scanner_comparison__inner
      _cur_t = _previous_cur_t

    method r_scanner_comparison__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_EQ)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_add_subtract
          if (not disable_output) _push( CompareEQ(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_NE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_add_subtract
          if (not disable_output) _push( CompareNE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_LT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_add_subtract
          if (not disable_output) _push( CompareLT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_GT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_add_subtract
          if (not disable_output) _push( CompareGT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_LE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_add_subtract
          if (not disable_output) _push( CompareLE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_GE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_add_subtract
          if (not disable_output) _push( CompareGE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_add_subtract
      local _previous_cur_t = _cur_t
      r_scanner_multiply_divide
      r_scanner_add_subtract__inner
      _cur_t = _previous_cur_t

    method r_scanner_add_subtract__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_PLUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_multiply_divide
          if (not disable_output) _push( Add(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_add_subtract__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_multiply_divide
          if (not disable_output) _push( Subtract(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_add_subtract__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_multiply_divide
      local _previous_cur_t = _cur_t
      r_scanner_power
      r_scanner_multiply_divide__inner
      _cur_t = _previous_cur_t

    method r_scanner_multiply_divide__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_STAR)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_power
          if (not disable_output) _push( Multiply(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_multiply_divide__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_SLASH)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_power
          if (not disable_output) _push( Divide(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_multiply_divide__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_power
      local _previous_cur_t = _cur_t
      r_scanner_pre_unary
      r_scanner_power__inner
      _cur_t = _previous_cur_t

    method r_scanner_power__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_CARET)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_pre_unary
          if (not disable_output) _push( Power(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_scanner_power__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scanner_pre_unary
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_pre_unary
          if (not disable_output) _push( Negate(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NOT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_scanner_pre_unary
          if (not disable_output) _push( LogicalNot(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_scanner_term
      _cur_t = _previous_cur_t

    method r_scanner_term
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _on_t
          r_scanner_expression
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_CURLY)
        temporarily _cur_t = _on_t
          r_pattern_sequence
          if (not _consume(TokenType.SYMBOL_CLOSE_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_CURLY )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_BUFFER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ReadBuffer(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CHARACTER)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_scanner_expression
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          if (not disable_output) _push( CastToCharacter(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_INTEGER)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_scanner_expression
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          if (not disable_output) _push( CastToInteger(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CONSUME)
        temporarily _cur_t = _on_t
          r_sequence_args
          if (not disable_output) _push( ScannerConsume(_cur_t,_node_arg(-1)->(as SequenceArgs)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FALSE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("false")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_HAS_NEXT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ScannerHasAnother(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NEXT_IS)
        temporarily _cur_t = _on_t
          r_sequence_args
          if (not disable_output) _push( ScannerNextIs(_cur_t,_node_arg(-1)->(as SequenceArgs)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_OUTPUT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ReadOutput(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PEEK)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            r_scanner_expression
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( ScannerPeek(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_READ)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ScannerRead(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_SCAN)
        temporarily _cur_t = _on_t
          r_sequence_args
          if (not disable_output) _push( Scan(_cur_t,_node_arg(-1)->(as SequenceArgs)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_TRUE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("true")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.CHARSET)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( CharSet(_cur_t,_cur_t.content), 0 )
          r_repeat_count
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Access(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.INTEGER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralInteger(_cur_t,_string_to_Integer(_cur_t.content)), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          r_repeat_count
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.ANYCASE_STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content,_string_to_Logical("true")), 0 )
          r_repeat_count
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.STRING_OR_CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralStringOrCharacter(_cur_t,_cur_t.content), 0 )
          r_repeat_count
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_repeat_count
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_STAR)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ZeroOrMore(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_PLUS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( OneOrMore(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_QUESTION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( OptionalPattern(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_routines
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      while ((_next_t.type == TokenType.SYMBOL_MINUS))
        if (_next_t.type == TokenType.SYMBOL_MINUS)
          temporarily _cur_t = _on_t
            r_routine_name_and_attributes
            r_parser_multi_line_statements
            if (not disable_output) _push( FroleyRoutine(_cur_t,_string_arg(-3),_string_arg(-2),_node_arg(-1)->(as Statements)), 3 )
          endTemporarily
        endIf
        r_consume_eols
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_parser_multi_line_statements
      local _previous_cur_t = _cur_t
      r_consume_eols_and_semicolons
      if ((not (_position < _limit)))
        _throw_syntax_error
        _cur_t = _previous_cur_t
        return
      endIf
      _begin_list
      while (((_position < _limit) and (not ((_next_t.type == TokenType.SYMBOL_MINUS) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))))
        r_parser_control_structure
        r_consume_eols_and_semicolons
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_parser_single_line_statements
      local _previous_cur_t = _cur_t
      _begin_list
      if (_consume(TokenType.EOL))
        if (disable_output)     _discard_list
        else                    _push_list( Statements(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_parser_statement
      while (_consume(TokenType.SYMBOL_SEMICOLON))
        r_parser_statement
      endWhile
      r_must_consume_eols
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_parser_control_structure
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_IF)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            r_parser_expression
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            r_parser_expression
          endIf
          if (_consume(TokenType.EOL))
            r_parser_multi_line_statements
            r_parser_multi_line_else_ifs
            r_parser_multi_line_else
            if (not _consume(TokenType.KEYWORD_END_IF)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_IF )
          else
            r_parser_single_line_statements
            r_parser_single_line_else_ifs
            r_parser_single_line_else
          endIf
          if (not disable_output) _push( If(_cur_t,_node_arg(-4),_node_arg(-3)->(as Statements),_node_arg(-2),_node_arg(-1)->(as Statements)), 4 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ON)
        temporarily _cur_t = _on_t
          r_on_block
          if (not disable_output) _push( On(_cur_t,_node_arg(-5),_node_arg(-4)->(as Args),_node_arg(-3)->(as Statements),_node_arg(-2),_node_arg(-1)->(as Statements)), 5 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_ON_PEEK)
        temporarily _cur_t = _on_t
          r_on_block
          if (not disable_output) _push( On(_cur_t,_node_arg(-5),_node_arg(-4)->(as Args),_node_arg(-3)->(as Statements),_node_arg(-2),_node_arg(-1)->(as Statements),_string_to_Logical("true")), 5 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_WHILE)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            r_parser_expression
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            r_parser_expression
          endIf
          if (_consume(TokenType.EOL))
            r_parser_multi_line_statements
            if (not _consume(TokenType.KEYWORD_END_WHILE)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_WHILE )
          else
            r_parser_single_line_statements
          endIf
          if (not disable_output) _push( While(_cur_t,_node_arg(-2),_node_arg(-1)->(as Statements)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_parser_statement
      _cur_t = _previous_cur_t

    method r_on_block
      local _previous_cur_t = _cur_t
      r_ttype_or_literal
      r_collect_parse_list
      if (_consume(TokenType.EOL))
        r_parser_multi_line_statements
        r_parser_multi_line_else_ons
        r_parser_multi_line_else_on_others
        if (not _consume(TokenType.KEYWORD_END_ON)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_ON )
      else
        _consume(TokenType.SYMBOL_COLON)
        r_parser_single_line_statements
        r_parser_single_line_else_ons
        r_parser_single_line_else_on_others
      endIf
      _cur_t = _previous_cur_t

    method r_parser_multi_line_else_ifs
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_next_t.type == TokenType.KEYWORD_ELSE_IF))
        _save_position
        if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
          temporarily _cur_t = _on_t
            if (_consume(TokenType.SYMBOL_OPEN_PAREN))
              r_parser_expression
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            else
              r_parser_expression
            endIf
            if ((_next_t.type == TokenType.EOL))
              _discard_position
            else
              _restore_position
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              _cur_t = _previous_cur_t
              return
            endIf
            r_parser_multi_line_statements
            if (not disable_output) _push( ElseIf(_cur_t,_node_arg(-2),_node_arg(-1)->(as Statements)), 2 )
          endTemporarily
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_parser_multi_line_else
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.KEYWORD_ELSE)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE)
        temporarily _cur_t = _on_t
          if ((not _consume(TokenType.EOL)))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
          r_parser_multi_line_statements
          _discard_position
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_single_line_else_ifs
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_next_t.type == TokenType.KEYWORD_ELSE_IF))
        _save_position
        if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
          temporarily _cur_t = _on_t
            if (_consume(TokenType.SYMBOL_OPEN_PAREN))
              r_parser_expression
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            else
              r_parser_expression
            endIf
            if ((_next_t.type == TokenType.EOL))
              _restore_position
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              _cur_t = _previous_cur_t
              return
            else
              _discard_position
            endIf
            r_parser_single_line_statements
            if (not disable_output) _push( ElseIf(_cur_t,_node_arg(-2),_node_arg(-1)->(as Statements)), 2 )
          endTemporarily
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_parser_single_line_else
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.KEYWORD_ELSE)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
          r_parser_single_line_statements
          _discard_position
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_multi_line_else_ons
      local _previous_cur_t = _cur_t
      _begin_list
      while (((_next_t.type == TokenType.KEYWORD_ELSE_ON) or (_next_t.type == TokenType.KEYWORD_ELSE_ON_PEEK)))
        _save_position
        if (_next_t.type == TokenType.KEYWORD_ELSE_ON)
          temporarily _cur_t = _on_t
            r_token_id
            r_collect_parse_list
            if ((_next_t.type == TokenType.EOL))
              _discard_position
            else
              _restore_position
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              _cur_t = _previous_cur_t
              return
            endIf
            r_parser_multi_line_statements
            if (not disable_output) _push( ElseOn(_cur_t,_node_arg(-3),_node_arg(-2)->(as Args),_node_arg(-1)->(as Statements)), 3 )
          endTemporarily
        elseIf (_next_t.type == TokenType.KEYWORD_ELSE_ON_PEEK)
          temporarily _cur_t = _on_t
            r_token_id
            r_collect_parse_list
            if ((_next_t.type == TokenType.EOL))
              _discard_position
            else
              _restore_position
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              _cur_t = _previous_cur_t
              return
            endIf
            r_parser_multi_line_statements
            if (not disable_output) _push( ElseOn(_cur_t,_node_arg(-3),_node_arg(-2)->(as Args),_node_arg(-1)->(as Statements),_string_to_Logical("true")), 3 )
          endTemporarily
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_parser_multi_line_else_on_others
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.KEYWORD_ELSE_OTHERS)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE_OTHERS)
        temporarily _cur_t = _on_t
          if ((not _consume(TokenType.EOL)))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
          r_parser_multi_line_statements
          _discard_position
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_single_line_else_ons
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_next_t.type == TokenType.KEYWORD_ELSE_ON))
        _save_position
        if (_next_t.type == TokenType.KEYWORD_ELSE_ON)
          temporarily _cur_t = _on_t
            r_token_id
            r_collect_parse_list
            if ((_next_t.type == TokenType.EOL))
              _restore_position
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              _cur_t = _previous_cur_t
              return
            else
              _discard_position
            endIf
            _consume(TokenType.SYMBOL_COLON)
            r_parser_single_line_statements
            if (not disable_output) _push( ElseOn(_cur_t,_node_arg(-3),_node_arg(-2)->(as Args),_node_arg(-1)->(as Statements)), 3 )
          endTemporarily
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_parser_single_line_else_on_others
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.KEYWORD_ELSE_OTHERS)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE_OTHERS)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
          _consume(TokenType.SYMBOL_COLON)
          r_parser_single_line_statements
          _discard_position
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_statement
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_BEGIN_LIST)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( BeginList(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CALL)
        temporarily _cur_t = _on_t
          r_identifier
          if (not disable_output) _push( ParserCallUserMethod(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CREATE)
        temporarily _cur_t = _on_t
          r_parser_product
          if (not disable_output) _push( ParserCreate(_cur_t,_node_arg(-1)->(as CreateCmd)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CREATE_LIST)
        temporarily _cur_t = _on_t
          r_list_type
          if (not disable_output) _push( CreateList(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CREATE_NULL)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( CreateNull(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CREATE_TOKEN_LIST)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( CreateTokenList(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_DISCARD_LIST)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( DiscardList(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_DISCARD_POSITION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( DiscardPosition(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_MUST_CONSUME)
        temporarily _cur_t = _on_t
          r_ttype_or_literal
          if (not disable_output) _push( ParserMustConsume(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NO_ACTION)
        temporarily _cur_t = _on_t
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRINT)
        temporarily _cur_t = _on_t
          r_parser_args
          if (not disable_output) _push( Print(_cur_t,_node_arg(-1)->(as Args)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRINTLN)
        temporarily _cur_t = _on_t
          if (((not (_position < _limit)) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
            _begin_list
            if (disable_output)     _discard_list
            else                    _push_list( Args(_list_t) )
          else
            r_parser_args
          endIf
          if (not disable_output) _push( Println(_cur_t,_node_arg(-1)->(as Args)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_POP)
        temporarily _cur_t = _on_t
          r_access
          if (not disable_output) _push( ParserPop(_cur_t,_node_arg(-1)->(as Access)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRODUCE)
        temporarily _cur_t = _on_t
          r_parser_product
          if (not disable_output) _push( ParserProduce(_cur_t,_node_arg(-1)->(as CreateCmd)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_ARROW)
        temporarily _cur_t = _on_t
          r_parser_product
          if (not disable_output) _push( ParserProduce(_cur_t,_node_arg(-1)->(as CreateCmd)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRODUCE_NULL)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( CreateNull(_cur_t), 0 )
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Return(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRODUCE_LIST)
        temporarily _cur_t = _on_t
          r_list_type
          if (not disable_output) _push( ProduceList(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRODUCE_TOKEN_LIST)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ProduceTokenList(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PUSH)
        temporarily _cur_t = _on_t
          r_access
          if (not disable_output) _push( ParserPush(_cur_t,_node_arg(-1)->(as Access)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_RESTORE_POSITION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( RestorePosition(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_RETURN)
        temporarily _cur_t = _on_t
          if ((_next_t.type == TokenType.EOL))
            if (not disable_output) _push( null, 0 )
          else
            _throw_syntax_error
            _cur_t = _previous_cur_t
            return
          endIf
          if (not disable_output) _push( Return(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_SAVE_POSITION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( SavePosition(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_SYNTAX_ERROR)
        temporarily _cur_t = _on_t
          if ((_next_t.type == TokenType.EOL))
            if (not disable_output) _push( null, 0 )
          else
            r_parser_args
          endIf
          if (not disable_output) _push( ThrowSyntaxError(_cur_t,_node_arg(-1)->(as Args)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
        temporarily _cur_t = _on_t
          r_parser_expression
          if (not disable_output) _push( Increment(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
        temporarily _cur_t = _on_t
          r_parser_expression
          if (not disable_output) _push( Decrement(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_parser_expression
      if (_next_t.type == TokenType.SYMBOL_ASSIGN)
        temporarily _cur_t = _on_t
          r_parser_expression
          if (not disable_output) _push( Assign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Increment(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Decrement(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_list_type
      local _previous_cur_t = _cur_t
      if ((_next_t.type == TokenType.IDENTIFIER))
        r_identifier
      else
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _cur_t = _previous_cur_t

    method r_parser_args
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_consume_eols
        r_parser_arg_list
        r_consume_eols
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        r_parser_arg_list
      endIf
      _cur_t = _previous_cur_t

    method r_parser_arg_list
      local _previous_cur_t = _cur_t
      _begin_list
      if ((_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)
        if (disable_output)     _discard_list
        else                    _push_list( Args(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_parser_expression
      while ((_position < _limit))
        if (_consume(TokenType.SYMBOL_COMMA))
          r_consume_eols
          r_parser_expression
        elseIf (((_next_t.type == TokenType.EOL) or (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
          if (disable_output)     _discard_list
          else                    _push_list( Args(_list_t) )
          _cur_t = _previous_cur_t
          return
        else
          r_parser_expression
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Args(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_ttype_or_literal
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_ttype_or_literal_inner
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        r_ttype_or_literal_inner
      endIf
      _cur_t = _previous_cur_t

    method r_ttype_or_literal_inner
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_AT))
        r_token_id
        if (not disable_output) _push( LiteralContent(_cur_t,_string_arg(-1)), 1 )
      else
        r_token_id
      endIf
      _cur_t = _previous_cur_t

    method r_attr_name_arg
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_attribute_name
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        r_attribute_name
      endIf
      _cur_t = _previous_cur_t

    method r_attribute_name
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING_OR_CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Attribute name expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_token_id
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING_OR_CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("TOKEN_ID or \"token_name\" expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_collect_parse_list
      local _previous_cur_t = _cur_t
      _begin_list
      while ((((_position < _limit) and (not (_next_t.type == TokenType.EOL))) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
        _consume(TokenType.SYMBOL_COMMA)
        r_string_id_or_routine
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Args(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_string_id_or_routine
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING_OR_CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("TOKEN_ID, \"token_name\", or routine_name expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_parser_product
      local _previous_cur_t = _cur_t
      r_consume_eols
      r_identifier
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_cmd_args
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        _begin_list
        if (disable_output)     _discard_list
        else                    _push_list( Args(_list_t) )
      endIf
      if (_consume(TokenType.SYMBOL_COLON))
        r_type_name
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (not disable_output) _push( CreateCmd(_cur_t,_string_arg(-3),_node_arg(-2)->(as Args),_string_arg(-1)), 3 )
      _cur_t = _previous_cur_t
      return

    method r_parser_expression
      local _previous_cur_t = _cur_t
      r_parser_logical_or
      _cur_t = _previous_cur_t

    method r_parser_logical_or
      local _previous_cur_t = _cur_t
      r_parser_logical_and
      r_parser_logical_or__inner
      _cur_t = _previous_cur_t

    method r_parser_logical_or__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_OR)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_logical_and
          if (not disable_output) _push( LogicalOr(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_logical_or__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_logical_and
      local _previous_cur_t = _cur_t
      r_parser_comparison
      r_parser_logical_and__inner
      _cur_t = _previous_cur_t

    method r_parser_logical_and__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_AND)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_comparison
          if (not disable_output) _push( LogicalAnd(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_logical_and__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_comparison
      local _previous_cur_t = _cur_t
      r_parser_add_subtract
      r_parser_comparison__inner
      _cur_t = _previous_cur_t

    method r_parser_comparison__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_EQ)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_add_subtract
          if (not disable_output) _push( CompareEQ(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_NE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_add_subtract
          if (not disable_output) _push( CompareNE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_LT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_add_subtract
          if (not disable_output) _push( CompareLT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_GT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_add_subtract
          if (not disable_output) _push( CompareGT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_LE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_add_subtract
          if (not disable_output) _push( CompareLE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_GE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_add_subtract
          if (not disable_output) _push( CompareGE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_add_subtract
      local _previous_cur_t = _cur_t
      r_parser_multiply_divide
      r_parser_add_subtract__inner
      _cur_t = _previous_cur_t

    method r_parser_add_subtract__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_PLUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_multiply_divide
          if (not disable_output) _push( Add(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_add_subtract__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_multiply_divide
          if (not disable_output) _push( Subtract(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_add_subtract__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_multiply_divide
      local _previous_cur_t = _cur_t
      r_parser_power
      r_parser_multiply_divide__inner
      _cur_t = _previous_cur_t

    method r_parser_multiply_divide__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_STAR)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_power
          if (not disable_output) _push( Multiply(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_multiply_divide__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_SLASH)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_power
          if (not disable_output) _push( Divide(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_multiply_divide__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_power
      local _previous_cur_t = _cur_t
      r_parser_pre_unary
      r_parser_power__inner
      _cur_t = _previous_cur_t

    method r_parser_power__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_CARET)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_pre_unary
          if (not disable_output) _push( Power(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_parser_power__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_parser_pre_unary
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_pre_unary
          if (not disable_output) _push( Negate(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NOT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_parser_pre_unary
          if (not disable_output) _push( LogicalNot(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_parser_term
      _cur_t = _previous_cur_t

    method r_parser_term
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _on_t
          r_parser_expression
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_BUFFER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ReadBuffer(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CONSUME)
        temporarily _cur_t = _on_t
          r_ttype_or_literal
          if (not disable_output) _push( ParserConsume(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FALSE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("false")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_HAS_NEXT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ParserHasAnother(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NEXT_HAS_ATTRIBUTE)
        temporarily _cur_t = _on_t
          r_attr_name_arg
          if (not disable_output) _push( NextHasAttribute(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NEXT_IS)
        temporarily _cur_t = _on_t
          r_ttype_or_literal
          if (not disable_output) _push( ParserNextIs(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_OUTPUT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ReadOutput(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_READ)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( ParserRead(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_TRUE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("true")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Access(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.INTEGER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralInteger(_cur_t,_string_to_Integer(_cur_t.content)), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING_OR_CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralStringOrCharacter(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_access
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Access(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Variable name expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_additional_node_types
      local _previous_cur_t = _cur_t
      if (not disable_output) _push( WriteBuffer(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( WriteOutput(_cur_t,_node_arg(-1)), 1 )
      _cur_t = _previous_cur_t

endClass

class ParserPosition( position:Int32, cmd_stack_count:Int32, cur_t:Token ) [compound];
