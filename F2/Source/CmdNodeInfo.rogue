module F2

class CmdNodeInfo
  PROPERTIES
    name         : String
    program      : Program
    base_type    : CmdNodeInfo
    constructors = StringTable<<CreateCmd>>()
    properties   : NameAndType[]

  METHODS
    method init( name, program )
      if (name != "Cmd") base_type = "Cmd"

    method add( constructor:CreateCmd )
      constructors[ constructor.signature ] = constructor

    method add_property( name:String, type:String )
      properties.add( NameAndType(name,type) )

    method description->String
      return name

    method extended_properties->NameAndType[]
      if (not base_type) return properties

      local types = StringTable<<NameAndType>>()
      forEach (p in properties) types[p.name] = p
      forEach (p in base_type.properties) types.remove(p.name)
      return types.values.to_list

    method properties->NameAndType[]
      if (@properties) return @properties

      local types = StringTable<<NameAndType>>()
      forEach (constructor in constructors)
        if (constructor.args)
          local args = constructor.args as Args
          forEach (arg in args)
            block arg = arg as CreateCmdArg
              local name_and_type = NameAndType( arg.arg_name, arg.arg_type )
              if (types.contains(name_and_type.name))
                local existing = types[ name_and_type.name ]
                if (existing != name_and_type)
                  throw arg.t.error( "Multiple definitions of '$' as both type '$' and type '$'." ...
                    (name_and_type.name,name_and_type.type,existing.type) )
                endIf
              endIf
              types[ name_and_type.name ] = name_and_type
            endBlock
          endForEach
        endIf
      endForEach

      #if (base_type)
      #  # Remove properties found in the base type
      #  forEach (base_property in base_type.properties)
      #    if (types.contains(base_property.name))
      #      # Need to save a t (token) to do the following. Will leave as a TODO.
      #      #local existing = types[ base_property.name ]
      #      #if (existing != base_property)
      #      #  throw arg.t.error( "Multiple definitions of '$' as both type '$' and inherited type '$'." ...
      #      #    (base_property.name,existing.type,base_property.type) )
      #      #endIf
      #      types.remove( base_property.name )
      #    endIf
      #  endForEach
      #endIf

      @properties = types.values.to_list
      return @properties

    method set_base_type( @base_type )

    method set_base_type( base_type_name:String )
      local info = program.cmd_node_info[ base_type_name ]
      if (not info)
        info = CmdNodeInfo( base_type_name, program )
        program.cmd_node_info[ base_type_name ] = info
      endIf
      @base_type = info

endClass

class NameAndType( name:String, type:String ) [compound]
  METHODS
    method description->String
      return "$:$" (name,type)

    method hash_code->Int32
      return name.hash_code ~ type.hash_code

    method operator==( other:NameAndType )->Logical
      return name == other.name and type == other.type
endClass

