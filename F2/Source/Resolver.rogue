module F2

class Resolver : FroleyVisitor
  PROPERTIES
    cur_match           : Match
    next_scan_table_id = 0

  METHODS
    method init( program:Program )
      prior.init( program )
      local t = program.nodes.t
      local null_attr = null as CmdList
      if (not program.tokens_by_name.contains("EOI"))
        program.tokens_by_name//EOI = TokenDef( t, "EOI", "end of input", null_attr )
      endIf
      if (not program.tokens_by_name.contains("COMPILE_ERROR"))
        program.tokens_by_name//COMPILE_ERROR = TokenDef( t, "COMPILE_ERROR", "compile error", null_attr )
      endIf

    method cast_to( cmd:Cmd, to_type:Type )->Cmd
      cmd = cmd.dispatch( this )
      if (cmd.type == to_type) return cmd
      return cmd.cast_to( to_type ).dispatch( this )

    method resolve_sequence( cmd:Args )->Cmd
      cmd.dispatch( this )

      local any_patterns = false
      local all_strings = true
      forEach (element in cmd)
        if (element.type != Type.STRING and element.type != Type.CHARACTER)
          all_strings = false
        endIf

        if (element.type == Type.PATTERN)
          any_patterns = true
          escapeForEach
        endIf
      endForEach

      if (any_patterns)
        if (cmd.count == 1)
          return Pattern( cmd.t, cmd.first->ScanPattern ).dispatch( this )
        else
          # Convert this list into a pattern
          local pattern = ScanPatternList( ScanPattern[] )
          pattern.add( (forEach in cmd)->ScanPattern )
          return Pattern( cmd.t, pattern ).dispatch( this )
        endIf
      endIf

      # Non-pattern
      if (cmd.count == 1) return cmd[0]

      # All characters and strings?
      if (all_strings)
        use builder = StringBuilder.pool
          builder.print( (forEach in cmd)->String )
          if (builder.count == 1) return LiteralCharacter( cmd.t, builder[0] )
          else                    return LiteralString( cmd.t, builder->String )
        endUse
      endIf

      throw cmd[1].t.error( "Too many arguments." )

    method visit( cmd:Access )->Cmd [override]
      local r = cur_element.routines[ cmd.name ]
      if (r)
        return Call(cmd.t,r).dispatch( this )
      else
        local t_def = program.tokens_by_name[ cmd.name ]
        if (t_def)
          return LiteralTokenType( cmd.t, t_def ).dispatch(this)
        else
          return ReadVar(cur_element.define_var(cmd.t,cmd.name)).dispatch(this)
        endIf
      endIf

    method visit( cmd:Add )->Cmd  [override]
      cmd.left  .= dispatch( this )
      cmd.right .= dispatch( this )
      local common_type = cmd.left.common_type( cmd.right )
      if (cmd.left.require_type != common_type)
        cmd.left = cmd.left.cast_to( common_type ).dispatch( this )
      endIf
      if (cmd.right.require_type != common_type)
        cmd.right = cmd.right.cast_to( common_type ).dispatch( this )
      endIf
      if (cmd.left instanceOf Literal and cmd.right instanceOf Literal)
        which (common_type)
          case Type.LOGICAL
            local left  = (cmd.left as LiteralLogical).value
            local right = (cmd.right as LiteralLogical).value
            return LiteralLogical( cmd.t, left or right ).dispatch(this)
          case Type.CHARACTER
            local left  = (cmd.left as LiteralCharacter).value
            local right = (cmd.right as LiteralCharacter).value
            return LiteralCharacter( cmd.t, left+right ).dispatch(this)
          case Type.INTEGER
            local left  = (cmd.left as LiteralInteger).value
            local right = (cmd.right as LiteralInteger).value
            return LiteralInteger( cmd.t, left + right ).dispatch(this)
          case Type.STRING
            local left  = (cmd.left as LiteralString).value
            local right = (cmd.right as LiteralString).value
            return LiteralString( cmd.t, left + right ).dispatch(this)
          others
            throw UnsupportedOperationError()
        endWhich
      endIf
      return cmd

    method visit( cmd:Args )->Cmd [override]
      local result = prior.visit( cmd )
      if (not result) return null
      (forEach in cmd.list).require_value
      return result

    method visit( cmd:Assign )->Cmd [override]
      return cmd.target.resolve_assignment( cmd, this )

    method visit( cmd:CastToPattern )->Cmd [override]
      return Pattern( cmd.t, cmd.operand->ScanPattern ).dispatch( this )

    method visit( cmd:Consume )->Cmd [override]
      local seq = resolve_sequence( cmd.args )
      which (seq.require_type)
        case Type.CHARACTER, Type.STRING
          return ConsumeCharacters( cmd.t, seq ).dispatch( this )
        case Type.PATTERN
          return ConsumePattern( cmd.t, seq ).dispatch( this )
        others
          throw cmd.t.error( "Expected character, string, or pattern; found type $."(seq.type.display_name) )
      endWhich

    method visit( cmd:MustConsume )->Cmd [override]
      local seq = resolve_sequence( cmd.args )
      which (seq.require_type)
        case Type.CHARACTER, Type.STRING
          return MustConsumeCharacters( cmd.t, seq ).dispatch( this )
        case Type.PATTERN
          return MustConsumePattern( cmd.t, seq ).dispatch( this )
        others
          throw cmd.t.error( "Expected character, string, or pattern; found type $."(seq.type.display_name) )
      endWhich

    method visit( cmd:Pattern )->Cmd [override]
      if (not cmd.reference_name)
        local pattern = cmd.scan_pattern->String
        if (not program.scan_patterns.contains(pattern))
          program.scan_patterns[ pattern ] = "_scan_pattern_" + program.scan_patterns.count
        endIf
        cmd.reference_name = program.scan_patterns[ pattern ]
      endIf
      return cmd

    method visit( cmd:ScannerProduce )->Cmd [override]
      cmd.token_type = cast_to( cmd.token_type, Type.TOKEN_TYPE )
      return cmd

    method visit( cmd:Match )->Cmd [override]
      temporarily cur_match = cmd
        if (not cmd.id)
          cmd.id = "scan_table_" + next_scan_table_id
          ++next_scan_table_id
        endIf
        if (cmd.expression)
          cmd.expression = cast_to( cmd.expression.dispatch(this), Type.STRING )
        endIf
        if (cmd._others and cmd.statement_lists.is_empty)
          cmd.table_builder.default = 0  # index 0 in statement_lists
          cmd.statement_lists.add( cmd._others )
        endIf
        return prior.visit( cmd )
      endTemporarily

    method visit( cmd:MatchCase )->Cmd [override]
      if (not cmd.is_resolved)
        cmd.is_resolved = true

        cmd.expression = cmd.expression.dispatch( this )
        if (cmd.expression.type == Type.INTEGER) cmd.expression .= cast_to( Type.CHARACTER )
        cmd.expression = cmd.expression.cast_to(Type.STRING).dispatch(this)
        if (cmd.expression not instanceOf LiteralString)
          throw cmd.t.error( "Literal string, character, or character code expected." )
        endIf

        cmd.statements = cmd.statements.dispatch(this)

        cur_match.table_builder.add( (cmd.expression as LiteralString).value, cur_match.statement_lists.count )
        cur_match.statement_lists.add( cmd.statements )
      endIf
      return cmd

    method visit( cmd:NextIs )->Cmd [override]
      local seq = resolve_sequence( cmd.args )
      which (seq.require_type)
        case Type.CHARACTER, Type.STRING
          return NextIsCharacters( cmd.t, seq ).dispatch( this )
        case Type.PATTERN
          return NextIsPattern( cmd.t, seq ).dispatch( this )
        others
          throw cmd.t.error( "Expected character, string, or pattern; found type $."(seq.type.display_name) )
      endWhich

    method visit( cmd:Scan )->Cmd [override]
      local seq = resolve_sequence( cmd.args )
      which (seq.require_type)
        case Type.CHARACTER, Type.STRING
          return ScanCharacters( cmd.t, seq ).dispatch( this )
        case Type.PATTERN
          return ScanPatternCmd( cmd.t, seq ).dispatch( this )
        others
          throw cmd.t.error( "Expected character, string, or pattern; found type $."(seq.type.display_name) )
      endWhich

    method visit( cmd:ScanError )->Cmd [override]
      if (cmd.args)
        forEach (arg at i in cmd.args)
          cmd.args[i] = arg.cast_to( Type.STRING ).dispatch( this )
        endForEach
      endIf
      return cmd

    method visit( cmd:WriteBuffer )->Cmd [override]
      cmd.new_value = cmd.new_value.dispatch(this).require_value
      return cmd

    method visit( cmd:WriteVar )->Cmd [override]
      cmd.new_value = cmd.new_value.dispatch(this).require_value
      return cmd
endClass

