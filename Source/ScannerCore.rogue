module Froley

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.

$include "CompileError.rogue"
$include "ScanTable.rogue"
$include "Token.rogue"
$include "TokenType.rogue"

class ScannerCore [abstract]
  DEFINITIONS
    ip_scan_standard_token = 0
    ip_scan_charset = 1
    ip_consume_whitespace = 2
    ip_consume_comment = 3
    ip_scan_optional_plain_id = 4
    ip_scan_tokens_id = 5
    ip_scan_token_name = 6
    ip_scan_token_symbol = 7
    ip_scan_token_attributes = 8
    ip_scan_identifier = 9
    ip_must_scan_attribute_identifier = 10
    ip_scan_integer = 11
    ip_scan_single_quoted_string = 12
    ip_scan_double_quoted_string = 13
    ip_scan_literal_character = 14

  PROPERTIES
    _filepath     : String
    _scanner      : ::Scanner
    line          = 1
    column        = 1

    tokens        = Token[]
    buffer        = StringBuilder()
    output        = StringBuilder()

    start_ip      = 0
    ip            : Int32
    halt          = false

    _position_stack = Int32[]
    _line_stack     = Int32[]
    _column_stack   = Int32[]

    # GENERATED PROPERTIES
    scanning_node_logic : Logical
    ch                  : Character
    count               : Int32
    _scan_pattern_0 = ScanPattern( "[0-9]" )
    _scan_pattern_1 = ScanPattern( "{[a-zA-Z_][a-zA-Z_0-9]*}" )
    _scan_pattern_2 = ScanPattern( "{[a-zA-Z_][a-zA-Z0-9_]*}" )
    _scan_pattern_3 = ScanPattern( "[0-9_]" )
    _scan_table_0 = ScanTable("gQoAFi0uPThAPl5AfUIpRF1GOkgsSi5MW1I+WDxeIWR7aihsK24/dDt2J3gvgQYqgQgSAj40LTYBABMAAgE9PAwAAwAEAAUABgAHAAgACQD/AS5QCgAWAV1WCwAOAT1cDQAQAT1iDwD/AT1oEQAUABUAFwErchgAGQAaAP8BXHz/ASeBAP8BJ4EEGwAcAB0A")
    _scan_table_1 = ScanTable("gRoABG4KcFRzanSBBP8CYRBvNv8BdBT/AWkY/wF2HP8BZSD/AVQk/wF5KP8BcCz/AWUw/wFzNAEA/wFkOv8BZT7/AUxC/wFvRv8BZ0r/AWlO/wFjUgIA/wFhWP8Bclz/AXNg/wFlZP8BcmgDAP8BY27/AWFy/wFudv8Bbnr/AWV+/wFygQIEAP8Bb4EI/wFrgQz/AWWBEP8BboEU/wFzgRgFAA==")
    _scan_table_2 = ScanTable("Ev8ECgpbDF0OLBAAAAEAAgADAA==")
    _scan_table_3 = ScanTable("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")

  METHODS
    method init( file:File )
      init( file.filepath, ::Scanner(file) )
      line   = 1
      column = 1

    method init( filepath:String, content:String, line=1, column=1 )
      init( filepath, ::Scanner(content).[line=line, column=column] )

    method init( _filepath, _scanner )
      noAction

    method execute( ip:Int32 )
      _clear_state
      _execute( ip )

    method tokenize( ip=null:Int32? )->Token[]
      if (ip) start_ip = ip.value
      _clear_state
      while (_execute(start_ip) or not halt)
        buffer.clear
      endWhile
      _on_output_line # flush any buffered output
      return tokens

    method _add( type:TokenType )
      if (type.attributes & TokenType.ATTRIBUTE_CONTENT)
        tokens.add( _t(type,buffer) )
      else
        tokens.add( _t(type) )
      endIf
      buffer.clear

    method _clear_state
      tokens = Token[]
      buffer.clear
      output.clear
      halt = false

    method _describe_character( c:Character )->String
      if (c == 10 or c == 13)       return "end of line";
      elseIf (c >= 32 and c != 127) return "'$'" (c)
      else                          return "'$'" (c.to_escaped_ascii)

    method _is_next( text:String )->Logical
      local location = _scanner.location
      local result = _scanner.consume( text )
      _scanner.location = location
      return result

    method _must_consume( ch:Character )
      if (_scanner.consume(ch)) return
      local message = "Syntax error - expected $, found " (_describe_character(ch))
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _must_consume( st:String )
      if (_scanner.consume(st)) return
      _throw_expected_string_error( "'$'" (st.to_escaped_ascii("'")) )

    method _must_consume( pattern:ScanPattern )
      if (pattern.scan(_scanner)) return
      _throw_expected_string_error( pattern->String )

    method _next_is( text:String )->Logical
      if (not _scanner.has_another(text.count)) return false
      local pos = _scanner.position
      forEach (ch at index in text)
        if (ch != _scanner.data[pos+index]) return false
      endForEach
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output ).flush
      output.clear

    method _restore_position
      if (_position_stack.is_empty)
        _throw_syntax_error( "restorePosition without prior savePosition." )
      endIf
      _scanner.position = _position_stack.remove_last
      _scanner.line     = _line_stack.remove_last
      _scanner.column   = _column_stack.remove_last

    method _save_position
      _position_stack.add( _scanner.position )
      _line_stack.add( _scanner.line )
      _column_stack.add( _scanner.column )

    method _scan( ch:Character )->Logical
      if (not _scanner.consume(ch)) return false
      buffer.print ch
      return true

    method _scan( text:String )->Logical
      if (not _scanner.consume(text)) return false
      buffer.print text
      return true

    method _t( type:TokenType, content=null:String )->Token
      return Token( type, _filepath, _scanner.source, line, column, content )

    method _throw_expected_string_error( st:String )
      local message = "Syntax error - expected $, found " (st)
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _throw_syntax_error( message=null:String )
      if (not message)
        local builder = StringBuilder()
        builder.print "Syntax error - unexpected "
        if (not _scanner.has_another)
          builder.println "end of input."
        else
          builder.print( _describe_character(_scanner.peek) ).print( '.' )
        endIf
        message = builder->String
      endIf
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _execute( ip:Int32 )->Logical
      loop
        ++ip
        which (ip-1)
          case ip_scan_standard_token
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            line   = _scanner.line
            column = _scanner.column
            if (_scanner.consume('\n'))
              _add( TokenType.EOL )
              return false
            endIf
            if (not _execute(ip_scan_identifier)) return false
            if (not _execute(ip_scan_single_quoted_string)) return false
            if (not _execute(ip_scan_double_quoted_string)) return false
            if ((not scanning_node_logic))
              if (not _execute(ip_scan_charset)) return false
            endIf
            _scan_table_0.reset
            contingent
              block n=1
                while (_scanner.has_another(n))
                  if (not _scan_table_0.accept(_scanner.peek(n-1)))
                    escapeWhile
                  endIf
                  ++n
                endWhile
                necessary (_scan_table_0.has_product)
                loop (_scan_table_0.match_count) _scanner.read
              endBlock
              which (_scan_table_0.product)
                case 1
                  _add( TokenType.SYMBOL_ARROW )
                  return false
                case 2
                  _add( TokenType.SYMBOL_ASSIGN )
                  return false
                case 3
                  _add( TokenType.SYMBOL_AT )
                  return false
                case 4
                  _add( TokenType.SYMBOL_CARET )
                  return false
                case 5
                  _add( TokenType.SYMBOL_CLOSE_CURLY )
                  return false
                case 6
                  _add( TokenType.SYMBOL_CLOSE_PAREN )
                  return false
                case 7
                  _add( TokenType.SYMBOL_CLOSE_SQUARE )
                  return false
                case 8
                  _add( TokenType.SYMBOL_COLON )
                  return false
                case 9
                  _add( TokenType.SYMBOL_COMMA )
                  return false
                case 10
                  _add( TokenType.SYMBOL_DOT_DOT )
                  return false
                case 11
                  _add( TokenType.SYMBOL_EMPTY_BRACKETS )
                  return false
                case 12
                  _add( TokenType.SYMBOL_EQ )
                  return false
                case 13
                  _add( TokenType.SYMBOL_GE )
                  return false
                case 14
                  _add( TokenType.SYMBOL_GT )
                  return false
                case 15
                  _add( TokenType.SYMBOL_LE )
                  return false
                case 16
                  _add( TokenType.SYMBOL_LT )
                  return false
                case 17
                  _add( TokenType.SYMBOL_NE )
                  return false
                case 18
                  _add( TokenType.SYMBOL_MINUS )
                  return false
                case 19
                  _add( TokenType.SYMBOL_MINUS_MINUS )
                  return false
                case 20
                  _add( TokenType.SYMBOL_OPEN_CURLY )
                  return false
                case 21
                  _add( TokenType.SYMBOL_OPEN_PAREN )
                  return false
                case 22
                  _add( TokenType.SYMBOL_OPEN_SQUARE )
                  return false
                case 23
                  _add( TokenType.SYMBOL_PLUS )
                  return false
                case 24
                  _add( TokenType.SYMBOL_PLUS_PLUS )
                  return false
                case 25
                  _add( TokenType.SYMBOL_QUESTION )
                  return false
                case 26
                  _add( TokenType.SYMBOL_SEMICOLON )
                  return false
                case 27
                  _add( TokenType.SYMBOL_SINGLE_QUOTE )
                  return false
                case 28
                  _add( TokenType.SYMBOL_SLASH )
                  return false
                case 29
                  _add( TokenType.SYMBOL_STAR )
                  return false
                others
                  necessary (false)
              endWhich
            unsatisfied
              ch = _scanner.peek 
              if (_scan_pattern_0.is_next(_scanner))
                if (not _execute(ip_scan_integer)) return false
                _add( TokenType.INTEGER )
                return false
              endIf
            endContingent
            _throw_syntax_error
            return true
          case ip_scan_charset
            if ((not _scanner.consume('[')))
              return true
            endIf
            if (_scanner.consume(']'))
              _add( TokenType.SYMBOL_EMPTY_BRACKETS )
              return false
            endIf
            buffer.print('[')
            while ((_scanner.has_another and (not _scanner.next_is(']'))))
              ch = _scanner.read
              if ((ch=='\\'))
                ch = _scanner.read
                if ((ch=='n'))
                  ch = '\n'
                elseIf ((ch=='r'))
                  ch = '\r'
                elseIf ((ch=='t'))
                  ch = '\t'
                else
                  buffer.print('\\')
                endIf
              endIf
              buffer.print(ch)
            endWhile
            _must_consume( ']' )
            buffer.print(']')
            _add( TokenType.CHARSET )
            return false
          case ip_consume_whitespace
            while ((_scanner.consume(' ') or _scanner.consume('\t')))
            endWhile
            return true
          case ip_consume_comment
            if (_scanner.consume('#'))
              if (_scanner.consume('{'))
                count = 1
                while (_scanner.has_another)
                  ch = _scanner.read
                  if ((ch=='\n'))
                    _add( TokenType.EOL )
                  elseIf ((ch=='#'))
                    if (_scanner.consume('{'))
                      ++count
                    endIf
                  elseIf ((ch=='}'))
                    if (_scanner.consume('#'))
                      --count
                      if ((count==0))
                        return false
                      endIf
                    endIf
                  endIf
                endWhile
                halt = true
                return false
              else
                while (_scanner.has_another)
                  ch = _scanner.read
                  if ((ch=='\n'))
                    _add( TokenType.EOL )
                    return false
                  endIf
                endWhile
                return false
              endIf
            elseIf ((_scanner.consume("----") or _scanner.consume("====")))
              while (_scanner.has_another)
                ch = _scanner.read
                if ((ch=='\n'))
                  _add( TokenType.EOL )
                  return false
                endIf
              endWhile
              return false
            else
              return true
            endIf
            return true
          case ip_scan_optional_plain_id
            if ((not _scan_pattern_1.scan(_scanner,buffer)))
              return true
            endIf
            _add( TokenType.IDENTIFIER )
            return false
          case ip_scan_tokens_id
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            line   = _scanner.line
            column = _scanner.column
            start_ip = ip_scan_token_name
            if (_scanner.consume('\n'))
              _add( TokenType.EOL )
              return false
            endIf
            if (not _execute(ip_scan_optional_plain_id)) return false
            _throw_syntax_error("Identifier expected.")
            return true
          case ip_scan_token_name
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            line   = _scanner.line
            column = _scanner.column
            start_ip = ip_scan_token_symbol
            if (_scan_pattern_1.scan(_scanner,buffer))
              _scan_table_1.reset
              contingent
                necessary (_scan_table_1.accept(forEach in buffer))
                which (_scan_table_1.product)
                  case 1
                    scanning_node_logic = false
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_NATIVE_TYPES )
                    return false
                  case 2
                    scanning_node_logic = true
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_NODE_LOGIC )
                    return false
                  case 3
                    scanning_node_logic = false
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_PARSER )
                    return false
                  case 4
                    scanning_node_logic = false
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_SCANNER )
                    return false
                  case 5
                    scanning_node_logic = false
                    start_ip = ip_scan_tokens_id
                    _add( TokenType.KEYWORD_TOKENS )
                    return false
                  others
                    necessary (false)
                endWhich
              unsatisfied
                _add( TokenType.IDENTIFIER )
                return false
              endContingent
            endIf
            start_ip = ip_scan_token_name
            if (_scanner.consume('\n'))
              _add( TokenType.EOL )
              return false
            endIf
            _throw_syntax_error("Identifier expected.")
            return true
          case ip_scan_token_symbol
            if (_scanner.consume('('))
              while (((_scanner.has_another and (not _scanner.next_is(')'))) and (not _scanner.next_is('\n'))))
                ch = _scanner.read
                buffer.print(ch)
              endWhile
              _must_consume( ')' )
            else
              if (not _execute(ip_consume_whitespace)) return false
              if (_scanner.next_is('\n'))
                start_ip = ip_scan_token_attributes
                return false
              endIf
              while (((_scanner.has_another and (not _scanner.next_is(' '))) and (not _scanner.next_is('\n'))))
                ch = _scanner.read
                buffer.print(ch)
              endWhile
            endIf
            start_ip = ip_scan_token_attributes
            _add( TokenType.SYMBOL )
            return false
          case ip_scan_token_attributes
            if (not _execute(ip_consume_whitespace)) return false
            if (not _execute(ip_consume_comment)) return false
            if ((not _scanner.has_another))
              halt = true
              return false
            endIf
            _scan_table_2.reset
            contingent
              block n=1
                while (_scanner.has_another(n))
                  if (not _scan_table_2.accept(_scanner.peek(n-1)))
                    escapeWhile
                  endIf
                  ++n
                endWhile
                necessary (_scan_table_2.has_product)
                loop (_scan_table_2.match_count) _scanner.read
              endBlock
              which (_scan_table_2.product)
                case 0
                  start_ip = ip_scan_token_name
                  _add( TokenType.EOL )
                  return false
                case 1
                  _add( TokenType.SYMBOL_OPEN_SQUARE )
                  return false
                case 2
                  _add( TokenType.SYMBOL_CLOSE_SQUARE )
                  return false
                case 3
                  _add( TokenType.SYMBOL_COMMA )
                  return false
                others
                  necessary (false)
              endWhich
            endContingent
            if (not _execute(ip_must_scan_attribute_identifier)) return false
            return true
          case ip_scan_identifier
            ch = _scanner.peek 
            if (_scan_pattern_2.scan(_scanner,buffer))
              _scan_table_3.reset
              contingent
                necessary (_scan_table_3.accept(forEach in buffer))
                which (_scan_table_3.product)
                  case 1
                    scanning_node_logic = false
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_NATIVE_TYPES )
                    return false
                  case 2
                    scanning_node_logic = true
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_NODE_LOGIC )
                    return false
                  case 3
                    scanning_node_logic = false
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_PARSER )
                    return false
                  case 4
                    scanning_node_logic = false
                    start_ip = ip_scan_standard_token
                    _add( TokenType.KEYWORD_SCANNER )
                    return false
                  case 5
                    scanning_node_logic = false
                    start_ip = ip_scan_tokens_id
                    _add( TokenType.KEYWORD_TOKENS )
                    return false
                  case 6
                    _add( TokenType.KEYWORD_ELSE_OTHERS )
                    return false
                  case 7
                    _add( TokenType.KEYWORD_AND )
                    return false
                  case 8
                    _add( TokenType.KEYWORD_CALL )
                    return false
                  case 9
                    _add( TokenType.KEYWORD_CONSUME )
                    return false
                  case 10
                    _add( TokenType.KEYWORD_CONSUME_ANY )
                    return false
                  case 11
                    _add( TokenType.KEYWORD_CREATE )
                    return false
                  case 12
                    _add( TokenType.KEYWORD_DISCARD_POSITION )
                    return false
                  case 13
                    _add( TokenType.KEYWORD_ELSE )
                    return false
                  case 14
                    _add( TokenType.KEYWORD_ELSE_IF )
                    return false
                  case 15
                    _add( TokenType.KEYWORD_END_IF )
                    return false
                  case 16
                    _add( TokenType.KEYWORD_END_WHILE )
                    return false
                  case 17
                    _add( TokenType.KEYWORD_FALSE )
                    return false
                  case 18
                    _add( TokenType.KEYWORD_HALT )
                    return false
                  case 19
                    _add( TokenType.KEYWORD_HAS_NEXT )
                    return false
                  case 20
                    _add( TokenType.KEYWORD_IF )
                    return false
                  case 21
                    _add( TokenType.KEYWORD_MARK_POSITION )
                    return false
                  case 22
                    _add( TokenType.KEYWORD_MODE )
                    return false
                  case 23
                    _add( TokenType.KEYWORD_MUST_CONSUME )
                    return false
                  case 24
                    _add( TokenType.KEYWORD_NEXT_IS )
                    return false
                  case 25
                    _add( TokenType.KEYWORD_NO_ACTION )
                    return false
                  case 26
                    _add( TokenType.KEYWORD_NOT )
                    return false
                  case 27
                    _add( TokenType.KEYWORD_OR )
                    return false
                  case 28
                    _add( TokenType.KEYWORD_OTHERS )
                    return false
                  case 29
                    _add( TokenType.KEYWORD_PRINT )
                    return false
                  case 30
                    _add( TokenType.KEYWORD_PRINTLN )
                    return false
                  case 31
                    _add( TokenType.KEYWORD_PRODUCE )
                    return false
                  case 32
                    _add( TokenType.KEYWORD_READ )
                    return false
                  case 33
                    _add( TokenType.KEYWORD_RESTORE_POSITION )
                    return false
                  case 34
                    _add( TokenType.KEYWORD_RETURN )
                    return false
                  case 35
                    _add( TokenType.KEYWORD_SAVE_POSITION )
                    return false
                  case 36
                    _add( TokenType.KEYWORD_SCAN )
                    return false
                  case 37
                    _add( TokenType.KEYWORD_SYNTAX_ERROR )
                    return false
                  case 38
                    _add( TokenType.KEYWORD_TRUE )
                    return false
                  case 39
                    _add( TokenType.KEYWORD_WHILE )
                    return false
                  case 40
                    _add( TokenType.KEYWORD_BEGIN_LIST )
                    return false
                  case 41
                    _add( TokenType.KEYWORD_CREATE_LIST )
                    return false
                  case 42
                    _add( TokenType.KEYWORD_CREATE_NULL )
                    return false
                  case 43
                    _add( TokenType.KEYWORD_DISCARD_LIST )
                    return false
                  case 44
                    _add( TokenType.KEYWORD_ELSE_ON )
                    return false
                  case 45
                    _add( TokenType.KEYWORD_ELSE_ON_PEEK )
                    return false
                  case 46
                    _add( TokenType.KEYWORD_ELSE_OTHERS )
                    return false
                  case 47
                    _add( TokenType.KEYWORD_END_ON )
                    return false
                  case 48
                    _add( TokenType.KEYWORD_NEXT_HAS_ATTRIBUTE )
                    return false
                  case 49
                    _add( TokenType.KEYWORD_ON )
                    return false
                  case 50
                    _add( TokenType.KEYWORD_ON_PEEK )
                    return false
                  case 51
                    _add( TokenType.KEYWORD_PRODUCE_LIST )
                    return false
                  case 52
                    _add( TokenType.KEYWORD_PRODUCE_NULL )
                    return false
                  case 53
                    _add( TokenType.KEYWORD_BUFFER )
                    return false
                  case 54
                    _add( TokenType.KEYWORD_CASE )
                    return false
                  case 55
                    _add( TokenType.KEYWORD_CHARACTER )
                    return false
                  case 56
                    _add( TokenType.KEYWORD_COLLECT )
                    return false
                  case 57
                    _add( TokenType.KEYWORD_END_MATCH )
                    return false
                  case 58
                    _add( TokenType.KEYWORD_INPUT )
                    return false
                  case 59
                    _add( TokenType.KEYWORD_INTEGER )
                    return false
                  case 60
                    _add( TokenType.KEYWORD_OUTPUT )
                    return false
                  case 61
                    _add( TokenType.KEYWORD_PEEK )
                    return false
                  case 62
                    _add( TokenType.KEYWORD_PRODUCE_ANY )
                    return false
                  case 63
                    _add( TokenType.KEYWORD_MATCH )
                    return false
                  case 64
                    _add( TokenType.KEYWORD_RESTART )
                    return false
                  others
                    necessary (false)
                endWhich
              unsatisfied
                _add( TokenType.IDENTIFIER )
                return false
              endContingent
            endIf
            return true
          case ip_must_scan_attribute_identifier
            if (_scan_pattern_2.scan(_scanner,buffer))
              _add( TokenType.IDENTIFIER )
              return false
            endIf
            _throw_syntax_error("Identifier expected.")
            return true
          case ip_scan_integer
            while (_scan_pattern_3.is_next(_scanner))
              ch = _scanner.read
              if ((ch!='_'))
                buffer.print(ch)
              endIf
              if ((not _scanner.has_another))
                return true
              endIf
              ch = _scanner.peek 
            endWhile
            return true
          case ip_scan_single_quoted_string
            if ((not _scanner.consume('\'')))
              return true
            endIf
            while (_scanner.has_another)
              if (_scanner.consume('\''))
                _add( TokenType.STRING_OR_CHARACTER )
                return false
              endIf
              if (_scanner.next_is('\n'))
                _throw_syntax_error("Unterminated string.")
              endIf
              if (not _execute(ip_scan_literal_character)) return false
            endWhile
            _throw_syntax_error("Unterminated string.")
            return true
          case ip_scan_double_quoted_string
            if ((not _scanner.consume('"')))
              return true
            endIf
            while (_scanner.has_another)
              if (_scanner.consume('"'))
                _add( TokenType.STRING )
                return false
              endIf
              if (_scanner.next_is('\n'))
                _throw_syntax_error("Unterminated string.")
              endIf
              if (not _execute(ip_scan_literal_character)) return false
            endWhile
            _throw_syntax_error("Unterminated string.")
            return true
          case ip_scan_literal_character
            ch = _scanner.read
            if ((ch=='\\'))
              ch = _scanner.read
              if ((ch=='n'))
                ch = '\n'
              endIf
              if ((ch=='r'))
                ch = '\r'
              endIf
              if ((ch=='t'))
                ch = '\t'
              endIf
            endIf
            buffer.print(ch)
            return true
          others
            halt = true
            return false
        endWhich
      endLoop

endClass
