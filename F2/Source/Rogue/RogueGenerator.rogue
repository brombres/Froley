module F2

$include "CompileErrorTemplate.rogue"
$include "MainTemplate.rogue"
$include "ScannerTemplate.rogue"
$include "ScanTableTemplate.rogue"
$include "ScanTableDeclarationWriter.rogue"
$include "TokenTemplate.rogue"

class RogueGenerator : FroleyVisitor
  PROPERTIES
    folder     : String
    writer     : PrintWriter
    class_name = ""

    indent     = 0
    at_newline = true
    write_replacements = StringTable<<String>>()

  METHODS
    method init( program, folder )
      File.create_folder( folder )

      program.nodes.dispatch( this )
      #generate_scanner( forEach in scanners )
      #generate_parser( forEach in parsers )
      #nodes.dispatch( Organizer(this) )

      create_file( "CompileError", template_CompileError )
      create_file( "Token", template_Token )
      create_file( "ScanTable", template_ScanTable )

      # TokenType
      create_file( "TokenType" )
      writeln @|# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
               |$module
               |enum TokenType( symbol:String, attributes=0:Int32 )
               |  ENUMERATE
               |    # TODO: attributes
               |  CATEGORIES
      forEach (def in program.tokens_by_name)
        write  ''    $("$"'' (def.name,to_escaped_ascii(def.symbol,''"''))
        writeln ")"
      endForEach
      writeln @|endEnum
      writer.close

      # Main
      if (program.main_filename)
        create_file( program.main_filename, template_Main )
      endIf

    method create_file( class_name, template=null:String, filename=null:String )
      if (not filename) filename = class_name + ".rogue"
      local filepath = folder/filename

      if (File.exists(filepath)) print "Recreating "
      else                       print "Creating "
      println filepath

      writer = File.print_writer(filepath)
      if (template)
        write( template )
        writer.close
      endIf

    method visit( cmd:Call )->Cmd  [override]
      write "if (not execute(ip_"
      write cmd.routine_def.name
      write ")) return false"
      return cmd

    method visit( cmd:CastToLogical )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Logical"
      return cmd

    method visit( cmd:CastToCharacter )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Character"
      return cmd

    method visit( cmd:CastToInteger )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->Int32"
      return cmd

    method visit( cmd:CastToString )->Cmd  [override]
      cmd.operand.dispatch( this )
      write "->String"
      return cmd

    method visit( cmd:Collect )->Cmd  [override]
      write "buffer"
      forEach (arg in cmd.args)
        write ".print("
        arg.dispatch( this )
        write ")"
      endForEach
      return cmd

    method visit( cmd:CompareEQ )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "=="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareNE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "!="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:ConsumeAny )->Cmd  [override]
      write "scanner.consume_any("
      dispatch( cmd.alternatives )
      write ")"
      return cmd

    method visit( cmd:ConsumeValue )->Cmd  [override]
      write "scanner.consume("
      dispatch( cmd.value )
      write ")"
      return cmd

    method visit( cmd:Decrement )->Cmd  [override]
      write "--"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:If )->Cmd  [override]
      write   "if ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2

      dispatch( cmd.else_ifs )

      if (cmd._else)
        writeln "else"
        indent += 2
        dispatch( cmd._else )
        indent -= 2
      endIf

      write   "endIf"
      return cmd

    method visit( cmd:ElseIf )->Cmd  [override]
      write   "elseIf ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      return cmd

    method visit( cmd:Halt )->Cmd  [override]
      writeln "halt = true"
      write   "return false"
      return cmd

    method visit( cmd:Increment )->Cmd  [override]
      write "++"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:HasAnother )->Cmd  [override]
      write "scanner.has_another"
      return cmd

    method visit( cmd:LiteralCharacter )->Cmd  [override]
      which (cmd.value)
        case '\n': write @|'\n'
        case '\r': write @|'\r'
        case '\t': write @|'\t'
        others
          write( "'$'"(to_escaped_ascii(cmd.value,"'")) )
      endWhich
      return cmd

    method visit( cmd:LiteralInteger )->Cmd  [override]
      writer.print( cmd.value )
      return cmd

    method visit( cmd:LiteralLogical )->Cmd  [override]
      writer.print( cmd.value )
      return cmd

    method visit( cmd:LiteralString )->Cmd  [override]
      if (cmd.value.count == 1)
        writer.print( "'$'"(to_escaped_ascii(cmd.value,"'")) )
      else
        writer.print( ''"$"''(to_escaped_ascii(cmd.value,''"'')) )
      endIf
      return cmd

    method visit( cmd:LiteralTokenType )->Cmd  [override]
      write "TokenType."
      write cmd.token_type.name
      return cmd

    method visit( cmd:LogicalAnd )->Cmd  [override]
      write "("
      cmd.left.dispatch( this )
      write " and "
      cmd.right.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:LogicalNot )->Cmd  [override]
      write "(not "
      cmd.operand.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:LogicalOr )->Cmd  [override]
      write "("
      cmd.left.dispatch( this )
      write " or "
      cmd.right.dispatch( this )
      write ")"
      return cmd

    method visit( cmd:Print )->Cmd  [override]
      write "output"
      forEach (arg in cmd.args)
        write ".print("
        arg.require_value.dispatch( this )
        write ")"
      endForEach
      return cmd

    method visit( cmd:Println )->Cmd  [override]
      write "output"
      forEach (arg in cmd.args)
        write ".print("
        arg.require_value.dispatch( this )
        write ")"
      endForEach
      write ".println"
      return cmd

    method visit( cmd:ScannerProduce )->Cmd  [override]
      write   "add( "
      cmd.token_type.dispatch( this )
      writeln " )"
      write   "return false"
      return cmd

    method visit( cmd:Read )->Cmd  [override]
      write "scanner.read"
      return cmd

    method visit( cmd:ReadBuffer )->Cmd  [override]
      write "buffer"
      return cmd

    method visit( cmd:ReadVar )->Cmd  [override]
      write cmd.var.name
      return cmd

    method visit( cmd:Return )->Cmd  [override]
      # TODO: save return value first, if needed
      write   "return true"
      return cmd

    method visit( cmd:RoutineDef )->Cmd  [override]
      writeln "          case ip_$"(cmd.name)

      indent += 12
      prior.visit( cmd )
      indent -= 12

      return cmd

    method visit( cmd:ScannerDef )->Cmd  [override]
      # OutputFolder/XYZScanner.rogue
      create_file( cmd.name, template_Scanner )

      # OutputFolder/XYZScannerCore.rogue
      create_file( cmd.name+"Core" )
      writeln @|# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
               |$module
               |class $ClassName
               |  DEFINITIONS
      forEach (r in cmd.routines)
        writeln "    ip_$ = $" (r.name,r.ip)
      endForEach

      writeln @|
               |  PROPERTIES
               |    filepath    : String
               |    scanner     : ::Scanner
               |    _src_line   = 1
               |    _src_column = 1
               |
               |    tokens      = Token[]
               |    buffer      = StringBuilder()
               |    output      = StringBuilder()
               |
               |    start_ip    = 0
               |    ip          : Int32
               |    halt        = false
               |
               |    # GENERATED PROPERTIES

      indent += 4
      if (cmd.vars.count)
        local max_w = 0
        max_w .= or_larger( (forEach in cmd.vars).name.count )

        forEach (v in cmd.vars)
          write "$ : "(v.name.left_justified(max_w))
          which (v.type)
            case Type.LOGICAL
              writeln "Logical"
            case Type.CHARACTER
              writeln "Character"
            case Type.INTEGER
              writeln "Int32"
            case Type.STRING
              writeln "String"
            others
              throw v.t.error( "[INTERNAL] Unhandled type '$'."(v.type) )
          endWhich
        endForEach
      endIf

      cmd.dispatch( ScanTableDeclarationWriter(program,this) )
      indent -= 4

      writeln @|
               |  METHODS
               |    method init( file:File )
               |      init( file.filepath, ::Scanner(file) )
               |
               |    method init( filepath:String, content:String )
               |      init( filepath, ::Scanner(content) )
               |
               |    method init( filepath, scanner )
               |      noAction
               |
               |    method add( type:TokenType )
               |      tokens.add( t(type) )
               |
               |    method clear
               |      tokens = Token[]
               |      buffer.clear
               |      output.clear
               |      _src_line = 1
               |      _src_column = 1
               |      halt = false
               |
               |    method describe_character( c:Character )->String
               |      if (c == 10 or c == 13)       return "end of line";
               |      elseIf (c >= 32 and c != 127) return "'$'" (c)
               |      else                          return "'$'" (c.to_escaped_ascii)
               |
               |    method execute->Logical
               |      return execute( start_ip )
               |
               |    method t( type:TokenType, content=null:String )->Token
               |      return Token( type, filepath, scanner.source, _src_line, _src_column, content )
               |
               |    method throw_expected_character_error( ch:Character )
               |      local message = "Syntax error - expected $, found " (describe_character(ch))
               |      if (scanner.has_another) message += describe_character(scanner.peek) + "."
               |      else                     message += "end of input."
               |      throw CompileError( filepath, scanner.source, scanner.line, scanner.column, message )
               |
               |    method throw_syntax_error( message=null:String )
               |      if (not message)
               |        local builder = StringBuilder()
               |        builder.print "Syntax error - unexpected "
               |        if (not scanner.has_another)
               |          builder.println "end of input."
               |        else
               |          builder.print( describe_character(scanner.peek) ).print( '.' )
               |        endIf
               |        message = builder->String
               |      endIf
               |      throw CompileError( filepath, scanner.source, scanner.line, scanner.column, message )
               |
               |    method tokenize( ip=null:Int32? )->Token[]
               |      if (ip) start_ip = ip.value
               |      clear
               |      while (execute(start_ip) or not halt)
               |        buffer.clear
               |      endWhile
               |      return tokens
               |
               |    method execute( ip:Int32 )->Logical
               |      loop
               |        ++ip
               |        which (ip-1)

      prior.visit( cmd )

      writeln @|          others
               |            halt = true
               |            return false
               |        endWhich
               |      endLoop
               |
               |endClass
      writer.close

      return cmd

    method visit( cmd:Statements )->Cmd  [override]
      forEach (element in cmd)
        if (element)
          element.dispatch( this )
          writeln
        endIf
      endForEach
      return cmd

    method visit( cmd:Scan )->Cmd  [override]
      write_replacements["$scan_table"] = cmd.id

      writeln @|$scan_table.reset
               |contingent
      if (cmd.expression)
        # Read from string; must accept all characters.
        write @|  necessary ($scan_table.accept(forEach in
        write " "
        cmd.expression.dispatch(this)
        writeln @|))
      else
        # Read longest match from input
        indent += 2
        writeln @|block n=1
                 |  while (scanner.has_another(n))
                 |    if (not $scan_table.accept(scanner.peek(n-1)))
                 |      escapeWhile
                 |    endIf
                 |    ++n
                 |  endWhile
                 |  necessary ($scan_table.has_product)
                 |  loop ($scan_table.match_count) scanner.read
                 |endBlock
        indent -= 2
      endIf

      writeln @|  which ($scan_table.product)
      indent += 4
      forEach (statements at i in cmd.statement_lists)
        writeln "case "+i
        indent += 2
        statements.dispatch(this)
        indent -= 2
      endForEach
      indent -= 4
      write @|  endWhich
             |endContingent

      write_replacements.remove( "$scan_table" )
      return cmd

    method visit( cmd:ScanError )->Cmd  [override]
      write "throw_syntax_error"
      if (cmd.args and cmd.args.count)
        write "("
        forEach (arg at i in cmd.args)
          if (i > 0) write "+"
          cmd.args.dispatch( this )
        endForEach
        write ")"
      endIf
      return cmd

    method visit( cmd:WriteBuffer )->Cmd  [override]
      write "buffer.clear.print "
      dispatch( cmd.new_value )
      return cmd

    method visit( cmd:WriteVar )->Cmd  [override]
      write "$ = " (cmd.var.name)
      dispatch( cmd.new_value )
      return cmd

    method visit( cmd:While )->Cmd  [override]
      write   "while ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      write   "endWhile"
      return cmd

    method write( content:String )
      if (content.contains('\n'))
        forEach (line at i in content.split('\n'))
          if (i > 0) writeln
          write( line )
        endForEach
        return
      endIf

      if (at_newline and indent)
        loop (indent) writer.print(' ')
      endIf

      if (content.contains('$'))
        content .= replacing( "$ClassName",  class_name )
        if (String.exists(program.project_name))
          content .= replacing( "$module", "module $\n"(program.project_name) )
        else
          content .= replacing( "$module", "" )
        endIf
        content .= replacing( "$ProjectName", program.project_name )
        content .= replacing( "$projectname", program.project_name.to_lowercase )
        forEach (entry in write_replacements.entries)
          content .= replacing( entry.key, entry.value )
        endForEach
      endIf
      writer.print( content )

      at_newline = false

    method writeln( content="":String )
      if (String.exists(content)) write( content )
      writer.println
      at_newline = true

  GLOBAL METHODS
    method to_escaped_ascii( st:String, additional_escapes:String )->String
      return st.to_escaped_ascii( additional_escapes )

endClass
