module F2

class Cmd( t:Token )
  METHODS
    method dispatch( visitor:Visitor )->Cmd [propagated]
      return visitor.visit( this )

    method is_value->Logical
      return false

    method require_value->Cmd
      if (not is_value) throw t.error( "Value expected." )
      return this

    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      throw t.error( "Illegal assignment." )

    method to->Int32
      return this->String->Int32

    method to->Logical
      return this->Int32 != 0

    method to->Real64
      return this->Int32

    method to->CmdList
      return CmdList(t).[ add(this) ]
endClass

class CmdList : Cmd
  PROPERTIES
    list : Cmd[]

  METHODS
    method init( t )
      list = Cmd[](5)

    method init( t, args:CmdInitArgs )
      list = Cmd[]( args.count )
      list.add( forEach in args )

    method add( cmd:Cmd )
      list.add( cmd )

    method count->Int32
      return list.count

    method first->Cmd
      return list.first

    method get( index:Int32 )->Cmd
      return list[ index ]

    method last->Cmd
      return list.last

    method set( index:Int32, value:Cmd )->this
      list[ index ] = value
      return this

    method to->CmdList
      return this

    method to->String
      return list->String
endClass

class Literal : Cmd
  METHODS
    method is_value->Logical
      return true
endClass

class LiteralInt32( t, value:Int32 ) : Literal
  METHODS
    method init( t, string_value:String )
      value = string_value->Int32

    method to->Int32
      return value

    method to->Real64
      return value

    method to->String
      return value->String
endClass

class LiteralLogical( t, value:Logical ) : Literal
  METHODS
    method to->Int32
      return which{ value:1 || 0 }

    method to->Logical
      return value

    method to->Real64
      return which{ value:1 || 0 }

    method to->String
      return which{ value:"true" || "false" }
endClass

class LiteralReal64( t, value:Real64 ) : Literal
  METHODS
    method to->Int32
      return this->Real64.floor->Int32

    method to->Logical
      return value != 0

    method to->Real64
      return value

    method to->String
      return value->String
endClass

class LiteralString( t, value:String ) : Literal
  METHODS
    method to->String
      return value
endClass

class LiteralCharacter( t, value:Character ) : Literal
  METHODS
    method to->String
      return value
endClass

class Unary( t, operand:Cmd ) : Cmd
  METHODS
    method op->String
      throw UnsupportedOperationError()

    method to->String
      local op = this.op
      local space = which{ op.count and op[op.count-1].is_letter:" " || "" }
      return "($$$)" (op,space,operand)
endClass

class PostUnary : Unary
  METHODS
    method to->String
      local op = this.op
      local space = which{ op.count and op[0].is_letter:" " || "" }
      return "($$$)" (operand,space,op)
endClass

class Binary( t, left:Cmd, right:Cmd ) : Cmd
  METHODS
    method op->String
      throw UnsupportedOperationError()

    method to->String
      return "($ $ $)" (left,op,right)
endClass


class Identifier( t, name:String ) : Cmd
  METHODS
    method to->String
      return "$"(name)
endClass

class ElementDef : Cmd
  PROPERTIES
    routines = StringTable<<RoutineDef>>()
    vars     = Set<<String>>()
endClass

class ParserDef( t, name:String, code:Cmd ) : ElementDef
  METHODS
    method to->String
      return "ParserDef($)"(name)
endClass

class ScannerDef( t, name:String, code:Cmd ) : ElementDef
  METHODS
    method to->String
      return "ScannerDef($,$)"(name,code)
endClass


class RoutineDef( t, name:String, base_type:String, statements:Cmd ) : Cmd
  PROPERTIES
    ip : Int32

  METHODS
    method to->String
      return "RoutineDef($,$,$)"(name,base_type,statements)
endClass

class SubroutineDef : RoutineDef
  METHODS
    method to->String
      return "SubroutineDef($,$,$)"(name,base_type,statements)
endClass


class Add : Binary
  METHODS
    method op->String
      return "+"
endClass

class Subtract : Binary
  METHODS
    method op->String
      return "-"
endClass

class Multiply : Binary
  METHODS
    method op->String
      return "*"
endClass

class Divide : Binary
  METHODS
    method op->String
      return "/"
endClass

class Power : Binary
  METHODS
    method op->String
      return "^"
endClass

class Negate : Unary
  METHODS
    method op->String
      return "-"
endClass

class Access( t, name:String ) : Cmd
  METHODS
    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      local r = resolver.cur_element.routines[name]
      if (r) throw t.error( "Illegal assignment to a routine." )
      resolver.cur_element.vars.add( name )
      return WriteVar( cmd.t, name, cmd.new_value )

    method to->String
      return "$"(name)
endClass


class Assign( t, target:Cmd, new_value:Cmd ) : Cmd
  METHODS
    method to->String
      return "Assign($,$)"(target,new_value)
endClass


class Statements : CmdList
  METHODS
endClass

class While( t, condition:Cmd, statements:Cmd ) : Cmd
  METHODS
    method to->String
      return "While($,$)"(condition,statements)
endClass


class If( t, condition:Cmd, statements:Cmd, else_ifs:CmdList, _else:Statements ) : Cmd
  METHODS
    method to->String
      return "If($,$,$,$)"(condition,statements,else_ifs,_else)
endClass

class ElseIf( t, condition:Cmd, statements:Statements ) : Cmd
  METHODS
    method to->String
      return "ElseIf($,$)"(condition,statements)
endClass

class LogicalOr : Binary
  METHODS
    method op->String
      return "or"
endClass

class LogicalAnd : Binary
  METHODS
    method op->String
      return "and"
endClass

class CompareEQ : Binary
  METHODS
    method op->String
      return "=="
endClass

class CompareNE : Binary
  METHODS
    method op->String
      return "!="
endClass

class CompareLT : Binary
  METHODS
    method op->String
      return "<"
endClass

class CompareGT : Binary
  METHODS
    method op->String
      return ">"
endClass

class CompareLE : Binary
  METHODS
    method op->String
      return "<="
endClass

class CompareGE : Binary
  METHODS
    method op->String
      return ">="
endClass


class Increment( t, target:Cmd ) : Cmd
  METHODS
    method to->String
      return "Increment($)"(target)
endClass

class Decrement( t, target:Cmd ) : Cmd
  METHODS
    method to->String
      return "Decrement($)"(target)
endClass

class Print( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Print($)"(args)
endClass

class Println( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Println($)"(args)
endClass


class HasNext : Cmd
  METHODS
    method to->String
      return "hasNext"
endClass


class Read : Cmd
  METHODS
    method to->String
      return "read"
endClass


class Collect( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Collect($)"(args)
endClass

class WriteVar( t, name:String, new_value:Cmd ) : Cmd
  METHODS
    method to->String
      return "WriteVar($,$)"(name,new_value)
endClass

class ReadVar( t, name:String ) : Cmd
  METHODS
    method is_value->Logical
      return true

    method to->String
      return "ReadVar($)"(name)
endClass

