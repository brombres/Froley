module F2

class Cmd( t:Token )
  METHODS
    method dispatch( visitor:Visitor )->Cmd [propagated]
      return visitor.visit( this )

    method require_type->Type
      localize type
      if (not type.exists) throw t.error( "Value expected." )
      return type

    method require_value->Cmd
      require_type
      return this

    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      throw t.error( "Illegal assignment." )

    method to->Int32
      return this->String->Int32

    method to->Logical
      return this->Int32 != 0

    method to->Real64
      return this->Int32

    method to->CmdList
      return CmdList(t).[ add(this) ]

    method type->Type
      return Type.NONE
endClass

class CmdList : Cmd
  PROPERTIES
    list : Cmd[]

  METHODS
    method init( t )
      list = Cmd[](5)

    method init( t, args:CmdInitArgs )
      list = Cmd[]( args.count )
      list.add( forEach in args )

    method add( cmd:Cmd )
      list.add( cmd )

    method count->Int32
      return list.count

    method first->Cmd
      return list.first

    method get( index:Int32 )->Cmd
      return list[ index ]

    method last->Cmd
      return list.last

    method set( index:Int32, value:Cmd )->this
      list[ index ] = value
      return this

    method to->CmdList
      return this

    method to->String
      return list->String
endClass

class Literal : Cmd
  METHODS
endClass

class LiteralInt32( t, value:Int32 ) : Literal
  METHODS
    method init( t, string_value:String )
      value = string_value->Int32

    method to->Int32
      return value

    method to->Real64
      return value

    method to->String
      return value->String

    method type->Type
      return Type.INTEGER
endClass

class LiteralLogical( t, value:Logical ) : Literal
  METHODS
    method to->Int32
      return which{ value:1 || 0 }

    method to->Logical
      return value

    method to->Real64
      return which{ value:1 || 0 }

    method to->String
      return which{ value:"true" || "false" }

    method type->Type
      return Type.LOGICAL
endClass

class LiteralString( t, value:String ) : Literal
  METHODS
    method to->String
      return value

    method type->Type
      return Type.STRING
endClass

class LiteralCharacter( t, value:Character ) : Literal
  METHODS
    method to->String
      return value

    method type->Type
      return Type.CHARACTER
endClass

class Unary( t, operand:Cmd ) : Cmd
  METHODS
    method op->String
      throw UnsupportedOperationError()

    method to->String
      local op = this.op
      local space = which{ op.count and op[op.count-1].is_letter:" " || "" }
      return "($$$)" (op,space,operand)
endClass

class PostUnary : Unary
  METHODS
    method to->String
      local op = this.op
      local space = which{ op.count and op[0].is_letter:" " || "" }
      return "($$$)" (operand,space,op)
endClass

class Binary( t, left:Cmd, right:Cmd ) : Cmd
  METHODS
    method op->String
      throw UnsupportedOperationError()

    method to->String
      return "($ $ $)" (left,op,right)
endClass


class Identifier( t, name:String ) : Cmd
  METHODS
    method to->String
      return "$"(name)
endClass

class ElementDef : Cmd
  PROPERTIES
    routines = StringTable<<RoutineDef>>()
    vars     = StringTable<<Var>>()

  METHODS
    method define_var( t:Token, name:String, type=Type.NONE:Type )->Var
      local entry = vars.find( name )
      if (not entry)
        local v = Var( t, name, type )
        vars[name] = v
        return v
      endIf

      local existing = entry.value
      if (type != existing.type)
        if (not existing.type.exists)
          existing.type = type
        elseIf (type.exists)
          throw t.error( "Conflicting implicit types $ and $ for variable '$'."...
                         (existing.type,type,name) )
        endIf
      endIf

      return existing

    method var_type( name:String )->Type
      local entry = vars.find( name )
      if (not entry) return Type.NONE
      return entry.value.type
endClass

class ParserDef( t, name:String, code:Cmd ) : ElementDef
  METHODS
    method to->String
      return "ParserDef($)"(name)
endClass

class ScannerDef( t, name:String, code:Cmd ) : ElementDef
  METHODS
    method to->String
      return "ScannerDef($,$)"(name,code)
endClass


class RoutineDef( t, name:String, base_type:String, statements:Cmd ) : Cmd
  PROPERTIES
    ip : Int32

  METHODS
    method to->String
      return "RoutineDef($,$,$)"(name,base_type,statements)
endClass

class SubroutineDef : RoutineDef
  METHODS
    method to->String
      return "SubroutineDef($,$,$)"(name,base_type,statements)
endClass


class Add : Binary
  METHODS
    method op->String
      return "+"
endClass

class Subtract : Binary
  METHODS
    method op->String
      return "-"
endClass

class Multiply : Binary
  METHODS
    method op->String
      return "*"
endClass

class Divide : Binary
  METHODS
    method op->String
      return "/"
endClass

class Power : Binary
  METHODS
    method op->String
      return "^"
endClass

class Negate : Unary
  METHODS
    method op->String
      return "-"
endClass

class Access( t, name:String ) : Cmd
  METHODS
    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      local r = resolver.cur_element.routines[name]
      if (r) throw t.error( "Illegal assignment to a routine." )
      local v = resolver.cur_element.define_var( t, name, cmd.new_value.type )
      return WriteVar( v, cmd.new_value ).dispatch( resolver )

    method to->String
      return "$"(name)
endClass


class Assign( t, target:Cmd, new_value:Cmd ) : Cmd
  METHODS
    method to->String
      return "Assign($,$)"(target,new_value)
endClass


class Statements : CmdList
  METHODS
endClass

class While( t, condition:Cmd, statements:Cmd ) : Cmd
  METHODS
    method to->String
      return "While($,$)"(condition,statements)
endClass


class If( t, condition:Cmd, statements:Cmd, else_ifs:CmdList, _else:Statements ) : Cmd
  METHODS
    method to->String
      return "If($,$,$,$)"(condition,statements,else_ifs,_else)
endClass

class ElseIf( t, condition:Cmd, statements:Statements ) : Cmd
  METHODS
    method to->String
      return "ElseIf($,$)"(condition,statements)
endClass

class LogicalOr : Binary
  METHODS
    method op->String
      return "or"
endClass

class LogicalAnd : Binary
  METHODS
    method op->String
      return "and"
endClass

class CompareEQ : Binary
  METHODS
    method op->String
      return "=="
endClass

class CompareNE : Binary
  METHODS
    method op->String
      return "!="
endClass

class CompareLT : Binary
  METHODS
    method op->String
      return "<"
endClass

class CompareGT : Binary
  METHODS
    method op->String
      return ">"
endClass

class CompareLE : Binary
  METHODS
    method op->String
      return "<="
endClass

class CompareGE : Binary
  METHODS
    method op->String
      return ">="
endClass


class Increment( t, target:Cmd ) : Cmd
  METHODS
    method to->String
      return "Increment($)"(target)
endClass

class Decrement( t, target:Cmd ) : Cmd
  METHODS
    method to->String
      return "Decrement($)"(target)
endClass

class Print( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Print($)"(args)
endClass

class Println( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Println($)"(args)
endClass


class HasNext : Cmd
  METHODS
    method to->String
      return "hasNext"

    method type->Type
      return Type.LOGICAL
endClass


class Read : Cmd
  METHODS
    method to->String
      return "read"

    method type->Type
      return Type.CHARACTER
endClass

class Collect( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "Collect($)"(args)
endClass

class WriteVar : Cmd
  PROPERTIES
    var       : Var
    new_value : Cmd

  METHODS
    method init( var, new_value )
      t = var.t

    method to->String
      return "WriteVar($,$)"(var.name,new_value)
endClass

class ReadVar : Cmd
  PROPERTIES
    var : Var

  METHODS
    method init( var )
      t = var.t

    method to->String
      return "ReadVar($)"(var.name)

    method type->Type
      return var.type
endClass



class SyntaxError( t, args:CmdList ) : Cmd
  METHODS
    method to->String
      return "SyntaxError($)"(args)
endClass
