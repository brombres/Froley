module F2

class GenerateRogue : FroleyVisitor
  PROPERTIES
    folder     : String
    writer     : PrintWriter
    class_name = ""

    indent     = 0
    at_newline = true

  METHODS
    method init( program, folder )
      File.create_folder( folder )

      program.nodes.dispatch( this )
      #generate_scanner( forEach in scanners )
      #generate_parser( forEach in parsers )
      #nodes.dispatch( Organizer(this) )

      # TokenType
      create_file( cur_module+"TokenType" )
      writeln @|enum $ClassName( symbol:String, attributes=0:Int32 )
               |  ENUMERATE
               |  CATEGORIES
               |    EOI("end of input") = 1
               |endEnum
      writer.close

      # Token
      create_file( cur_module+"Token" )
      writeln @|class $ClassName
               |  PROPERTIES
               |    type : Int32
               |endClass
      writer.close

    method create_file( class_name, filename=null:String )

      if (not filename) filename = class_name + ".rogue"

      if (File.exists(filename)) print "Recreating "
      else                       print "Creating "
      println filename

      writer = File(folder/filename).print_writer

    method visit( cmd:Cmd )->Cmd  [override]
      throw cmd.t.error( "Rogue code generation not defined for $."(cmd.type_name) )

    method visit( cmd:CompareEQ )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "=="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareGT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write ">"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareLT )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "<"
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:CompareNE )->Cmd  [override]
      write "("
      dispatch( cmd.left )
      write "!="
      dispatch( cmd.right )
      write ")"
      return cmd

    method visit( cmd:Decrement )->Cmd  [override]
      write "--"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:If )->Cmd  [override]
      write   "if ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2

      dispatch( cmd.else_ifs )

      if (cmd._else)
        writeln "else"
        indent += 2
        dispatch( cmd._else )
        indent -= 2
      endIf

      write   "endIf"
      return cmd

    method visit( cmd:ElseIf )->Cmd  [override]
      write   "elseIf ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      return cmd

    method visit( cmd:Increment )->Cmd  [override]
      write "++"
      dispatch( cmd.target )
      return cmd

    method visit( cmd:HasNext )->Cmd  [override]
      write "scanner.has_another"
      return cmd

    method visit( cmd:LiteralCharacter )->Cmd  [override]
      writer.print( "'$'"(cmd.value.to_escaped_ascii("'")) )
      return cmd

    method visit( cmd:LiteralInt32 )->Cmd  [override]
      writer.print( cmd.value )
      return cmd

    method visit( cmd:LiteralString )->Cmd  [override]
      if (cmd.value.count == 1)
        writer.print( "'$'"(cmd.value.to_escaped_ascii("'")) )
      else
        writer.print( ''"$"''(cmd.value.to_escaped_ascii(''"'')) )
      endIf
      return cmd

    method visit( cmd:Print )->Cmd  [override]
      write "output"
      if (cmd.args.count == 0)
        throw cmd.t.error( "Argument expected for 'print'." )
      else
        forEach (arg in cmd.args)
          write ".print("
          arg.require_value.dispatch( this )
          write ")"
        endForEach
      endIf
      return cmd

    method visit( cmd:Println )->Cmd  [override]
      write "output"
      if (cmd.args.count == 0)
        throw cmd.t.error( "Argument expected for 'println'." )
      else
        forEach (arg in cmd.args)
          write ".print("
          arg.require_value.dispatch( this )
          write ")"
        endForEach
        write ".println"
      endIf
      return cmd

    method visit( cmd:Read )->Cmd  [override]
      write "scanner.read"
      return cmd

    method visit( cmd:ReadVar )->Cmd  [override]
      write cmd.var.name
      return cmd

    method visit( cmd:RoutineDef )->Cmd  [override]
      writeln "          case $"(cmd.ip)

      indent += 12
      prior.visit( cmd )
      indent -= 12

      return cmd

    method visit( cmd:ScannerDef )->Cmd  [override]
      # OutputFolder/XYZScanner.rogue
      create_file( cmd.name )
      writeln @|$module
               |$include "$ClassNameCore.rogue"
               |$include "$Token.rogue"
               |$include "$TokenType.rogue"
               |
               |class $ClassName : $ClassNameCore
               |endClass
      writer.close

      # OutputFolder/XYZScannerCore.rogue
      create_file( cmd.name+"Core" )
      write   @|$module
               |class $ClassName
               |  PROPERTIES
               |    filepath : String
               |    scanner  : Scanner
               |
               |    tokens   = $Token[]
               |    buffer   = StringBuilder()
               |    output   = StringBuilder()
               |
               |    start_ip = 0
               |    ip       : Int32
               |    ip_map   = StringTable<<Int32>>()
      local map = @{}
      forEach (r in cmd.routines) map[r.name] = r.ip
      writeln( map.to_json )

      writeln @|
               |    # Generated Properties
      local max_w = 0
      max_w .= or_larger( (forEach in cmd.vars).name.count )

      forEach (v in cmd.vars)
        write "    $ : "(v.name.left_justified(max_w))
        which (v.type)
          case Type.NONE
            throw v.t.error( "Cannot determine variable type of '$'. Set to an initial value."(v.name) )
          case Type.LOGICAL
            writeln "Logical"
          case Type.CHARACTER
            writeln "Character"
          case Type.INTEGER
            writeln "Int32"
          case Type.STRING
            writeln "String"
          others
            throw v.t.error( "[INTERNAL] Unhandled type '$'."(v.type) )
        endWhich
      endForEach

      writeln @|
               |  METHODS
               |    method init( file:File )
               |      init( file.filepath, Scanner(file) )
               |
               |    method init( filepath:String, content:String )
               |      init( filepath, Scanner(content) )
               |
               |    method init( filepath, scanner )
               |      noAction
               |
               |    method execute( start_ip )
               |      execute
               |
               |    method execute( label:String )
               |      start_ip = ip_map[ label ]
               |      execute
               |
               |    method execute
               |      local ip = start_ip
               |      loop
               |        ++ip
               |        which (ip-1)

      prior.visit( cmd )

      writeln @|          others
               |            escapeLoop
               |        endWhich
               |      endLoop
               |
               |endClass
      writer.close

      return cmd

    method visit( cmd:Statements )->Cmd  [override]
      forEach (element in cmd)
        if (element)
          element.dispatch( this )
          writeln
        endIf
      endForEach
      return cmd

    method visit( cmd:WriteVar )->Cmd  [override]
      write "$ = " (cmd.var.name)
      #write "[$]" (cmd.new_value.type_name)
      dispatch( cmd.new_value )
      return cmd

    method visit( cmd:While )->Cmd  [override]
      write   "while ("
      dispatch( cmd.condition )
      writeln ")"
      indent += 2
      dispatch( cmd.statements )
      indent -= 2
      write   "endWhile"
      return cmd

    method write( content:String )
      if (at_newline and indent)
        loop (indent) writer.print(' ')
      endIf

      if (content.contains('$'))
        content .= replacing( "$Token",      "$Token"(cur_module) )
        content .= replacing( "$ClassName",  class_name )
        if (String.exists(cur_module))
          content .= replacing( "$module", "module $\n"(cur_module) )
        else
          content .= replacing( "$module", "" )
        endIf
      endIf
      writer.print( content )

      at_newline = false

    method writeln( content="":String )
      if (String.exists(content)) write( content )
      writer.println
      at_newline = true

endClass
