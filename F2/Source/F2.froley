[tokens]
EOL                 EOL
CHARSET             charset    [content]
IDENTIFIER          identifier [content]
INTEGER             integer    [content]
STRING              string     [content]
STRING_OR_CHARACTER string     [content]
SYMBOL              symbol     [content]

[attributes]
structural

[section_keywords]
KEYWORD_PARSER          parser      [structural]
KEYWORD_SCANNER         scanner     [structural]
KEYWORD_TOKENS          tokens      [structural]

[scanner_keywords]
KEYWORD_BUFFER           buffer
KEYWORD_CASE             case
KEYWORD_COLLECT          collect
KEYWORD_END_MATCH        endMatch    [structural]
KEYWORD_INPUT            input
KEYWORD_PRODUCE_ANY      produceAny
KEYWORD_MATCH            match
KEYWORD_RESTART          restart

[common_keywords]
KEYWORD_AND              and
KEYWORD_CALL             call
KEYWORD_CONSUME          consume
KEYWORD_CONSUME_ANY      consumeAny
KEYWORD_DISCARD_POSITION discardPosition
KEYWORD_ELSE             else        [structural]
KEYWORD_ELSE_IF          elseIf      [structural]
KEYWORD_END_IF           endIf       [structural]
KEYWORD_END_WHILE        endWhile    [structural]
KEYWORD_FALSE            false
KEYWORD_GOTO             goto
KEYWORD_HALT             halt
KEYWORD_HAS_NEXT         hasAnother
KEYWORD_IF               if
KEYWORD_MARK_POSITION    markPosition
KEYWORD_MODE             mode
KEYWORD_MUST_CONSUME     mustConsume
KEYWORD_NEXT_IS          nextIs
KEYWORD_NOT              not
KEYWORD_ON               on          [structural]
KEYWORD_OR               or
KEYWORD_OTHERS           others      [structural]
KEYWORD_PRINT            print
KEYWORD_PRINTLN          println
KEYWORD_PRODUCE          produce
KEYWORD_READ             read
KEYWORD_RESTORE_POSITION restorePosition
KEYWORD_RETURN           return
KEYWORD_SAVE_POSITION    savePosition
KEYWORD_SCAN             scan
KEYWORD_SYNTAX_ERROR     syntaxError
KEYWORD_TRUE             true
KEYWORD_WHILE            while

[symbols]
SYMBOL_ARROW          ->  [structural]
SYMBOL_ASSIGN         =
SYMBOL_AT             @
SYMBOL_CARET          ^
SYMBOL_CLOSE_CURLY    }   [structural]
SYMBOL_CLOSE_PAREN    )   [structural]
SYMBOL_CLOSE_SQUARE   ]   [structural]
SYMBOL_COLON          :
SYMBOL_COMMA          ,
SYMBOL_DOT_DOT        ..
SYMBOL_EMPTY_BRACKETS []
SYMBOL_EQ             ==
SYMBOL_GE             >=
SYMBOL_GT             >
SYMBOL_LE             <=
SYMBOL_LT             <
SYMBOL_NE             !=
SYMBOL_MINUS          -
SYMBOL_MINUS_MINUS    --
SYMBOL_OPEN_CURLY     {
SYMBOL_OPEN_PAREN     (
SYMBOL_OPEN_SQUARE    [
SYMBOL_PLUS           +
SYMBOL_PLUS_PLUS      ++
SYMBOL_QUESTION       ?
SYMBOL_SEMICOLON      ;    [structural]
SYMBOL_SINGLE_QUOTE   '\''
SYMBOL_SLASH          /
SYMBOL_STAR           *

[tokenizer]
+ scan_standard_token
  if (not hasAnother) halt

  consume_whitespace
  consume_comment

  markSourcePosition

  if (consume('\n')) produce EOL

  scan_identifier
  scan_single_quoted_string
  scan_double_quoted_string
  scan_charset

  which (input)
    produceAny [symbols]
    others
      ch = peek
      if (ch is '0'..'9')
        scan_integer
        produce INTEGER
      endIf
  endWhich

  syntaxError

- scan_charset
  if (not consume('[')) return
  if (consume(']')) produce SYMBOL_EMPTY_BRACKETS

  collect '['
  while (hasAnother and not nextIs(']'))
    ch = read
    if (ch == '\\')
      ch = read
      if (ch == 'n')     ch = '\n'
      elseIf (ch == 'r') ch = '\r'
      elseIf (ch == 't') ch = '\t'
      else               collect '\\'  # leave the slash
    endIf
    collect ch
  endWhile

  mustConsume ']'
  collect ']'
  produce CHARSET

- consume_whitespace
  while (consume(' ') or consume('\t')) noAction
  return

- consume_comment
  if (not consume('#')) return
  if (consume('{'))
    @count = 1
    while (hasAnother)
      ch = read
      if (ch == '\n')
        create EOL
      elseIf (ch == '#')
        if (consume('{')) @count += 1
      elseIf (ch == '}')
        if (consume('#'))
          @count -= 1
          if (@count == 0) restart
        endIf
      endIf
    endWhile
    halt
  else
    # Single line comment
    while (hasAnother)
      ch = read
      if (ch == '\n') produce EOL
    endWhile
    restart
  endIf

- scan_tokens_id
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  markSourcePosition
  mode scan_token_name

  if (consume('\n')) produce EOL

  scan_identifier
  syntaxError "Identifier expected."

- scan_token_name
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  if (nextIs('-') or nextIs('+')) restart scan_standard_token

  markSourcePosition
  mode scan_token_symbol
  scan_identifier

  mode scan_token_name
  if (consume('\n')) produce EOL
  syntaxError "Identifier expected."

- scan_token_symbol
  consume_whitespace

  if (nextIs('[') or nextIs('\n')) restart scan_token_attributes

  # Scan everything to the next space
  while (hasAnother and not nextIs(' ') and not nextIs('\n'))
    ch = read
    collect ch
  endWhile

  mode scan_token_attributes
  produce SYMBOL

- scan_token_attributes
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  which (input)
    case '\n': mode scan_token_name; produce EOL
    case '[':  produce SYMBOL_OPEN_SQUARE
    case ']':  produce SYMBOL_CLOSE_SQUARE
    case ',':  produce SYMBOL_COMMA
  endWhich

  must_scan_attribute_identifier

- scan_identifier
  ch = peek
  if (ch is 'a'..'z' or ch is 'A'..'Z' or ch == '_')
    collect_identifier

    which (buffer)
      case "parser"
        mode scan_standard_token
        produce KEYWORD_PARSER
      case "scanner"
        mode scan_standard_token
        produce KEYWORD_SCANNER
      case "tokens"
        mode scan_tokens_id
        produce KEYWORD_TOKENS
      produceAny [scanner_keywords]
      produceAny [common_keywords]
      others
        produce IDENTIFIER
    endWhich
  endIf
  return

- must_scan_attribute_identifier
  ch = peek
  if (ch is 'a'..'z' or ch is 'A'..'Z' or ch == '_')
    collect_identifier
    produce IDENTIFIER
  endIf
  syntaxError "Identifier expected."

- collect_identifier
  clear buffer

  ch = peek
  while (ch is 'a'..'z' or ch is 'A'..'Z' or ch is '0'..'9' or ch == '_')
    ch = read
    collect ch
    ch = peek
    if (ch == '/')
      ch = peek(1)
      if (ch == '/') ch = read; collect ch; ch = read; collect ch
      ch = peek
    endIf
  endWhile

  return

- scan_integer
  while (ch is '0'..'9' or ch == '_')
    ch = read
    if (ch != '_') collect ch
    if (not hasAnother) return
    ch = peek
  endWhile
  return

- scan_single_quoted_string
  if (not consume('\'')) return
  while (hasAnother)
    if (consume('\''))
      produce STRING_OR_CHARACTER
    endIf
    if (nextIs('\n')) syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_double_quoted_string
  if (not consume('"')) return
  while (hasAnother)
    if (consume('"')) produce STRING
    if (nextIs('\n')) syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_literal_character
  ch = read
  if (ch == '\\')
    ch = read
    if (ch == 'n') ch = '\n'
    if (ch == 'r') ch = '\r'
    if (ch == 't') ch = '\t'
  endIf
  collect ch
  return

[parser]
+ program
  beginList

  while (consume(EOL)) noAction

  while (hasAnother)
    element
    while (consume(EOL)) noAction
  endWhile

  produceList

+ element
  on "scanner"
    createNull
    must_consume_eols
    routines
    produce ScannerDef(name:String,code)

  elseOn "parser"
    createNull
    must_consume_eols
    routines
    produce ParserDef(name:String,code)

  elseOn "tokens"
    if (consume(EOL)) createNull
    else              identifier
    token_definitions
    produce TokenGroup(name:String,definitions:CmdList)
  endOn
  syntaxError

+ identifier
  on IDENTIFIER -> Identifier(name=t.content:String)
  syntaxError "Identifier expected."

+ routines
  beginList

  consume_eols
  while (nextIs('-') or nextIs('+'))
    on "-"
      routine_name_and_base_type
      multi_line_statements
      create Routine(name:String,base_type:String,statements)
    elseOn "+"
      routine_name_and_base_type
      multi_line_statements
      create Subroutine(name:String,base_type:String,statements)
    endOn
    consume_eols
  endWhile

  produceList

+ routine_name_and_base_type
  identifier
  if (consume(':'))
    identifier
  else
    createNull
  endIf
  must_consume_eols

+ token_definitions
  beginList

  consume_eols
  while (hasAnother and not nextHasAttribute(structural))
    identifier

    if (nextIs(SYMBOL)) symbol
    else                createNull

    attributes

    create TokenDef(name:String,symbol:String,attributes:CmdList)
    consume_eols
  endWhile

  produceList

+ attributes
  if (not consume('[')) produceNull
  if (consume(']'))     produceNull

  beginList
  identifier
  while (consume(',') or not nextIs(']'))
    if (not hasAnother or nextIs(EOL)) syntaxError "Closing ']' expected."
    identifier
  endWhile
  mustConsume(']')
  produceList

+ symbol
  on SYMBOL -> Symbol(name=t.content:String)
  syntaxError "Symbol expected."

+ consume_eols
  while (consume(EOL)) noAction

+ must_consume_eols
  mustConsume(EOL)
  while (consume(EOL)) noAction

+ multi_line_statements
  consume_eols
  if (not hasAnother) syntaxError
  beginList
  while (hasAnother and not (nextIs('+') or nextIs('-') or nextHasAttribute(structural)))
    control_structure
    consume_eols
  endWhile
  produceList Statements

+ single_line_statements
  beginList

  if (consume(EOL)) produceList Statements
  statement
  while (consume(';'))
    consume_eols
    statement
  endWhile
  must_consume_eols

  produceList Statements

+ control_structure
  on "if"
    if (consume("("))
      expression
      mustConsume( ")" )
    else
      expression
    endIf
    if (consume(EOL))
      multi_line_statements
      multi_line_else_ifs
      multi_line_else
      mustConsume( "endIf" )
    else
      single_line_statements
      single_line_else_ifs
      single_line_else
    endIf
    produce If( condition, statements:Statements, else_ifs:CmdList, _else:Statements )
  endOn

  on "match"
    if (consume(EOL) or consume("input"))
      createNull
    else
      expression
    endIf
    cases
    _others
    mustConsume "endMatch"
    produce Match(expression,cases:CmdList,_others:Cmd)
  endOn

  on "while"
    if (consume("("))
      expression
      mustConsume( ")" )
    else
      expression
    endIf
    if (consume(EOL))
      multi_line_statements
      mustConsume( "endWhile" )
    else
      single_line_statements
    endIf
    produce While( condition, statements:Statements )
  endOn

  #on "local"
  #  identifier
  #  if (consume("=")) expression
  #  else              createNull
  #  produce LocalDeclaration(name:String,initial_value)
  #endOn

  statement


+ cases
  beginList
  endList

+ cases
  beginList
    consume_eols
    while (hasAnother)
      consume_eols
      on "case"
        expression
        if (consume("->"))
          beginList
            expression
            create ScannerProduce(token_type:Cmd)
          createList Statements
        else
          consume(":")
          consume_eols
          multi_line_statements
        endIf
        create MatchCase(expression,statements:CmdList)
      elseOn "produceAny"
        identifier
        create ProduceAny(token_group_name:String)
      else
        produceList
      endOn
    endWhile
  produceList

+ _others
  on "others"
    consume(":")
    consume_eols
    multi_line_statements
  else
    createNull
  endOn

+ multi_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        expression
        mustConsume( ")" )
      else
        expression
      endIf
      if (nextIs(EOL)) discardPosition
      else             restorePosition; produceList
      multi_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ multi_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (not consume(EOL)) restorePosition; produceNull
    multi_line_statements
    discardPosition
    return
  endOn

+ single_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        expression
        mustConsume( ")" )
      else
        expression
      endIf
      if (nextIs(EOL)) restorePosition; produceList
      else             discardPosition
      single_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ single_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (consume(EOL)) restorePosition; produceNull
    single_line_statements
    discardPosition
    return
  endOn

+ statement
  on "collect", args     -> Collect(args:Args)
  on "discardPosition"   -> DiscardPosition
  on "halt"              -> Halt
  on "markPosition"      -> MarkPosition
  on "mode", identifier  -> Mode(routine_name:String)
  on "mustConsume", args -> MustConsume(args:Args)
  on "print",   args     -> Print(args:Args)
  on "println"
    if (not hasAnother or nextHasAttribute(structural))
      beginList
      createList Args
    else
      args
    endIf
    produce Println(args:Args)
  endOn
  on "produce", expression      -> ScannerProduce(token_type:Cmd)
  on "->",      expression      -> ScannerProduce(token_type:Cmd)
  on "restart"
    if (nextIs(EOL)) createNull
    else             identifier
    produce Restart(start_ip:String)
  endOn
  on "restorePosition" -> RestorePosition
  on "return"
    if (nextIs(EOL)) createNull
    else             expression
    produce Return(value)
  endOn
  on "savePosition"    -> SavePosition
  on "syntaxError"
    if (nextIs(EOL)) createNull
    else             args
    produce ThrowSyntaxError(args:Args)
  endOn

  on "++", expression -> Increment(target)
  on "--", expression -> Decrement(target)

  expression

  on "=", expression -> Assign(target,new_value)
  on "++", expression -> Increment(target)
  on "--", expression -> Decrement(target)

+ args
  if (consume('('))
    consume_eols
    csv
    consume_eols
    mustConsume(')')
  else
    csv
  endIf

+ csv
  beginList
  if (nextHasAttribute(structural)) produceList Args

  expression
  while (hasAnother)
    if (consume(','))
      consume_eols
      expression
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList Args
    else
      expression
    endIf
  endWhile

  produceList Args

+ sequence
  beginList
  if (nextHasAttribute(structural)) produceList SequenceArgs

  sequence_item
  while (hasAnother)
    if (consume('*'))
      create ZeroOrMore(pattern)
    elseIf (consume('+'))
      create OneOrMore(pattern)
    elseIf (consume('?'))
      create OptionalPattern(pattern)
    elseIf (consume(','))
      consume_eols
      sequence_item
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList SequenceArgs
    else
      sequence_item
    endIf
  endWhile

  produceList SequenceArgs

+ sequence_item
  on '{' sequence '}': return
  on CHARSET
    create CharSet(characters=t.content:String)
    on '*'
      produce ZeroOrMore(pattern)
    elseOn '+'
      produce OneOrMore(pattern)
    elseOn '?'
      produce OptionalPattern(pattern)
    endOn
    return  # just the CharSet
  endOn
  on STRING              -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralStringOrCharacter( value=t.content:String )
  syntaxError

#+ alternatives
#  mustConsume('(')
#
#  beginList
#  consume_eols
#  if (consume(')')) produceList Args
#
#  expression
#  consume_eols
#  while (consume("|"))
#    expression
#    consume_eols
#  endWhile
#
#  mustConsume(')')
#  produceList Args

+ empty_statements
  beginList
  createList Statements

+ expression

- logical_or : Binary
  on "or" -> LogicalOr

- logical_and : Binary
  on "and" -> LogicalAnd

- comparison : Binary
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

- add_subtract : Binary
  on "+" -> Add
  on "-" -> Subtract

- multiply_divide : Binary
  on "*" -> Multiply
  on "/" -> Divide

- power : Binary
  on "^" -> Power

- pre_unary : PreUnary
  on "-"   -> Negate
  on "not" -> LogicalNot

- term
  on '(' expression ')':        return
  on '{' sequence '}':          return
  on "buffer"                   -> ReadBuffer
  on "call", identifier         -> CallUserMethod(fn_name:String)
  on "consume", args            -> Consume(args:Args)
  on "false"                    -> LiteralLogical(value="false":Logical)
  on "goto", identifier         -> Goto(routine_name:String)
  on "hasAnother"               -> HasAnother
  on "nextIs", args             -> NextIs(args:Args)
  on "read"                     -> Read
  on "scan", args             -> Scan(args:Args)
  on "true"                   -> LiteralLogical(value="true":Logical)
  on CHARSET
    create CharSet(characters=t.content:String)
    on '*'
      produce ZeroOrMore(pattern)
    elseOn '+'
      produce OneOrMore(pattern)
    elseOn '?'
      produce OptionalPattern(pattern)
    endOn
    return  # just the CharSet
  endOn
  on IDENTIFIER          -> Access( name=t.content:String )
  on INTEGER             -> LiteralInteger( value=t.content:Int32 )
  on STRING              -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralStringOrCharacter( value=t.content:String )
  syntaxError

