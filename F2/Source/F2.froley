[tokens]
EOL                 EOL
IDENTIFIER          identifier [content]
INTEGER             integer    [content]
STRING              string     [content]
STRING_OR_CHARACTER string     [content]
SYMBOL              symbol     [content]

[attributes]
structural

[section_keywords]
KEYWORD_PARSER          parser      [structural]
KEYWORD_SCANNER         scanner     [structural]
KEYWORD_TOKENS          tokens      [structural]

[scanner_keywords]
KEYWORD_BUFFER           buffer
KEYWORD_COLLECT          collect
KEYWORD_COLLECT_RANGE    collectRange
KEYWORD_DISCARD_POSITION discardPosition
KEYWORD_PRODUCE_ANY      produceAny
KEYWORD_MARK_POSITION    markPosition
KEYWORD_RESTART          restart
KEYWORD_RESTORE_POSITION restorePosition
KEYWORD_SAVE_POSITION    savePosition

[common_keywords]
KEYWORD_AND             and
KEYWORD_CONSUME         consume
KEYWORD_CONSUME_ANY     consumeAny
KEYWORD_ELSE            else        [structural]
KEYWORD_ELSE_IF         elseIf      [structural]
KEYWORD_END_IF          endIf       [structural]
KEYWORD_END_SCAN        endScan     [structural]
KEYWORD_END_WHILE       endWhile    [structural]
KEYWORD_FALSE           false
KEYWORD_HALT            halt
KEYWORD_HAS_NEXT        hasAnother
KEYWORD_IF              if
KEYWORD_NOT             not
KEYWORD_ON              on          [structural]
KEYWORD_OR              or
KEYWORD_OTHERS          others      [structural]
KEYWORD_PRINT           print
KEYWORD_PRINTLN         println
KEYWORD_PRODUCE         produce
KEYWORD_READ            read
KEYWORD_RETURN          return
KEYWORD_SCAN            scan
KEYWORD_SYNTAX_ERROR    syntaxError
KEYWORD_TRUE            true
KEYWORD_WHILE           while

[symbols]
SYMBOL_ALTERNATIVE  |
SYMBOL_ASSIGN       =
SYMBOL_CARET        ^
SYMBOL_CLOSE_PAREN  )   [structural]
SYMBOL_CLOSE_SQUARE ]   [structural]
SYMBOL_COLON        :
SYMBOL_COMMA        ,
SYMBOL_DOT_DOT      ..
SYMBOL_EQ           ==
SYMBOL_GE           >=
SYMBOL_GT           >
SYMBOL_LE           <=
SYMBOL_LT           <
SYMBOL_NE           !=
SYMBOL_MINUS        -
SYMBOL_MINUS_MINUS  --
SYMBOL_OPEN_PAREN   (
SYMBOL_OPEN_SQUARE  [
SYMBOL_PLUS         +
SYMBOL_PLUS_PLUS    ++
SYMBOL_SEMICOLON    ;
SYMBOL_SINGLE_QUOTE '\''
SYMBOL_SLASH        /
SYMBOL_STAR         *

[tokenizer]
+ scan_standard_token
  if (not hasAnother) halt

  consume_whitespace
  consume_comment

  markSourcePosition

  if (consume('\n')) produce EOL

  scan_identifier
  scan_single_quoted_string
  scan_double_quoted_string

  which (input)
    produceAny [symbols]
    others
      ch = peek
      if (ch is '0'..'9')
        scan_integer
        produce INTEGER
      endIf
  endWhich

  syntaxError

- consume_whitespace
  while (consume(' ') or consume('\t')) noAction
  return

- consume_comment
  if (not consume('#')) return
  if (consume('{'))
    @count = 1
    while (hasAnother)
      ch = read
      if (ch == '\n')
        create EOL
      elseIf (ch == '#')
        if (consume('{')) @count += 1
      elseIf (ch == '}')
        if (consume('#'))
          @count -= 1
          if (@count == 0) restart
        endIf
      endIf
    endWhile
    halt
  else
    # Single line comment
    while (hasAnother)
      ch = read
      if (ch == '\n') produce EOL
    endWhile
    restart
  endIf

- scan_tokens_id
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  markSourcePosition
  mode scan_token_name

  if (consume('\n')) produce EOL

  scan_identifier
  syntaxError "Identifier expected."

- scan_token_name
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  if (nextIs('-') or nextIs('+')) restart scan_standard_token

  markSourcePosition
  mode scan_token_symbol
  scan_identifier

  mode scan_token_name
  if (consume('\n')) produce EOL
  syntaxError "Identifier expected."

- scan_token_symbol
  consume_whitespace

  if (nextIs('[') or nextIs('\n')) restart scan_token_attributes

  # Scan everything to the next space; backslash escapes
  while (hasAnother and not nextIs(' ') and not nextIs('\n'))
    ch = read
    if (ch == '\\' and hasAnother) ch = read
    collect ch
  endWhile

  mode scan_token_attributes
  produce SYMBOL

- scan_token_attributes
  consume_whitespace
  consume_comment
  if (not hasAnother) halt

  which (input)
    case '\n': mode scan_token_name; produce EOL
    case '[':  produce SYMBOL_OPEN_SQUARE
    case ']':  produce SYMBOL_CLOSE_SQUARE
    case ',':  produce SYMBOL_COMMA
  endWhich

  must_scan_attribute_identifier

- scan_identifier
  ch = peek
  if (ch is 'a'..'z' or ch is 'A'..'Z' or ch == '_')
    collect_identifier

    which (buffer)
      case "parser"
        mode scan_standard_token
        produce KEYWORD_PARSER
      case "scanner"
        mode scan_standard_token
        produce KEYWORD_SCANNER
      case "tokens"
        mode scan_tokens_id
        produce KEYWORD_TOKENS
      produceAny [scanner_keywords]
      produceAny [common_keywords]
      others
        produce IDENTIFIER
    endWhich
  endIf
  return

- must_scan_attribute_identifier
  ch = peek
  if (ch is 'a'..'z' or ch is 'A'..'Z' or ch == '_')
    collect_identifier
    produce IDENTIFIER
  endIf
  syntaxError "Identifier expected."

- collect_identifier
  clear buffer

  ch = peek
  while (ch is 'a'..'z' or ch is 'A'..'Z' or ch is '0'..'9' or ch == '_')
    ch = read
    collect ch
    ch = peek
    if (ch == '/')
      ch = peek(1)
      if (ch == '/') ch = read; collect ch; ch = read; collect ch
      ch = peek
    endIf
  endWhile

  return

- scan_integer
  while (ch is '0'..'9' or ch == '_')
    ch = read
    if (ch != '_') collect ch
    if (not hasAnother) return
    ch = peek
  endWhile
  return

- scan_single_quoted_string
  if (not consume('\'')) return
  while (hasAnother)
    if (consume('\''))
      produce STRING_OR_CHARACTER
    endIf
    if (nextIs('\n')) syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_double_quoted_string
  if (not consume('"')) return
  while (hasAnother)
    if (consume('"')) produce STRING
    if (nextIs('\n')) syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_literal_character
  ch = read
  if (ch == '\\')
    ch = read
    if (ch == 'n') ch = '\n'
    if (ch == 'r') ch = '\r'
    if (ch == 't') ch = '\t'
  endIf
  collect ch
  return

[parser]
+ program
  beginList

  while (consume(EOL)) noAction

  while (hasAnother)
    element
    while (consume(EOL)) noAction
  endWhile

  produceList

+ element
  on "scanner"
    if (consume(EOL)) createNull
    else              identifier
    must_consume_eols
    routines
    produce ScannerDef(name:String,code)

  elseOn "parser"
    if (consume(EOL)) createNull
    else              identifier
    must_consume_eols
    routines
    produce ParserDef(name:String,code)

  elseOn "tokens"
    if (consume(EOL)) createNull
    else              identifier
    token_definitions
    produce TokenGroup(name:String,definitions:CmdList)
  endOn
  syntaxError

+ identifier
  on IDENTIFIER -> Identifier(name=t.content:String)
  syntaxError "Identifier expected."

+ routines
  beginList

  consume_eols
  while (nextIs('-') or nextIs('+'))
    on "-"
      routine_name_and_base_type
      multi_line_statements
      create Routine(name:String,base_type:String,statements)
    elseOn "+"
      routine_name_and_base_type
      multi_line_statements
      create Subroutine(name:String,base_type:String,statements)
    endOn
    consume_eols
  endWhile

  produceList

+ routine_name_and_base_type
  identifier
  if (consume(':'))
    identifier
  else
    createNull
  endIf
  must_consume_eols

+ token_definitions
  beginList

  consume_eols
  while (hasAnother and not nextHasAttribute(structural))
    identifier

    if (nextIs(SYMBOL)) symbol
    else                createNull

    attributes

    create TokenDef(name:String,symbol:String,attributes:CmdList)
    consume_eols
  endWhile

  produceList

+ attributes
  if (not consume('[')) produceNull
  if (consume(']'))     produceNull

  beginList
  identifier
  while (consume(',') or not nextIs(']'))
    if (not hasAnother or nextIs(EOL)) syntaxError "Closing ']' expected."
    identifier
  endWhile
  mustConsume(']')
  produceList

+ symbol
  on SYMBOL -> Symbol(name=t.content:String)
  syntaxError "Symbol expected."

+ consume_eols
  while (consume(EOL)) noAction

+ must_consume_eols
  mustConsume(EOL)
  while (consume(EOL)) noAction

+ multi_line_statements
  consume_eols
  if (not hasAnother) syntaxError
  beginList
  while (hasAnother and not (nextIs('+') or nextIs('-') or nextHasAttribute(structural)))
    control_structure
    consume_eols
  endWhile
  produceList Statements

+ single_line_statements
  beginList

  if (consume(EOL)) produceList Statements
  statement
  while (consume(';'))
    consume_eols
    statement
  endWhile
  must_consume_eols

  produceList Statements

+ control_structure
  on "if"
    if (consume("("))
      expression
      mustConsume( ")" )
    else
      expression
    endIf
    if (consume(EOL))
      multi_line_statements
      multi_line_else_ifs
      multi_line_else
      mustConsume( "endIf" )
    else
      single_line_statements
      single_line_else_ifs
      single_line_else
    endIf
    produce If( condition, statements:Statements, else_ifs:CmdList, _else:Statements )
  endOn

  on "scan"
    if (consume(EOL)) createNull
    else              expression
    cases
    _others
    mustConsume "endScan"
    produce Scan(expression,cases:CmdList,_others:Cmd)
  endOn

  on "while"
    if (consume("("))
      expression
      mustConsume( ")" )
    else
      expression
    endIf
    if (consume(EOL))
      multi_line_statements
      mustConsume( "endWhile" )
    else
      single_line_statements
    endIf
    produce While( condition, statements:Statements )
  endOn

  #on "local"
  #  identifier
  #  if (consume("=")) expression
  #  else              createNull
  #  produce LocalDeclaration(name:String,initial_value)
  #endOn

  statement


+ cases
  beginList
  endList

+ cases
  beginList
    consume_eols
    while (hasAnother)
      consume_eols
      on "on"
        expression
        consume(":")
        consume_eols
        multi_line_statements
        create ScanOn(expression,statements:CmdList)
      elseOn "produceAny"
        identifier
        create ProduceAny(token_group_name:String)
      else
        produceList
      endOn
    endWhile
  produceList

+ _others
  on "others"
    consume(":")
    consume_eols
    multi_line_statements
  else
    createNull
  endOn

+ multi_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        expression
        mustConsume( ")" )
      else
        expression
      endIf
      if (nextIs(EOL)) discardPosition
      else             restorePosition; produceList
      multi_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ multi_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (not consume(EOL)) restorePosition; produceNull
    multi_line_statements
    discardPosition
    return
  endOn

+ single_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        expression
        mustConsume( ")" )
      else
        expression
      endIf
      if (nextIs(EOL)) restorePosition; produceList
      else             discardPosition
      single_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ single_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (consume(EOL)) restorePosition; produceNull
    single_line_statements
    discardPosition
    return
  endOn

+ statement
  on "collect",      args -> Collect(args:CmdList)
  on "print",        args -> Print(args:CmdList)
  on "println",      args -> Println(args:CmdList)
  on "syntaxError"
    if (nextIs(EOL)) createNull
    else             args
    produce ScanError(args:CmdList)
  endOn

  on "++", expression -> Increment(target)
  on "--", expression -> Decrement(target)

  expression

  on "=", expression -> Assign(target,new_value)
  on "++", expression -> Increment(target)
  on "--", expression -> Decrement(target)

+ args
  if (consume('('))
    consume_eols
    csv
    consume_eols
    mustConsume(')')
  else
    csv
  endIf

+ csv
  beginList
  if (nextHasAttribute(structural)) produceList Args

  expression
  while (hasAnother)
    if (consume(','))
      consume_eols
      expression
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList Args
    else
      expression
    endIf
  endWhile

  produceList Args

+ alternatives
  mustConsume('(')

  beginList
  consume_eols
  if (consume(')')) produceList Args

  expression
  consume_eols
  while (consume("|"))
    expression
    consume_eols
  endWhile

  mustConsume(')')
  produceList Args

+ empty_statements
  beginList
  createList Statements

+ expression

- logical_or : Binary
  on "or" -> LogicalOr

- logical_and : Binary
  on "and" -> LogicalAnd

- comparison : Binary
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

- add_subtract : Binary
  on "+" -> Add
  on "-" -> Subtract

- multiply_divide : Binary
  on "*" -> Multiply
  on "/" -> Divide

- power : Binary
  on "^" -> Power

- pre_unary : PreUnary
  on "-"   -> Negate
  on "not" -> LogicalNot

- term
  on '(' expression ')': return
  on "buffer"                   -> ReadBuffer
  on "collectRange", expression -> CollectRange(range)
  on "consume", alternatives    -> Consume(alternatives:CmdList)
  on "consumeAny"
    expression
    create ConsumeAny(alternatives)
    empty_statements
    produce While(condition,statements:Statements)
  endOn
  on "discardPosition"     -> DiscardPosition
  on "false"               -> LiteralLogical(value="false":Logical)
  on "halt"                -> Halt
  on "hasAnother"          -> HasAnother
  on "markPosition"        -> MarkPosition
  on "produce", expression -> ScannerProduce(token_type:Cmd)
  on "read"                -> Read
  on "restart"
    if (nextIs(EOL)) createNull
    else             identifier
    produce Restart(start_ip:String)
  endOn
  on "restorePosition"     -> RestorePosition
  on "return"
    if (nextIs(EOL)) createNull
    else             expression
    produce Return(value)
  endOn
  on "savePosition"        -> SavePosition
  on "true"                  -> LiteralLogical(value="true":Logical)
  on IDENTIFIER -> Access( name=t.content:String )
  on INTEGER    -> LiteralInteger( value=t.content:Int32 )
  on STRING     -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralStringOrCharacter( value=t.content:String )
  syntaxError

