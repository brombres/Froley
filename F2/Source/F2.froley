[tokens]
EOL                 EOL
IDENTIFIER          identifier [content]
INTEGER             integer    [content]
STRING              string     [content]
STRING_OR_CHARACTER string     [content]
SYMBOL              symbol     [content]

[attributes]
structural

[element_keywords]
KEYWORD_PARSER          parser      [structural]
KEYWORD_SCANNER         scanner     [structural]
KEYWORD_TOKENS          tokens      [structural]
# For changes here be sure to adjust scanning_token_defs logic

[scanner_keywords]
KEYWORD_BUFFER          buffer
KEYWORD_COLLECT         collect
KEYWORD_PRODUCE_ANY     produceAny

[common_keywords]
KEYWORD_AND             and
KEYWORD_CONSUME         consume
KEYWORD_ELSE            else        [structural]
KEYWORD_ELSE_IF         elseIf      [structural]
KEYWORD_END_IF          endIf       [structural]
KEYWORD_END_SCAN        endScan     [structural]
KEYWORD_END_WHILE       endWhile    [structural]
KEYWORD_HALT            halt
KEYWORD_HAS_NEXT        hasAnother
KEYWORD_IF              if
KEYWORD_NOT             not
KEYWORD_ON              on          [structural]
KEYWORD_OR              or
KEYWORD_OTHERS          others      [structural]
KEYWORD_PRINT           print
KEYWORD_PRINTLN         println
KEYWORD_PRODUCE         produce
KEYWORD_READ            read
KEYWORD_RETURN          return
KEYWORD_SCAN            scan
KEYWORD_SYNTAX_ERROR    syntaxError
KEYWORD_WHILE           while

[symbols]
SYMBOL_ALTERNATIVE  |
SYMBOL_ASSIGN       =
SYMBOL_CARET        ^
SYMBOL_CLOSE_PAREN  )   [structural]
SYMBOL_CLOSE_SQUARE ]   [structural]
SYMBOL_COLON        :
SYMBOL_COMMA        ,
SYMBOL_DOT_DOT      ..
SYMBOL_EQ           ==
SYMBOL_GE           >=
SYMBOL_GT           >
SYMBOL_LE           <=
SYMBOL_LT           <
SYMBOL_NE           !=
SYMBOL_MINUS        -
SYMBOL_MINUS_MINUS  --
SYMBOL_OPEN_PAREN   (
SYMBOL_OPEN_SQUARE  [
SYMBOL_PLUS         +
SYMBOL_PLUS_PLUS    ++
SYMBOL_SEMICOLON    ;
SYMBOL_SINGLE_QUOTE '\''
SYMBOL_SLASH        /
SYMBOL_STAR         *

[tokenizer]
+ tokenize_froley
  if (not hasAnother) halt

  consume_whitespace
  consume_comment

  markSourcePosition

  if (consume('\n')) produce EOL

  scan_identifier
  scan_single_quoted_string
  scan_double_quoted_string

  which (input)
    produceAny [symbols]
    others
      ch = peek
      if (ch is '0'..'9')
        scan_integer
        produce INTEGER
      endIf
  endWhich

  syntaxError

+ scan_token_def
  if (not hasAnother) halt

  consume_whitespace
  markSourcePosition

  if (consume('\n'))
    mode tokenize_froley
    produce EOL
  endIf

  # Scan everything to the next space; backslash escapes
  while (hasAnother and not nextIs(' ') and not nextIs('\n'))
    ch = read
    if (ch == '\\' and hasAnother) ch = read
    collect ch
  endWhile

  produce SYMBOL

- consume_whitespace
  while (consume(' ') or consume('\t')) noAction
  return

- consume_comment
  if (not consume('#')) return
  while (hasAnother)
    ch = read
    if (ch == '\n') produce EOL
  endWhile
  restart

- scan_identifier
  ch = peek
  if (ch is 'a'..'z' or ch is 'A'..'Z' or ch == '_')
    clear buffer
    while (ch is 'a'..'z' or ch is 'A'..'Z' or ch is '0'..'9' or ch == '_')
      ch = read
      collect ch
      ch = peek
      if (ch == '/')
        ch = peek(1)
        if (ch == '/') ch = read; collect ch; ch = read; collect ch
        ch = peek
      endIf
    endWhile

    which (buffer)
      case "parser"
        @scanning_token_defs = 0
        produce KEYWORD_PARSER
      case "scanner"
        @scanning_token_defs = 0
        produce KEYWORD_SCANNER
      case "tokens"
        @scanning_token_defs = 1
        produce KEYWORD_TOKENS
      others
        if (@scanning_token_defs)
          mode scan_token_def
          produce IDENTIFIER
        endIf
    endWhich

    which (buffer)
      produceAny [scanner_keywords]
      produceAny [common_keywords]
      others: produce IDENTIFIER
    endWhich
  endIf
  return

- scan_integer
  while (ch is '0'..'9' or ch == '_')
    ch = read
    if (ch != '_') collect ch
    if (not hasAnother) return
    ch = peek
  endWhile
  return

- scan_single_quoted_string
  if (not consume('\'')) return
  while (hasAnother)
    if (consume('\''))
      produce STRING_OR_CHARACTER
    endIf
    if (nextIs('\n')) syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_double_quoted_string
  if (not consume('"')) return
  while (hasAnother)
    if (consume('"')) produce STRING
    if (nextIs('\n')) trace; syntaxError "Unterminated string."
    scan_literal_character
  endWhile
  syntaxError "Unterminated string."

- scan_literal_character
  ch = read
  if (ch == '\\')
    ch = read
    if (ch == 'n') ch = '\n'
    if (ch == 'r') ch = '\r'
    if (ch == 't') ch = '\t'
  endIf
  collect ch
  return

[parser]
+ program
  beginList

  while (consume(EOL)) noAction

  while (hasAnother)
    element
    while (consume(EOL)) noAction
  endWhile

  produceList

+ element
  on "scanner"
    if (consume(EOL)) createNull
    else              identifier
    must_consume_eols
    routines
    produce ScannerDef(name:String,code)

  elseOn "parser"
    if (consume(EOL)) createNull
    else              identifier
    must_consume_eols
    routines
    produce ParserDef(name:String,code)

  elseOn "tokens"
    if (consume(EOL)) createNull
    else              identifier
    token_definitions
    produce TokenGroup(name:String,definitions:CmdList)
  endOn
  syntaxError

+ identifier
  on IDENTIFIER -> Identifier(name=t.content:String)
  syntaxError "Identifier expected."

+ routines
  beginList

  consume_eols
  while (nextIs('+') or nextIs('-'))
    on "+"
      routine_name_and_base_type
      multi_line_statements
      create RoutineDef(name:String,base_type:String,statements)
    elseOn "-"
      routine_name_and_base_type
      multi_line_statements
      create SubroutineDef(name:String,base_type:String,statements)
    endOn
    consume_eols
  endWhile

  produceList

+ routine_name_and_base_type
  identifier
  if (consume(':'))
    identifier
  else
    createNull
  endIf
  must_consume_eols

+ token_definitions
  beginList

  consume_eols
  while (hasAnother and not nextHasAttribute(structural))
    identifier
    if (nextIs(SYMBOL)) symbol
    else                createNull
    createNull  # [attributes] placeholder
    create TokenDef(name:String,symbol:String,attributes:CmdList)
    consume_eols
  endWhile

  produceList

+ symbol
  on SYMBOL -> Symbol(name=t.content:String)
  syntaxError "Symbol expected."

+ consume_eols
  while (consume(EOL)) noAction

+ must_consume_eols
  mustConsume(EOL)
  while (consume(EOL)) noAction

+ multi_line_statements
  consume_eols
  if (not hasAnother) syntaxError
  beginList
  while (hasAnother and not (nextIs('+') or nextIs('-') or nextHasAttribute(structural)))
    control_structure
    consume_eols
  endWhile
  produceList Statements

+ single_line_statements
  beginList

  if (consume(EOL)) produceList Statements
  statement
  while (consume(';'))
    consume_eols
    statement
  endWhile
  must_consume_eols

  produceList Statements

+ control_structure
  on "if"
    if (consume("("))
      expression
      mustConsume( ")" )
    else
      expression
    endIf
    if (consume(EOL))
      multi_line_statements
      multi_line_else_ifs
      multi_line_else
      mustConsume( "endIf" )
    else
      single_line_statements
      single_line_else_ifs
      single_line_else
    endIf
    produce If( condition, statements:Statements, else_ifs:CmdList, _else:Statements )
  endOn

  on "scan"
    if (consume(EOL)) createNull
    else              expression
    cases
    _others
    mustConsume "endScan"
    produce Scan(expression,cases:CmdList,_others:Cmd)
  endOn

  on "while"
    if (consume("("))
      expression
      mustConsume( ")" )
    else
      expression
    endIf
    if (consume(EOL))
      multi_line_statements
      mustConsume( "endWhile" )
    else
      single_line_statements
    endIf
    produce While( condition, statements:Statements )
  endOn

  #on "local"
  #  identifier
  #  if (consume("=")) expression
  #  else              createNull
  #  produce LocalDeclaration(name:String,initial_value)
  #endOn

  statement


+ cases
  beginList
  endList

+ cases
  beginList
    consume_eols
    while (hasAnother)
      consume_eols
      on "on"
        expression
        consume(":")
        consume_eols
        multi_line_statements
        create ScanOn(expression,statements:CmdList)
      elseOn "produceAny"
        identifier
        create ProduceAny(token_group_name:String)
      else
        produceList
      endOn
    endWhile
  produceList

+ _others
  on "others"
    consume(":")
    consume_eols
    multi_line_statements
  else
    createNull
  endOn

+ multi_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        expression
        mustConsume( ")" )
      else
        expression
      endIf
      if (nextIs(EOL)) discardPosition
      else             restorePosition; produceList
      multi_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ multi_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (not consume(EOL)) restorePosition; produceNull
    multi_line_statements
    discardPosition
    return
  endOn

+ single_line_else_ifs
  beginList

  while (nextIs("elseIf"))
    savePosition
    on "elseIf"
      if (consume("("))
        expression
        mustConsume( ")" )
      else
        expression
      endIf
      if (nextIs(EOL)) restorePosition; produceList
      else             discardPosition
      single_line_statements
      create ElseIf(condition,statements:Statements)
    endOn
  endWhile

  produceList

+ single_line_else
  if (not nextIs("else")) produceNull
  savePosition
  on "else"
    if (consume(EOL)) restorePosition; produceNull
    single_line_statements
    discardPosition
    return
  endOn

+ statement
  on "collect",      args -> Collect(args:CmdList)
  on "print",        args -> Print(args:CmdList)
  on "println",      args -> Println(args:CmdList)
  on "syntaxError"
    if (nextIs(EOL)) createNull
    else             args
    produce ScanError(args:CmdList)
  endOn

  on "++", expression -> Increment(target)
  on "--", expression -> Decrement(target)

  expression

  on "=", expression -> Assign(target,new_value)
  on "++", expression -> Increment(target)
  on "--", expression -> Decrement(target)

+ args
  if (consume('('))
    consume_eols
    csv
    consume_eols
    mustConsume(')')
  else
    csv
  endIf

+ csv
  beginList
  if (nextHasAttribute(structural)) produceList Args

  expression
  while (hasAnother)
    if (consume(','))
      consume_eols
      expression
    elseIf (nextIs(EOL) or nextHasAttribute(structural))
      produceList Args
    else
      expression
    endIf
  endWhile

  produceList Args

+ alternatives
  mustConsume('(')

  beginList
  consume_eols
  if (consume(')')) produceList Args

  expression
  consume_eols
  while (consume("|"))
    expression
    consume_eols
  endWhile

  mustConsume(')')
  produceList Args

+ expression

- logical_or : Binary
  on "or" -> LogicalOr

- logical_and : Binary
  on "and" -> LogicalAnd

- comparison : Binary
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

- add_subtract : Binary
  on "+" -> Add
  on "-" -> Subtract

- multiply_divide : Binary
  on "*" -> Multiply
  on "/" -> Divide

- power : Binary
  on "^" -> Power

- pre_unary : PreUnary
  on "-"   -> Negate
  on "not" -> LogicalNot

- term
  on '(' expression ')': return
  on "buffer"                -> ReadBuffer
  on "consume", alternatives -> Consume(alternatives:CmdList)
  on "halt"                  -> Halt
  on "hasAnother"               -> HasAnother
  on "produce", expression   -> ScannerProduce(token_type:Cmd)
  on "read"                  -> Read
  on "return"
    if (nextIs(EOL)) createNull
    else             expression
    produce Return(value)
  endOn
  on IDENTIFIER -> Access( name=t.content:String )
  on INTEGER    -> LiteralInteger( value=t.content:Int32 )
  on STRING     -> LiteralString( value=t.content:String )
  on STRING_OR_CHARACTER -> LiteralStringOrCharacter( value=t.content:String )
  syntaxError

