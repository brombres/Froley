module Froley

class RNodeLogic : RogueSourceWriter
  PROPERTIES
    handled_node_types = Set<<String>>()
    logic              : NodeLogic
    method_name        : String
    method_signature   : String
    call_signature     : String
    return_type        : String
    default_value      : String

  METHODS
    method init( generator:RogueGenerator, logic )
      prior.init( generator )
      class_name  = logic.filename
      method_name = logic.method_name

      if (logic.return_info)
        return_type = logic.return_info._type_name
        if (logic.return_info.is_optional) return_type += "?"

        default_value = logic.return_info.default_value
      endIf

      use builder = StringBuilder.pool
        builder.print method_name

        if (logic.parameters.count)
          builder.print "( "
          forEach (param at i in logic.parameters)
            block param = param->(as Parameter)
              if (i > 0) builder.print ", "
              builder.print( param.name )
              builder.print ':'
              builder.print( param._type_name )
            endBlock
          endForEach
          builder.print " )"
        endIf

        if (return_type)
          builder.print "->"
          builder.print( return_type )
        endIf

        method_signature = builder->String
      endUse

      use builder = StringBuilder.pool
        builder.print method_name

        if (logic.parameters.count)
          builder.print '('
          forEach (param at i in logic.parameters)
            block param = param->(as Parameter)
              if (i > 0) builder.print ','
              builder.print( param.name )
            endBlock
          endForEach
          builder.print ')'
        endIf

        call_signature = builder->String
      endUse

    method scan_node_types( content:String )
      forEach (line in LineReader(content))
        if (line.contains("method") and line.contains(method_name))
          local node_type = line.after_first("method ").before_first('.')
          handled_node_types.add( node_type )
        endIf
      endForEach

    method update_content( content:String )->String
      if (not String.exists(content) or not content.contains("augment"))
        if (content is null) content = ""

        use builder = StringBuilder.pool
          builder.print content

          builder.println  "# Generated and updated by Froley. Custom changes will not be overwritten; customize as desired.\n"
          builder.println  "module $\n"(Program.project_name)
          builder.println  "augment"
          builder.println  "  METHODS"
          builder.println  "    method Cmd.$"(method_signature)
          builder.println ''      #throw t.error( "[INTERNAL] $.$() is undefined."(type_name) )'' ('$',method_name)
          if (return_type) builder.println ''      return $''(default_value)
          builder.println
          builder.println  "    method CmdList.$"(method_signature)
          if (return_type)
            builder.println "      local result : $"(return_type)
            builder.println "      forEach (cmd in list)"
            builder.println "        result = cmd.$"(call_signature)
            builder.println "        if (result) return result"
            builder.println "      endForEach"
            builder.println "      return $"(default_value)
            builder.println
          else
            builder.println "      forEach (cmd in list)"
            builder.println "        cmd.$"(call_signature)
            builder.println "      endForEach"
            builder.println
          endIf
          builder.println "endAugment"

          content = builder->String
        endUse
      endIf

      scan_node_types( content )

      local builder = StringBuilder(content.count*2)

      local end_augment_location = content.locate( "endAugment", content.locate("augment").value )
      local bottom = "endAugment\n"
      if (end_augment_location)
        bottom = content.from( end_augment_location.value )
        content = content.leftmost( end_augment_location.value ).trimmed
      endIf

      builder.println( content )
      builder.indent = 4

      forEach (node_type in Program.types.values.to_list.sorted((a,b)=>(a.name<b.name)))
        if (node_type.is_built_in or node_type.is_native or node_type.is_list) nextIteration

        if (not handled_node_types.contains(node_type.name))
          handled_node_types.add( node_type.name )

          local properties = node_type.properties
          properties .= discarding( (p) => p.type.is_built_in or p.type.is_native )
          local extended_properties = node_type.extended_properties
          extended_properties .= discarding( (p) => p.type.is_built_in or p.type.is_native )

          if (extended_properties.count)
            builder.println
            builder.print(  "method " ).print(node_type.name).print('.').println(method_signature)

            if (return_type)
              builder.println "  local result : $"(return_type)
              if (properties.count)
                forEach (p in properties)
                  local type = p.type
                  if (not (type.is_built_in or type.is_native))
                    builder.println "  if ($)"(p.name)
                    builder.println "    result = $.$"(p.name,call_signature)
                    builder.println "    if (result) return result"
                    builder.println "  endIf"
                  endIf
                endForEach
              endIf
              builder.println "  return $"(default_value)

            else
              if (properties.count)
                forEach (p in properties)
                  local type = p.type
                  if (not (type.is_built_in or type.is_native))
                    builder.println "  if ($) $.$"(p.name,p.name,call_signature)
                  endIf
                endForEach
              endIf
            endIf

          endIf
        endIf
      endForEach

      builder.println

      content = builder->String + bottom
      return content
endClass
