augment RogueTemplate
  PROPERTIES
    tokenizer_vm =
      @|module FroleyLanguage
       |
       |$include "Code.rogue"
       |$include "Error.rogue"
       |$include "Token.rogue"
       |$include "TokenType.rogue"
       |$include "TokenizerOpcode.rogue"
       |
       |class TokenizerVM
       |  DEFINITIONS
       |    MIN_VERSION = 1
       |
       |  PROPERTIES
       |    code         = Int32[]
       |    stack        = Int32[]
       |    variables    = Int32[]
       |    strings      = String[]
       |    entry_points = EntryPoint[]
       |    ch           : Int32
       |    result       : Int32
       |    buffer       = StringBuilder()
       |    buffer_stack = StringBuilder[]
       |    tokens       : Token[]
       |
       |    filepath : String
       |    scanner  : Scanner
       |
       |    line   : Int32
       |    column : Int32
       |
       |    start_ip = 0
       |
       |    id_start      = "<id_start>"
       |    id_continue   = "<id_continue>"
       |    id_characters = Array<<Int32>>(128)
       |
       |  METHODS
       |    method init
       |      forEach (ch in id_continue) id_characters[ch->Int32] = 2  # '2' = can be start or continue
       |      forEach (ch in id_start)    id_characters[ch->Int32] = 1  # '1' = can be start only
       |
       |    method on_custom( name_index:Int32 )
       |      # Can override this instead of on_custom(String) for higher efficiency vs string compares.
       |      # name_index can change when the .froley code is updated so don't rely on specific values.
       |      # But one could set up an array of custom function handlers when the tokenizer is constructed
       |      # and then index into that.
       |      on_custom( strings[name_index] )
       |
       |    method on_custom( name:String )
       |      println "*** Unhandled custom operation:$ ***" (name)
       |
       |    method set_mode( new_mode_name:String )
       |      forEach (entry_point in entry_points)
       |        if (entry_point.name == new_mode_name)
       |          start_ip = entry_point.ip
       |          return
       |        endIf
       |      endForEach
       |      throw UnsupportedOperationError( ''No such mode "$".'' (new_mode_name) )
       |
       |    method open( file:File )
       |      if (not file.exists) throw Error( "File not found: $." (file.filepath) )
       |      open( file.filepath, file.load_as_string )
       |
       |    method open( filepath, source:String, start_line=1:Int32, start_column=1:Int32 )
       |      reset
       |      scanner = Scanner( source )
       |      scanner.line = start_line
       |      scanner.column = start_column
       |
       |    method tokenize( mode=null:String )->Token[]
       |      if (mode) set_mode( mode )
       |      tokens = Token[](1024)
       |      execute
       |      return tokens
       |
       |    method reset
       |      stack.clear
       |      ch = 0
       |      result = 0
       |      buffer.clear
       |      start_ip = 0
       |
       |    method add( token_type:Int32 )
       |      local t = Token( TokenType(token_type), filepath, scanner.source, line, column )
       |      if (t.type.attributes & TokenTypeAttribute.CONTENT) t.content = buffer->String
       |      tokens.add( t )
       |
       |    method describe_character( c:Character )->String
       |      if (c == 10 or c == 13)       return "end of line";
       |      elseIf (c == '\'')            return ''"'"''
       |      elseIf (c >= 32 and c != 127) return "'$'" (c)
       |      else                          return "'$'" (c.to_escaped_ascii)
       |
       |    method execute
       |      local ip = start_ip
       |      loop
       |        local opcode = TokenizerOpcode( code[ip] )
       |        #println "$ $" (ip.format("04"),opcode)
       |        ++ip
       |        which (opcode)
       |          case TokenizerOpcode.HALT
       |            return
       |          case TokenizerOpcode.RESTART
       |            buffer.clear
       |            ip = start_ip
       |            nextIteration
       |          case TokenizerOpcode.MODE_INT32
       |            start_ip = code[ ip ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SYNTAX_ERROR
       |            throw_syntax_error
       |          case TokenizerOpcode.SYNTAX_ERROR_BUFFER
       |            throw_buffer_error
       |          case TokenizerOpcode.MARK_SOURCE_POS
       |            line   = scanner.line
       |            column = scanner.column
       |            nextIteration
       |          case TokenizerOpcode.CREATE_INT32
       |            local token_type = code[ ip ]
       |            ++ip
       |            add( token_type )
       |            buffer.clear
       |            nextIteration
       |          case TokenizerOpcode.JUMP
       |            ip = code[ ip ]
       |            nextIteration
       |          case TokenizerOpcode.JUMP_EQ
       |            if (result == 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_NE
       |            if (result != 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_LT
       |            if (result < 0) ip = code[ ip ]
       |            else            ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_LE
       |            if (result <= 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_GT
       |            if (result > 0) ip = code[ ip ]
       |            else            ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_GE
       |            if (result >= 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.CALL
       |            stack.add( ip+1 )
       |            ip = code[ ip ]
       |            nextIteration
       |          case TokenizerOpcode.RETURN
       |            if (stack.is_empty) throw Error( "[INTERNAL]", "'return' on empty stack." )
       |            ip = stack.remove_last
       |            nextIteration
       |          case TokenizerOpcode.HAS_ANOTHER
       |            result = which{ scanner.has_another:1 || 0 }
       |            nextIteration
       |          case TokenizerOpcode.PEEK_CH_INT32
       |            ch = scanner.peek( code[ip] )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.PEEK_CH_VAR
       |            ch = scanner.peek( variables[code[ip]] )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.READ_CH
       |            ch = scanner.read
       |            nextIteration
       |          case TokenizerOpcode.CONSUME_CHARACTER
       |            local value = code[ip]->Character
       |            result = which{ scanner.consume(value):1 || 0 }
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.CONSUME_STRING
       |            block
       |              local st = strings[ code[ip] ]
       |              ++ip
       |              forEach (ch at index in st)
       |                if (ch != scanner.peek(index)) result = 0; escapeBlock
       |              endForEach
       |              result = 1
       |              loop (st.count) scanner.read
       |            endBlock
       |            nextIteration
       |          case TokenizerOpcode.MUST_CONSUME_CHARACTER
       |            local ch = code[ip]->Character
       |            ++ip
       |            if (scanner.consume(ch)) nextIteration
       |            throw_expected_character_error( ch )
       |          case TokenizerOpcode.NEXT_IS_CHARACTER
       |            contingent
       |              necessary (scanner.has_another)
       |              local peek_ch = scanner.peek
       |              local low  = code[ip]->Character
       |              necessary (peek_ch >= low)
       |              local high = code[ip+1]->Character
       |              necessary (peek_ch >= high)
       |              result = 1
       |            unsatisfied
       |              result = 0
       |            endContingent
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.CLEAR_BUFFER
       |            buffer.clear
       |            nextIteration
       |          case TokenizerOpcode.COLLECT_CH
       |            buffer.print( ch->Character )
       |            nextIteration
       |          case TokenizerOpcode.COLLECT_CHARACTER
       |            buffer.print( code[ip]->Character )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.COLLECT_STRING
       |            buffer.print( strings[code[ip]] )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.CUSTOM
       |            ++ip
       |            on_custom( code[ip-1] )
       |            nextIteration
       |          case TokenizerOpcode.BUFFER_TO_LOWERCASE
       |            local lowercase_buffer = StringBuilder.pool.on_use
       |            lowercase_buffer.print( (forEach in buffer).to_lowercase )
       |            StringBuilder.pool.on_end_use( buffer )
       |            buffer = lowercase_buffer
       |            nextIteration
       |          case TokenizerOpcode.COMPARE_BUFFER_STRING
       |            result = buffer.compare_to( strings[code[ip]] )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.COMPARE_CH_INT32
       |            result = ch - code[ip]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.COMPARE_VAR_INT32
       |            result = variables[code[ip]] - code[ip+1]
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.CH_IS_RANGE
       |            result = (ch >= code[ip] and ch <= code[ip+1])
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.SET_CH_TO_INT32
       |            ch = code[ ip ]
       |            result = ch
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SET_CH_TO_VAR
       |            ch = variables[code[ip]]
       |            result = ch
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SET_VAR_TO_INT32
       |            result = code[ip+1]
       |            variables[code[ip]] = result
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.SET_VAR_TO_CH
       |            variables[code[ip]] = ch
       |            result = ch
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SET_RESULT_TO_CH
       |            result = ch
       |            nextIteration
       |          case TokenizerOpcode.SET_RESULT_TO_VAR
       |            result = variables[code[ip]]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SET_RESULT_TO_INT32
       |            result = code[ ip ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.ADD_CH_INT32
       |            ch += code[ ip ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.ADD_VAR_INT32
       |            variables[code[ip]] += code[ip+1]
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.ADD_VAR_VAR
       |            variables[code[ip]] += variables[code[ip+1]]
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.SUB_VAR_VAR
       |            variables[code[ip]] -= variables[code[ip+1]]
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.MUL_VAR_INT32
       |            variables[code[ip]] *= code[ip+1]
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.DIV_VAR_INT32
       |            local d = code[ip+1]
       |            if (d) variables[code[ip]] /= d
       |            ip += 2
       |            nextIteration
       |          case TokenizerOpcode.WHICH_INPUT
       |            local cur_cmd = ip
       |            local lookahead = 0
       |            local last_acceptable_cmd = 0
       |            local last_acceptable_link_count = 0
       |            local last_acceptable_lookahead = 0
       |            loop
       |              local link_count = code[cur_cmd+1]
       |              if (code[cur_cmd])
       |                last_acceptable_cmd = cur_cmd
       |                last_acceptable_link_count = link_count
       |                last_acceptable_lookahead = lookahead
       |              endIf
       |              if (not scanner.has_another(lookahead+1)) escapeLoop
       |              local c = scanner.peek( lookahead )
       |              ip = cur_cmd + 2
       |              contingent
       |                loop (link_count)
       |                  if (c == code[ip])
       |                    cur_cmd = code[ ip+1 ]
       |                    sufficient true
       |                  endIf
       |                  ip += 2
       |                endLoop
       |                escapeLoop
       |              satisfied
       |                ++lookahead
       |              endContingent
       |            endLoop
       |            # Either no links match or EOI - jump to code of last acceptable cmd.
       |            # The start cmd is always acceptable and either contains the
       |            # 'others' case or jumps to the end of the scan table.
       |            ip = last_acceptable_cmd + last_acceptable_link_count * 2 + 2
       |
       |            # Discard the matched input (we know what it is by what case is called)
       |            loop (last_acceptable_lookahead) scanner.read
       |            nextIteration
       |
       |          case TokenizerOpcode.WHICH_BUFFER
       |            local cur_cmd = ip
       |            local start_cmd = cur_cmd
       |            local lookahead = 0
       |            loop
       |              local link_count = code[cur_cmd+1]
       |              if (lookahead == buffer.count) escapeLoop
       |              local c = buffer[ lookahead ]
       |              ip = cur_cmd + 2
       |              contingent
       |                loop (link_count)
       |                  if (c == code[ip])
       |                    cur_cmd = code[ ip+1 ]
       |                    sufficient true
       |                  endIf
       |                  ip += 2
       |                endLoop
       |                escapeLoop
       |              satisfied
       |                ++lookahead
       |              endContingent
       |            endLoop
       |
       |            # Either no links match or EOI
       |            if (code[cur_cmd] == 0 or lookahead < buffer.count)
       |              # Not a complete match; use the 'others' code in the start cmd
       |              cur_cmd = start_cmd
       |            endIf
       |            ip = cur_cmd + code[cur_cmd+1] * 2 + 2
       |            nextIteration
       |
       |          case TokenizerOpcode.TRACE
       |            print( "Line " ).print( code[ip] ).print( " peek:" )
       |            if (scanner.has_another) print( scanner.peek->Character.to_escaped_ascii )
       |            else                     print( "EOI" )
       |            ++ip
       |            print( " ch:$ ($) result:$ vars:$" (Character(ch).to_escaped_ascii,ch,result,variables) )
       |            print( " opcode:" ).println( TokenizerOpcode(code[ip]) )
       |            println( "buffer:" + buffer )
       |            nextIteration
       |          others
       |            throw Error( "[INTERNAL]", "Unhandled tokenizer opcode: " + TokenizerOpcode(opcode) )
       |        endWhich
       |      endLoop
       |
       |    method load( data:Byte[] )
       |      load( DataReader(data) )
       |
       |    method load( reader:DataReader )
       |      local version = reader.read_int32x
       |      require version >= MIN_VERSION
       |
       |      local n = reader.read_int32x
       |      variables.resize( n )
       |      variables[ forEach of variables ] = 0
       |
       |      n = reader.read_int32x
       |      strings.reserve( n )
       |      loop (n) strings.add( reader.read_string )
       |
       |      n = reader.read_int32x
       |      entry_points.reserve( n )
       |      loop (n)
       |        local name = strings[ reader.read_int32x ]
       |        entry_points.add( EntryPoint(name,reader.read_int32x) )
       |      endLoop
       |
       |      n = reader.read_int32x
       |      code.reserve( n )
       |      loop (n) code.add( reader.read_int32x )
       |
       |    method throw_buffer_error
       |      throw Error( filepath, scanner.source, scanner.line, scanner.column, buffer->String )
       |
       |    method throw_expected_character_error( ch:Character )
       |      local message = "Syntax error - expected $, found " (describe_character(ch))
       |      if (scanner.has_another) message += describe_character(scanner.peek) + "."
       |      else                     message += "end of input."
       |      throw Error( filepath, scanner.source, scanner.line, scanner.column, message )
       |
       |    method throw_syntax_error
       |      local builder = StringBuilder()
       |      builder.print "Syntax error - unexpected "
       |      if (not scanner.has_another)
       |        builder.println "end of input."
       |      else
       |        builder.print( describe_character(scanner.peek) ).print( '.' )
       |      endIf
       |      throw Error( filepath, scanner.source, scanner.line, scanner.column, builder->String )
       |endClass
       |
       |class EntryPoint( name:String, ip:Int32 ) [compound]
       |  METHODS
       |    method to->String
       |      return "$ $" (ip.format("04"),name)
       |endClass
       |
endAugment

