module F2

class Organizer : FroleyVisitor
  PROPERTIES
    this_match      : Match

  METHODS
    method visit( cmd:Identifier )->Cmd
      if (is_parser and cmd.name == "content") return TokenContent(cmd.t).dispatch(this)
      return cmd

    method visit( cmd:ScannerCallUserMethod )->Cmd [override]
      program.scanner_user_calls.add( cmd.fn_name )
      return cmd

    method visit( cmd:LiteralStringOrCharacter )->Cmd [override]
      if (cmd.value.count == 1) return LiteralCharacter( cmd.t, cmd.value[0] ).dispatch( this )
      else                      return LiteralString( cmd.t, cmd.value ).dispatch( this )

    method visit( cmd:ParserDef )->Cmd [override]
      if (not cmd.name) cmd.name = "Parser"
      if (program.parser and program.parser is not cmd)
        throw cmd.t.error( "Multiple parsers defined - only one parser can be defined." )
      endIf
      program.parser = cmd
      return prior.visit( cmd )

    method visit( cmd:ProduceAny )->Cmd [override]
      # Add a scan case for each token in the named group
      local t = cmd.t
      local group = program.token_groups[ cmd.token_group_name ]
      if (not group)
        throw t.error( ''No such token group "$".''(cmd.token_group_name) )
      endIf
      forEach (item in group.definitions)
        local def = item as TokenDef
        local expr = LiteralString( t, def.symbol )
        local _case = MatchCase( t, expr, Statements(t,ScannerProduce(t,Access(t,def.name))) )
        this_match.cases.add( _case )
        _case.dispatch( this )
      endForEach
      return null

    method visit( cmd:Routine )->Cmd [override]
      cmd.ip = this_element.routines.count
      this_element.routines[cmd.name] = cmd
      return prior.visit( cmd )

    method visit( cmd:Match )->Cmd [override]
      temporarily this_match = cmd
        return prior.visit( cmd )
      endTemporarily

    method visit( cmd:CreateCmd )->Cmd [override]
      if (not cmd.is_organized)
        cmd.is_organized = true

        cmd.args.dispatch( this )

        # Count number of args
        local args = cmd.args as Args
        cmd.arg_count = args.count
        forEach (arg at index in args)
          block arg = arg as CreateCmdArg
            arg.index = index
            if (arg.arg_value)
              if (not arg.arg_type) arg.arg_type = "String"
            else
              ++cmd.node_arg_count
              arg.is_node_arg = true
              if (not arg.arg_type) arg.arg_type = "Cmd"
            endIf
          endBlock
        endForEach

        # Assign stack-relative offsets
        local stack_offset = -(cmd.node_arg_count)
        forEach (arg in args)
          block arg = arg as CreateCmdArg
            if (arg.is_node_arg)
              arg.stack_offset = stack_offset
              ++stack_offset
            endIf
          endBlock
        endForEach

        use sig_builder = StringBuilder.pool
          sig_builder.print( cmd.name )
          sig_builder.print( "(" )
          if (cmd.args)
            forEach (arg at index in cmd.args as Args)
              block arg = arg as CreateCmdArg
                if (index > 0) sig_builder.print ','
                sig_builder.print(arg.arg_type)
              endBlock
            endForEach
          endIf
          sig_builder.print( ")" )
          cmd.signature = sig_builder->String
        endUse

        local cmd_node_info = program.cmd_node_info[ cmd.name ]
        if (not cmd_node_info)
          cmd_node_info = CmdNodeInfo( cmd.name )
          program.cmd_node_info[ cmd.name ] = cmd_node_info
        endIf
        cmd_node_info.add( cmd )
      endIf

      return prior.visit( cmd )

    method visit( cmd:Subroutine )->Cmd [override]
      cmd.ip = this_element.routines.count
      this_element.routines[cmd.name] = cmd
      return prior.visit( cmd )

    method visit( cmd:ScannerDef )->Cmd [override]
      if (not cmd.name) cmd.name = "Scanner"
      if (program.scanner and program.scanner is not cmd)
        throw cmd.t.error( "Multiple scanners defined - only one scanner can be defined." )
      endIf
      program.scanner = cmd
      return prior.visit( cmd )

endClass

