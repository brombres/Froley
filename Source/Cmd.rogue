# Generated and updated by Froley. Custom changes will not be overwritten; customize as desired.
library Froley

class Cmd( t:Token )
  METHODS
    method add( cmd:Cmd )
      throw UnsupportedOperationError()

    method cast_to( to_type:FType )->Cmd
      if (require_type == to_type) return this  # no cast needed

      which (to_type)
        case FType.LOGICAL:    return CastToLogical( t, this )
        case FType.CHARACTER:  return CastToCharacter( t, this )
        case FType.INT:    return CastToInt( t, this )
        case FType.REAL:       return CastToReal( t, this )
        case FType.TOKEN_TYPE: return CastToTokenType( t, this )
        case FType.STRING:     return CastToString( t, this )
        case FType.PATTERN:    return CastToPattern( t, this )
        others
          throw t.error( "Cannot cast type $ to type: $."(type,to_type) )
      endWhich

    method clear
      throw UnsupportedOperationError()

    method common_type( other:Cmd )->FType
      local a = require_type
      local b = other.require_type
      return FType( a->Int.or_larger(b->Int) )

    method count->Int
      return 0

    method description->String
      return "Cmd"

    method dispatch<<$m,$VisitorType>>( visitor:$VisitorType ) [propagated]
      visitor.$m( this )

    method dispatch<<$m,$VisitorType,$ReturnType>>( visitor:$VisitorType )->$ReturnType [propagated]
      return visitor.$m( this )

    method first->Cmd
      throw UnsupportedOperationError()

    method get( index:Int )->Cmd
      throw UnsupportedOperationError()

    method get<<$AsType>>( index:Int )->$AsType
      return get(index)->(as $AsType)

    method insert( element:Cmd, before_index=0:Int )
      throw UnsupportedOperationError()

    method last->Cmd
      throw UnsupportedOperationError()

    method remove_first->Cmd
      throw UnsupportedOperationError()

    method remove_last->Cmd
      throw UnsupportedOperationError()

    method require_type->FType
      localize type
      if (not type.exists)
        throw t.error( "Variant expected." )
        #throw t.error( "Variant expected.($,$)"(type_name,type) )
      endIf
      return type

    method require_value->Cmd
      require_type
      return this

    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      throw t.error( "Illegal assignment." )

    method set( index:Int, value:Cmd )
      throw UnsupportedOperationError()

    method to->Character
      return Character(this->Int)

    method to->Cmd[]
      throw UnsupportedOperationError()

    method to->Int
      return 0

    method to->Logical
      return (this->Int)?

    method to->Real
      return this->Int

    method to->ScanPattern
      throw t.error( ''Pattern expected.'' )

    method to->String
      return description

    method type->FType
      return FType.NONE
endClass

class CmdList : Cmd
  PROPERTIES
    list = Cmd[]

  METHODS
    method init( t )
      noAction

    method init( t, element:Cmd )
      list.add( element )

    method init( t, element1:Cmd, element2:Cmd )
      list.add( element1 )
      list.add( element2 )

    method add( cmd:Cmd )
      @list.add( cmd )

    method clear
      @list.clear

    method count->Int
      return @list.count

    method description->String
      return "CmdList" + list_description

    method first->Cmd
      return @list.first

    method get( index:Int )->Cmd
      return @list[index]

    method get<<$AsType>>( index:Int )->$AsType
      return @list[index]->(as $AsType)

    method insert( element:Cmd, before_index=0:Int )
      list.insert( element, before_index )

    method last->Cmd
      return @list.last

    method list_description->String
      local builder = String()
      builder.print '['
      forEach (element at index in @list)
        if (index > 0) builder.print ','
        builder.print( %element )
      endForEach
      builder.print ']'
      return builder->String

    method remove_first->Cmd
      return @list.remove_first

    method remove_last->Cmd
      return @list.remove_last

    method set( index:Int, value:Cmd )
      @list[index] = value

    method to->Cmd[]
      return @list

endClass

class Unary( t, operand:Cmd ) : Cmd
  METHODS
    method description->String
      return "Unary($)"(%operand)

    method type->FType
      return operand.type
endClass

class Binary( t, left:Cmd, right:Cmd ) : Cmd
  METHODS
    method description->String
      return "Binary($,$)"(%left,%right)

    method type->FType
      return FType( left.type->Int.or_larger(right.type->Int) )
endClass

class ProgramDef : Cmd
  PROPERTIES
    sections      : Cmd

  METHODS
    method init( t, sections )

    method description->String
      return "ProgramDef($)" (%sections)
endClass

class Element : Cmd
  PROPERTIES
    name         : String
    routine_defs : Cmd
    routines     = [String:FroleyRoutine]
    vars         = [String:Var]

  METHODS
    method init( t, name, routine_defs )

    method define_var( t:Token, name:String, type=FType.NONE:FType )->Var
      local entry = vars.find( name )
      if (not entry)
        local v = Var( t, name, type )
        vars[name] = v
        return v
      endIf

      local existing = entry.value
      if (type != existing.type)
        if (not existing.type.exists)
          existing.type = type
        elseIf (type.exists)
          throw t.error( "Conflicting implicit types $ and $ for variable '$'."...
                         (existing.type,type,name) )
        endIf
      endIf

      return existing

    method var_type( name:String )->FType
      local entry = vars.find( name )
      if (not entry) return FType.NONE
      return entry.value.type
endClass

class ScannerDef : Element
  METHODS
    method description->String
      return "ScannerDef($,$)" (%name,%routine_defs)

endClass

class ParserDef : Element
  METHODS
    method init( t, name, routine_defs )
      prior.init( t, name, routine_defs )
      define_var( t, "disable_output", FType.INT )

    method description->String
      return "ParserDef($,$)" (%name,%routine_defs)

endClass

class TokenGroup : Cmd
  PROPERTIES
    name        : String
    definitions : Cmd

  METHODS
    method init( t, name, definitions )

    method description->String
      return "TokenGroup($,$)" (%name,%definitions)

endClass

class Identifier : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method description->String
      return "Identifier($)" (%name)

    method to->Character
      if (name is null or name.count == 0) return Character(0)
      return name[0]

    method to->Int:  return name
    method to->Logical: return name?
    method to->String: return name

endClass

class FroleyRoutine : Cmd
  PROPERTIES
    name             : String
    attributes       : String
    statements       : Statements

    ip               : Int
    is_primer        : Logical
    is_binary        : Logical
    is_right_binary  : Logical
    is_pre_unary     : Logical
    is_post_unary    : Logical
    is_organized     : Logical

    next_routine     : FroleyRoutine

  METHODS
    method init( t, name, attributes, statements )
      if (attributes)
        which (attributes)
          case "[binary]":       is_binary = true
          case "[primer]":       is_primer = true
          case "[rightBinary]":  is_right_binary = true
          case "[preUnary]":     is_pre_unary = true
          case "[postUnary]":    is_post_unary = true
          others:                throw t.error( "Unrecognized routine attribute $."(attributes) )
        endWhich
      endIf

    method description->String
      return "FroleyRoutine($,$,$)" (%name,%attributes,%statements)
endClass

class Literal : Cmd
  METHODS
    method description->String
      return "Literal"
endClass

class LiteralString : Cmd
  PROPERTIES
    value       : String
    ignore_case : Logical

  METHODS
    method init( t, value, ignore_case=false )

    method cast_to( to_type:FType )->Cmd
      if (to_type == FType.STRING) return this

      which (to_type)
        case FType.LOGICAL:    return LiteralLogical( t, value.equals("true",&ignore_case) )
        case FType.CHARACTER:  return LiteralCharacter( t, value[0] )
        case FType.INT:    return LiteralInteger( t, value->Int )
        case FType.REAL:       return LiteralReal( t, value->Real )
        others
          return prior.cast_to( to_type )
      endWhich

    method description->String
      return "LiteralString($)" (%value)

    method to->Character
      if (value is null or value.count == 0) return Character(0)
      return value[0]

    method to->Int:  return value
    method to->Logical: return value?
    method to->String: return value

    method to->ScanPattern
      return LiteralStringScanPattern( value )

    method type->FType
      return FType.STRING
endClass

class LiteralStringOrCharacter : Cmd
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method cast_to( to_type:FType )->Cmd
      which (to_type)
        case FType.CHARACTER
          if (value.count == 0) return LiteralCharacter( t, 0 )
          return LiteralCharacter( t, value[0] )
        case FType.STRING
          return LiteralString( t, value )
        others
          return prior.cast_to( to_type )
      endWhich

    method description->String
      return "LiteralStringOrCharacter($)" (%value)

    method to->Character
      if (value is null or value.count == 0) return Character(0)
      return value[0]

    method to->Int:  return value
    method to->Logical: return value?
    method to->String: return value

    method type->FType
      return FType.STRING

endClass

class LiteralLogical : Cmd
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method cast_to( to_type:FType )->Cmd
      if (to_type == FType.LOGICAL) return this

      which (to_type)
        case FType.CHARACTER:  return LiteralCharacter( t, which{value:'1'||'0'} )
        case FType.INT:    return LiteralInteger( t, which{value:1||0} )
        case FType.REAL:       return LiteralReal( t, which{value:1||0} )
        case FType.STRING:     return LiteralString( t, which{value:"true"||"false"} )
        others
          return prior.cast_to( to_type )
      endWhich

    method description->String
      return "LiteralLogical($)" (%value)

    method to->Int:   return which{value:1 || 0}
    method to->Logical: return value
    method to->String:  return which{value:"true" || "false"}

    method type->FType
      return FType.LOGICAL
endClass

class LiteralInteger : Cmd
  PROPERTIES
    value : Int

  METHODS
    method init( t, value )

    method cast_to( to_type:FType )->Cmd
      if (to_type == FType.INT) return this
      which (to_type)
        case FType.LOGICAL:    return LiteralLogical( t, value->Logical )
        case FType.CHARACTER:  return LiteralCharacter( t, value->Character )
        case FType.REAL:       return LiteralReal( t, value->Real )
        case FType.STRING:     return LiteralString( t, value->String )
        others
          return prior.cast_to( to_type )
      endWhich

    method description->String
      return "LiteralInteger($)" (%value)

    method to->Int:     return value
    method to->String:    return value

    method type->FType
      return FType.INT
endClass

class LiteralCharacter : Cmd
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method cast_to( to_type:FType )->Cmd
      if (to_type == FType.CHARACTER) return this

      which (to_type)
        case FType.LOGICAL:    return LiteralLogical( t, value->Logical )
        case FType.INT:    return LiteralInteger( t, value->Int )
        case FType.REAL:       return LiteralReal( t, value->Real )
        case FType.STRING:     return LiteralString( t, value->String )
        others
          return prior.cast_to( to_type )
      endWhich

    method description->String
      return "LiteralCharacter($)" (%value)

    method to->Character: return value
    method to->Int:     return value
    method to->String:    return value

    method to->ScanPattern
      return LiteralStringScanPattern( ""+value )

    method type->FType
      return FType.CHARACTER
endClass

class TokenDef : Cmd
  PROPERTIES
    name       : String
    symbol     : String
    attributes : String[]

  METHODS
    method init( t, name, symbol, attributes )

    method init( t, name, symbol, attribute_cmd_list:Cmd )
      if (not String.exists(symbol)) symbol = name
      if (attribute_cmd_list)
        attributes = attribute_cmd_list->(as CmdList).list.map<<String>>( $->String )
      endIf

    method has_attribute( attribute_name:String )->Logical
      if (not attributes) return false
      return attributes.locate(attribute_name)?

    method description->String
      return "TokenDef($,$,$)" (%name,%symbol,%attributes)

endClass

class Symbol : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method description->String
      return "Symbol($)" (%name)

    method to->Character
      if (name is null or name.count == 0) return Character(0)
      return name[0]

    method to->Int:  return name
    method to->Logical: return name?
    method to->String: return name

endClass

class Statements : CmdList
  METHODS
    method description->String
      return "Statements" + list_description
endClass

class If : Cmd
  PROPERTIES
    condition  : Cmd
    statements : Statements
    else_ifs   : Cmd
    _else      : Statements

  METHODS
    method init( t, condition, statements, else_ifs, _else )

    method description->String
      return "If($,$,$,$)" (%condition,%statements,%else_ifs,%_else)

endClass

class Match : Cmd
  PROPERTIES
    expression      : Cmd
    cases           : Cmd
    _others         : Cmd
    id              : String
    table_builder   = ScanTableBuilder()
    statement_lists = Cmd[]

  METHODS
    method init( t, expression, cases, _others )

    method description->String
      return "Match($,$,$)" (%expression,%cases,%_others)

endClass

class While : Cmd
  PROPERTIES
    condition  : Cmd
    statements : Statements

  METHODS
    method init( t, condition, statements )

    method description->String
      return "While($,$)" (%condition,%statements)

endClass

class ScannerCreate : Cmd
  PROPERTIES
    arg : Cmd

  METHODS
    method init( t, arg )

    method description->String
      return "ScannerCreate($)" (%arg)

endClass

class Restart : Cmd
  PROPERTIES
    start_ip : String

  METHODS
    method init( t, start_ip )

    method description->String
      return "Restart($)" (%start_ip)

    method to->Character
      if (start_ip is null or start_ip.count == 0) return Character(0)
      return start_ip[0]

    method to->Int:  return start_ip
    method to->Logical: return start_ip?
    method to->String: return start_ip

endClass

class MatchCase : Cmd
  PROPERTIES
    expression  : Cmd
    statements  : Cmd
    is_resolved : Logical

  METHODS
    method init( t, expression, statements )

    method description->String
      return "MatchCase($,$)" (%expression,%statements)

endClass

class ProduceAny : Cmd
  PROPERTIES
    token_group_name : String

  METHODS
    method init( t, token_group_name )

    method description->String
      return "ProduceAny($)" (%token_group_name)

    method to->Character
      if (token_group_name is null or token_group_name.count == 0) return Character(0)
      return token_group_name[0]

    method to->Int:  return token_group_name
    method to->Logical: return token_group_name?
    method to->String: return token_group_name

endClass

class ElseIf : Cmd
  PROPERTIES
    condition  : Cmd
    statements : Statements

  METHODS
    method init( t, condition, statements )

    method description->String
      return "ElseIf($,$)" (%condition,%statements)

endClass

class Collect : Cmd
  PROPERTIES
    args : Args

  METHODS
    method init( t, args )

    method description->String
      return "Collect($)" (%args)

endClass

class DiscardPosition : Cmd
  METHODS
    method description->String
      return "DiscardPosition"
endClass

class Halt : Cmd
  METHODS
    method description->String
      return "Halt"
endClass

class MarkPosition : Cmd
  METHODS
    method description->String
      return "MarkPosition"
endClass

class Mode : Cmd
  PROPERTIES
    routine_name : String

  METHODS
    method init( t, routine_name )

    method description->String
      return "Mode($)" (%routine_name)

    method to->Character
      if (routine_name is null or routine_name.count == 0) return Character(0)
      return routine_name[0]

    method to->Int:  return routine_name
    method to->Logical: return routine_name?
    method to->String: return routine_name

endClass

class ScannerMustConsume : Cmd
  PROPERTIES
    args : SequenceArgs

  METHODS
    method init( t, args )

    method description->String
      return "ScannerMustConsume($)" (%args)

endClass

class Print : Cmd
  PROPERTIES
    args : Args

  METHODS
    method init( t, args )

    method description->String
      return "Print($)" (%args)

endClass

class Args : CmdList
  METHODS
    method description->String
      return "Args" + list_description
endClass

class Println : Cmd
  PROPERTIES
    args : Args

  METHODS
    method init( t, args )

    method description->String
      return "Println($)" (%args)

endClass

class RestorePosition : Cmd
  METHODS
    method description->String
      return "RestorePosition"
endClass

class Return : Cmd
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value )

    method description->String
      return "Return($)" (%value)

endClass

class SavePosition : Cmd
  METHODS
    method description->String
      return "SavePosition"
endClass

class ThrowSyntaxError : Cmd
  PROPERTIES
    args : Args

  METHODS
    method init( t, args )

    method description->String
      return "ThrowSyntaxError($)" (%args)

endClass

class Increment : Cmd
  PROPERTIES
    target : Cmd

  METHODS
    method init( t, target )

    method description->String
      return "Increment($)" (%target)

endClass

class Decrement : Cmd
  PROPERTIES
    target : Cmd

  METHODS
    method init( t, target )

    method description->String
      return "Decrement($)" (%target)

endClass

class Assign : Cmd
  PROPERTIES
    target    : Cmd
    new_value : Cmd

  METHODS
    method init( t, target, new_value )

    method description->String
      return "Assign($,$)" (%target,%new_value)

endClass

class Access : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method description->String
      return "Access($)" (%name)

    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      local r = resolver.this_element.routines[name]
      if (r) throw t.error( "Illegal assignment to a routine." )
      local v = resolver.this_element.define_var( t, name, cmd.new_value.type )
      return resolver.visit( WriteVar( v, cmd.new_value ) )

    method to->Character
      if (name is null or name.count == 0) return Character(0)
      return name[0]

    method to->Int:  return name
    method to->Logical: return name?
    method to->String: return name

endClass

class CreateCmd : Cmd
  PROPERTIES
    name           : String
    args           : Args
    base_type_name : String

    is_organized   = false
    arg_count      = 0L
    node_arg_count = 0L  # number of node-based args (vs 'content')
    signature      : String

  METHODS
    method init( t, name, args, base_type_name )

    method description->String
      return "CreateCmd($,$)" (%name,%args)

endClass

class CreateCmdArg : Cmd
  PROPERTIES
    arg_name  : String
    arg_value : Cmd
    arg_type  : String

    is_node_arg  = false   # versus 'content'
    index        : Int   # arg index 0, 1, ...
    stack_offset : Int   # back into cmd stack; most recent = -1, one back = -2, ...

  METHODS
    method init( t, arg_name, arg_value, arg_type )

    method description->String
      return "CreateCmdArg($,$,$)" (%arg_name,%arg_value,%arg_type)

endClass

class SequenceArgs : CmdList
  METHODS
    method description->String
      return "SequenceArgs" + list_description
endClass

class PatternSequence : CmdList
  METHODS
    method description->String
      return "PatternSequence" + list_description

    method to->ScanPattern
      local result = ScanPatternList( ScanPattern[] )
      result.add( (forEach in this)->ScanPattern )
      return result

    method type->FType
      return FType.PATTERN
endClass

class ZeroOrMore : Cmd
  PROPERTIES
    pattern : Cmd

  METHODS
    method init( t, pattern )

    method description->String
      return "ZeroOrMore($)" (%pattern)

    method to->ScanPattern
      return ZeroOrMoreScanPattern( pattern->ScanPattern )

    method type->FType
      return FType.PATTERN
endClass

class OneOrMore : Cmd
  PROPERTIES
    pattern : Cmd

  METHODS
    method init( t, pattern )

    method description->String
      return "OneOrMore($)" (%pattern)

    method to->ScanPattern
      return OneOrMoreScanPattern( pattern->ScanPattern )

    method type->FType
      return FType.PATTERN
endClass

class OptionalPattern : Cmd
  PROPERTIES
    pattern : Cmd

  METHODS
    method init( t, pattern )

    method description->String
      return "OptionalPattern($)" (%pattern)

    method to->ScanPattern
      return ZeroOrOneScanPattern( pattern->ScanPattern )

    method type->FType
      return FType.PATTERN
endClass

class CharSet : Cmd
  PROPERTIES
    characters : String

  METHODS
    method init( t, characters )

    method description->String
      return "CharSet($)" (%characters)

    method to->Character
      if (characters is null or characters.count == 0) return Character(0)
      return characters[0]

    method to->Int:  return characters
    method to->Logical: return characters?
    method to->String: return characters

    method to->ScanPattern
      return ScanPatternParser.charset_to_scan_pattern( characters.from(1,characters.count-2) )

    method type->FType
      return FType.PATTERN
endClass

class LogicalBinary : Binary
  METHODS
    method description->String
      return "LogicalBinary($,$)" (%left,%right)

    method type->FType
      return FType.LOGICAL
endClass

class LogicalOr : LogicalBinary
  METHODS
    method description->String
      return "LogicalOr($,$)" (%left,%right)

endClass

class LogicalAnd : LogicalBinary
  METHODS
    method description->String
      return "LogicalAnd($,$)" (%left,%right)

endClass

class CompareEQ : LogicalBinary
  METHODS
    method description->String
      return "CompareEQ($,$)" (%left,%right)

endClass

class CompareNE : LogicalBinary
  METHODS
    method description->String
      return "CompareNE($,$)" (%left,%right)

endClass

class CompareLT : LogicalBinary
  METHODS
    method description->String
      return "CompareLT($,$)" (%left,%right)

endClass

class CompareGT : LogicalBinary
  METHODS
    method description->String
      return "CompareGT($,$)" (%left,%right)

endClass

class CompareLE : LogicalBinary
  METHODS
    method description->String
      return "CompareLE($,$)" (%left,%right)

endClass

class CompareGE : LogicalBinary
  METHODS
    method description->String
      return "CompareGE($,$)" (%left,%right)

endClass

class Add : Binary
  METHODS
    method description->String
      return "Add($,$)" (%left,%right)

endClass

class Subtract : Binary
  METHODS
    method description->String
      return "Subtract($,$)" (%left,%right)

endClass

class Multiply : Binary
  METHODS
    method description->String
      return "Multiply($,$)" (%left,%right)

endClass

class Divide : Binary
  METHODS
    method description->String
      return "Divide($,$)" (%left,%right)

endClass

class Power : Binary
  METHODS
    method description->String
      return "Power($,$)" (%left,%right)

endClass

class Negate : Unary
  METHODS
    method description->String
      return "Negate($)" (%operand)

endClass

class LogicalNot : Unary
  METHODS
    method description->String
      return "LogicalNot($)" (%operand)

    method type->FType
      return FType.LOGICAL
endClass

class ReadBuffer : Cmd
  METHODS
    method description->String
      return "ReadBuffer"

    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      return resolver.visit( WriteBuffer( t, cmd.new_value ) )

    method type->FType
      return FType.STRING
endClass

class ScannerCallUserMethod : Cmd
  PROPERTIES
    fn_name : String

  METHODS
    method init( t, fn_name )

    method description->String
      return "ScannerCallUserMethod($)" (%fn_name)

    method to->Character
      if (fn_name is null or fn_name.count == 0) return Character(0)
      return fn_name[0]

    method to->Int:  return fn_name
    method to->Logical: return fn_name?
    method to->String: return fn_name

    method type->FType
      return FType.INT

endClass

class ScannerConsume : Cmd
  PROPERTIES
    args : SequenceArgs

  METHODS
    method init( t, args )

    method description->String
      return "ScannerConsume($)" (%args)

    method type->FType
      return FType.LOGICAL
endClass

class ScannerHasAnother : Cmd
  METHODS
    method description->String
      return "ScannerHasAnother"

    method type->FType
      return FType.LOGICAL
endClass

class ScannerNextIs : Cmd
  PROPERTIES
    args : SequenceArgs

  METHODS
    method init( t, args )

    method description->String
      return "ScannerNextIs($)" (%args)

    method type->FType
      return FType.LOGICAL
endClass

class ScannerPeek : Cmd
  PROPERTIES
    lookahead : Cmd

  METHODS
    method init( t, lookahead )

    method description->String
      return "ScannerPeek($)" (%lookahead)

    method type->FType
      return FType.CHARACTER
endClass

class ScannerRead : Cmd
  METHODS
    method description->String
      return "ScannerRead"

    method type->FType
      return FType.CHARACTER
endClass

class Scan : Cmd
  PROPERTIES
    args : SequenceArgs

  METHODS
    method init( t, args )

    method description->String
      return "Scan($)" (%args)

    method type->FType
      return FType.LOGICAL
endClass

class On : Cmd
  PROPERTIES
    token_type      : Cmd
    token_types     : Args
    statements      : Statements
    else_ons        : Cmd
    _else_on_others : Statements
    is_organized    : Logical
    is_peek         : Logical

  METHODS
    method init( t, token_type, token_types, statements, else_ons, _else_on_others, is_peek=false )

    method description->String
      local peek = which{ is_peek:"Peek" || "" }
      return "On$($,$,$,$,$)" (peek,%token_type,%token_types,%statements,%else_ons,%_else_on_others)

endClass

class ElseOn : Cmd
  PROPERTIES
    token_type   : Cmd
    token_types  : Args
    statements   : Statements
    is_organized : Logical
    is_peek      : Logical

  METHODS
    method init( t, token_type, token_types, statements, is_peek=false )

    method description->String
      local peek = which{ is_peek:"Peek" || "" }
      return "ElseOn$($,$,$)" (peek,%token_type,%token_types,%statements)

endClass

class BeginList : Cmd
  METHODS
    method description->String
      return "BeginList"
endClass

class ParserCreate : Cmd
  PROPERTIES
    arg : CreateCmd

  METHODS
    method init( t, arg )

    method description->String
      return "ParserCreate($)" (%arg)

endClass

class CreateList : Cmd
  PROPERTIES
    list_type : String

  METHODS
    method init( t, list_type )

    method description->String
      return "CreateList($)" (%list_type)

    method to->Character
      if (list_type is null or list_type.count == 0) return Character(0)
      return list_type[0]

    method to->Int:  return list_type
    method to->Logical: return list_type?
    method to->String: return list_type

endClass

class CreateNull : Cmd
  METHODS
    method description->String
      return "CreateNull"
endClass

class DiscardList : Cmd
  METHODS
    method description->String
      return "DiscardList"
endClass

class ParserMustConsume : Cmd
  PROPERTIES
    token_type : Cmd

  METHODS
    method init( t, token_type )

    method description->String
      return "ParserMustConsume($)" (%token_type)

endClass

class ParserArgs : CmdList
  METHODS
    method description->String
      return "ParserArgs" + list_description
endClass

class ProduceList : Cmd
  PROPERTIES
    list_type : String

  METHODS
    method init( t, list_type )

    method description->String
      return "ProduceList($)" (%list_type)

    method to->Character
      if (list_type is null or list_type.count == 0) return Character(0)
      return list_type[0]

    method to->Int:  return list_type
    method to->Logical: return list_type?
    method to->String: return list_type

endClass

class LiteralContent : Cmd
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method description->String
      return "LiteralContent($)" (%value)

    method to->Character
      if (value is null or value.count == 0) return Character(0)
      return value[0]

    method to->Int:  return value
    method to->Logical: return value?
    method to->String: return value

endClass

class ParserCallUserMethod : Cmd
  PROPERTIES
    fn_name : String

  METHODS
    method init( t, fn_name )

    method description->String
      return "ParserCallUserMethod($)" (%fn_name)

    method to->Character
      if (fn_name is null or fn_name.count == 0) return Character(0)
      return fn_name[0]

    method to->Int:  return fn_name
    method to->Logical: return fn_name?
    method to->String: return fn_name

    method type->FType
      return FType.INT

endClass

class ParserConsume : Cmd
  PROPERTIES
    token_type : Cmd

  METHODS
    method init( t, token_type )

    method description->String
      return "ParserConsume($)" (%token_type)

    method to->FType
      return FType.LOGICAL
endClass

class ParserHasAnother : Cmd
  METHODS
    method description->String
      return "ParserHasAnother"

    method type->FType
      return FType.LOGICAL
endClass

class NextHasAttribute : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method description->String
      return "NextHasAttribute($)" (%name)

    method to->Character
      if (name is null or name.count == 0) return Character(0)
      return name[0]

    method to->Int:  return name
    method to->Logical: return name?
    method to->String: return name

    method type->FType
      return FType.LOGICAL
endClass

class ParserNextIs : Cmd
  PROPERTIES
    token_type : Cmd

  METHODS
    method init( t, token_type )

    method description->String
      return "ParserNextIs($)" (%token_type)

    method to->FType
      return FType.LOGICAL
endClass

class ParserRead : Cmd
  METHODS
    method description->String
      return "ParserRead"

    method type->FType
      return FType.TOKEN
endClass


class TokenContent : Cmd
  METHODS
    method description->String
      return "TokenContent"
endClass


class WriteVar : Cmd
  PROPERTIES
    var       : Var
    new_value : Cmd

  METHODS
    method init( var, new_value )
      t = var.t

    method description->String
      return "WriteVar($,$)" (%var,%new_value)

endClass

class WriteBuffer : Cmd
  PROPERTIES
    new_value : Cmd

  METHODS
    method init( t, new_value )

    method description->String
      return "WriteBuffer($)" (%new_value)

endClass

class Call : Cmd
  PROPERTIES
    routine_def : FroleyRoutine

  METHODS
    method init( t, routine_def )

    method description->String
      return "Call($)" (routine_def.name)

    method type->FType
      return FType.INT

endClass

class LiteralTokenType : Cmd
  PROPERTIES
    token_type : TokenDef

  METHODS
    method init( t, token_type )

    method description->String
      return "LiteralTokenType($)" (%token_type)

    method type->FType
      return FType.TOKEN_TYPE
endClass

class ReadVar : Cmd
  PROPERTIES
    var : Var

  METHODS
    method init( var )
      t = var.t

    method description->String
      return "ReadVar"

    method type->FType
      return var.type
endClass

class CastToLogical : Unary
  METHODS
    method description->String
      return "CastToLogical($)" (%operand)

    method type->FType
      return FType.LOGICAL
endClass

class CastToCharacter : Unary
  METHODS
    method description->String
      return "CastToCharacter($)" (%operand)

    method type->FType
      return FType.CHARACTER

endClass

class CastToInt : Unary
  METHODS
    method description->String
      return "CastToInt($)" (%operand)

    method type->FType
      return FType.INT

endClass

class CastToReal : Unary
  METHODS
    method description->String
      return "CastToReal($)" (%operand)

    method type->FType
      return FType.REAL

endClass

class CastToTokenType : Unary
  METHODS
    method description->String
      return "CastToTokenType($)" (%operand)

    method type->FType
      return FType.TOKEN_TYPE

endClass

class CastToString : Unary
  METHODS
    method description->String
      return "CastToString($)" (%operand)

    method type->FType
      return FType.STRING

endClass

class CastToPattern : Unary
  METHODS
    method description->String
      return "CastToPattern($)" (%operand)

    method type->FType
      return FType.PATTERN

endClass


class LiteralReal : Cmd
  PROPERTIES
    value : Real

  METHODS
    method init( t, value )

    method cast_to( to_type:FType )->Cmd
      if (to_type == FType.REAL) return this
      which (to_type)
        case FType.LOGICAL:    return LiteralLogical( t, value->Logical )
        case FType.CHARACTER:  return LiteralCharacter( t, value->Character )
        case FType.INT:    return LiteralInteger( t, value->Int )
        case FType.STRING:     return LiteralString( t, value->String )
        others
          return prior.cast_to( to_type )
      endWhich

    method description->String
      return "LiteralReal($)" (%value)

    method to->Int:    return value
    method to->Real:   return value
    method to->String: return value

    method type->FType
      return FType.REAL

endClass

class ConsumeContent : Cmd
  PROPERTIES
    content : String

  METHODS
    method init( t, content )

    method description->String
      return "ConsumeContent($)" (%content)

    method to->Character
      if (content is null or content.count == 0) return Character(0)
      return content[0]

    method to->Int:  return content
    method to->Logical: return content?
    method to->String: return content

    method type->FType
      return FType.LOGICAL
endClass

class ConsumeToken : Cmd
  PROPERTIES
    token_type : TokenDef

  METHODS
    method init( t, token_type )

    method description->String
      return "ConsumeToken($)" (%token_type)

    method type->FType
      return FType.LOGICAL
endClass

class MustConsumeContent : Cmd
  PROPERTIES
    content : String

  METHODS
    method init( t, content )

    method description->String
      return "MustConsumeContent($)" (%content)

    method to->Character
      if (content is null or content.count == 0) return Character(0)
      return content[0]

    method to->Int:  return content
    method to->Logical: return content?
    method to->String: return content

endClass

class MustConsumeToken : Cmd
  PROPERTIES
    token_type : TokenDef

  METHODS
    method init( t, token_type )

    method description->String
      return "MustConsumeToken($)" (%token_type)

endClass

class NextIsContent : Cmd
  PROPERTIES
    content : String

  METHODS
    method init( t, content )

    method description->String
      return "NextIsContent($)" (%content)

    method to->Character
      if (content is null or content.count == 0) return Character(0)
      return content[0]

    method to->Int:  return content
    method to->Logical: return content?
    method to->String: return content

    method type->FType
      return FType.LOGICAL
endClass


class NextIsTokenType : Cmd
  PROPERTIES
    token_type : TokenDef

  METHODS
    method init( t, token_type )

    method description->String
      return "NextIsTokenType($)" (%token_type)

    method type->FType
      return FType.LOGICAL
endClass

class Pattern( t, scan_pattern:ScanPattern ) : Cmd
  PROPERTIES
    reference_name : String

  METHODS
    method description->String
      return "Pattern"

    method type->FType
      return FType.PATTERN
endClass

class ScanCharacters : Cmd
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value )

    method description->String
      return "ScanCharacters($)" (%value)

    method type->FType
      return FType.LOGICAL
endClass

class ScanPatternCmd : Cmd
  PROPERTIES
    pattern : Cmd

  METHODS
    method init( t, pattern )

    method description->String
      return "ScanPatternCmd($)" (%pattern)

    method type->FType
      return FType.LOGICAL
endClass

class ConsumeCharacters : Cmd
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value )

    method description->String
      return "ConsumeCharacters($)" (%value)

    method type->FType
      return FType.LOGICAL
endClass

class ConsumePattern : Cmd
  PROPERTIES
    pattern : Cmd

  METHODS
    method init( t, pattern )

    method description->String
      return "ConsumePattern($)" (%pattern)

    method type->FType
      return FType.LOGICAL
endClass

class MustConsumeCharacters : Cmd
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value )

    method description->String
      return "MustConsumeCharacters($)" (%value)

endClass

class MustConsumePattern : Cmd
  PROPERTIES
    pattern : Cmd

  METHODS
    method init( t, pattern )

    method description->String
      return "MustConsumePattern($)" (%pattern)

endClass

class NextIsCharacters : Cmd
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value )

    method description->String
      return "NextIsCharacters($)" (%value)

    method type->FType
      return FType.LOGICAL
endClass

class NextIsPattern : Cmd
  PROPERTIES
    pattern : Cmd

  METHODS
    method init( t, pattern )

    method description->String
      return "NextIsPattern($)" (%pattern)

    method type->FType
      return FType.LOGICAL
endClass

class ConsumeEOLs : Cmd
  METHODS
    method description->String
      return "ConsumeEOLs"
endClass

class ParserProduce : Cmd
  PROPERTIES
    arg : CreateCmd

  METHODS
    method init( t, arg )

    method description->String
      return "ParserProduce($)" (%arg)

endClass

class NativeTypes : CmdList
  METHODS
    method description->String
      return "NativeTypes" + list_description
endClass

class ReadOutput : Cmd
  METHODS
    method description->String
      return "ReadOutput"

    method resolve_assignment( cmd:Assign, resolver:Resolver )->Cmd
      return resolver.visit( WriteOutput( t, cmd.new_value ) )

    method type->FType
      return FType.STRING
endClass

class WriteOutput : Cmd
  PROPERTIES
    new_value : Cmd

  METHODS
    method init( t, new_value )

    method description->String
      return "WriteOutput($)" (%new_value)

endClass

class TokenList : Cmd
  PROPERTIES
    tokens : Token[]

  METHODS
    method init( t )
      tokens = Token[]

    method init( t, tokens )

    method init( existing:TokenList )
      tokens = existing.tokens.cloned

    method description->String
      return "TokenList($)"(tokens)

    method to->Token[]
      return tokens
endClass


class CreateTokenList : Cmd
  METHODS
    method description->String
      return "CreateTokenList"
endClass

class ProduceTokenList : Cmd
  METHODS
    method description->String
      return "ProduceTokenList"
endClass

class NativeLiteral : Cmd
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method init( existing:NativeLiteral )
      prior.init( existing )
      value = existing.value

    method description->String
      return "NativeLiteral($)" (%value)

    method to->Character
      return Cmd.to_character(value)

    method to->Int:  return value
    method to->Logical: return value?
    method to->String: return value

endClass

class ParserPop : Cmd
  PROPERTIES
    var : Access

  METHODS
    method init( t, var )

    method init( existing:ParserPop )
      prior.init( existing )
      if (existing.var) var = existing.var.cloned

    method description->String
      return "ParserPop($)" (%var)

endClass

class ParserPush : Cmd
  PROPERTIES
    var : Access

  METHODS
    method init( t, var )

    method init( existing:ParserPush )
      prior.init( existing )
      if (existing.var) var = existing.var.cloned

    method description->String
      return "ParserPush($)" (%var)

endClass

class CreateTokenListPreservingStack : Cmd
  METHODS
    method description->String
      return "CreateTokenListPreservingStack"
endClass

class ProduceTokenListPreservingStack : Cmd
  METHODS
    method description->String
      return "ProduceTokenListPreservingStack"
endClass

class ParserDuplicate : Cmd
  METHODS
    method description->String
      return "ParserDuplicate"
endClass
